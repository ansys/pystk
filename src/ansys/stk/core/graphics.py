################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################ 

__all__ = ["AGICustomTerrainOverlay", "AGICustomTerrainOverlayFactory", "AGIProcessedImageGlobeOverlay", "AGIProcessedImageGlobeOverlayFactory", 
"AGIProcessedTerrainOverlay", "AGIProcessedTerrainOverlayFactory", "AGIRoamImageGlobeOverlay", "AGIRoamImageGlobeOverlayFactory", 
"AgEStkGraphicsAntiAliasing", "AgEStkGraphicsBinaryLogicOperation", "AgEStkGraphicsBlurMethod", "AgEStkGraphicsCameraSnapshotFileFormat", 
"AgEStkGraphicsCameraVideoFormat", "AgEStkGraphicsConstrainedUpAxis", "AgEStkGraphicsCullFace", "AgEStkGraphicsCylinderFill", 
"AgEStkGraphicsEdgeDetectMethod", "AgEStkGraphicsFlipAxis", "AgEStkGraphicsFontStyle", "AgEStkGraphicsGlobeOverlayRole", 
"AgEStkGraphicsGradientDetectMethod", "AgEStkGraphicsIndicesOrderHint", "AgEStkGraphicsInternalTextureFormat", "AgEStkGraphicsJpeg2000CompressionProfile", 
"AgEStkGraphicsKmlNetworkLinkRefreshMode", "AgEStkGraphicsKmlNetworkLinkViewRefreshMode", "AgEStkGraphicsMagnificationFilter", 
"AgEStkGraphicsMaintainAspectRatio", "AgEStkGraphicsMapProjection", "AgEStkGraphicsMarkerBatchRenderPass", "AgEStkGraphicsMarkerBatchRenderingMethod", 
"AgEStkGraphicsMarkerBatchSizeSource", "AgEStkGraphicsMarkerBatchSortOrder", "AgEStkGraphicsMarkerBatchUnit", "AgEStkGraphicsMinificationFilter", 
"AgEStkGraphicsModelTransformationType", "AgEStkGraphicsModelUpAxis", "AgEStkGraphicsOrigin", "AgEStkGraphicsOutlineAppearance", 
"AgEStkGraphicsPathPrimitiveRemoveLocation", "AgEStkGraphicsPolylineType", "AgEStkGraphicsPrimitivesSortOrder", "AgEStkGraphicsRasterBand", 
"AgEStkGraphicsRasterFormat", "AgEStkGraphicsRasterOrientation", "AgEStkGraphicsRasterType", "AgEStkGraphicsRefreshRate", 
"AgEStkGraphicsRenderPass", "AgEStkGraphicsRenderPassHint", "AgEStkGraphicsRendererShadeModel", "AgEStkGraphicsScreenOverlayOrigin", 
"AgEStkGraphicsScreenOverlayPinningOrigin", "AgEStkGraphicsScreenOverlayUnit", "AgEStkGraphicsSetHint", "AgEStkGraphicsSharpenMethod", 
"AgEStkGraphicsStereoProjectionMode", "AgEStkGraphicsStereoscopicDisplayMode", "AgEStkGraphicsSurfaceMeshRenderingMethod", 
"AgEStkGraphicsTextureWrap", "AgEStkGraphicsVideoPlayback", "AgEStkGraphicsVisibility", "AgEStkGraphicsWindingOrder", "AlphaFromLuminanceFilter", 
"AlphaFromLuminanceFilterFactory", "AlphaFromPixelFilter", "AlphaFromPixelFilterFactory", "AlphaFromRasterFilter", "AlphaFromRasterFilterFactory", 
"AltitudeDisplayCondition", "AltitudeDisplayConditionFactory", "AxesPrimitive", "AxesPrimitiveFactory", "BandExtractFilter", 
"BandExtractFilterFactory", "BandOrderFilter", "BandOrderFilterFactory", "BatchPrimitiveIndex", "BlurFilter", "BlurFilterFactory", 
"BoundingSphere", "BoundingSphereFactory", "BoxTriangulatorInitializer", "BrightnessFilter", "BrightnessFilterFactory", 
"Camera", "CameraSnapshot", "CameraVideoRecording", "CentralBodyGraphics", "CentralBodyGraphicsIndexer", "Clouds", "ColorToLuminanceFilter", 
"ColorToLuminanceFilterFactory", "CompositeDisplayCondition", "CompositeDisplayConditionFactory", "CompositePrimitive", 
"CompositePrimitiveFactory", "ConstantDisplayCondition", "ConstantDisplayConditionFactory", "ContrastFilter", "ContrastFilterFactory", 
"ConvolutionFilter", "ConvolutionFilterFactory", "CustomImageGlobeOverlay", "CustomImageGlobeOverlayPluginActivator", "CustomImageGlobeOverlayPluginActivatorFactory", 
"CustomImageGlobeOverlayPluginProxy", "CylinderTriangulatorInitializer", "DisplayCondition", "DistanceDisplayCondition", 
"DistanceDisplayConditionFactory", "DistanceToGlobeOverlayDisplayCondition", "DistanceToGlobeOverlayDisplayConditionFactory", 
"DistanceToPositionDisplayCondition", "DistanceToPositionDisplayConditionFactory", "DistanceToPrimitiveDisplayCondition", 
"DistanceToPrimitiveDisplayConditionFactory", "DurationPathPrimitiveUpdatePolicy", "DurationPathPrimitiveUpdatePolicyFactory", 
"EdgeDetectFilter", "EdgeDetectFilterFactory", "EllipsoidTriangulatorInitializer", "ExtrudedPolylineTriangulatorInitializer", 
"ExtrudedPolylineTriangulatorResult", "FactoryAndInitializers", "FilteringRasterStream", "FilteringRasterStreamFactory", 
"FlipFilter", "FlipFilterFactory", "FrameRate", "GammaCorrectionFilter", "GammaCorrectionFilterFactory", "GaussianBlurFilter", 
"GaussianBlurFilterFactory", "GeospatialImageGlobeOverlay", "GeospatialImageGlobeOverlayFactory", "GlobeImageOverlay", "GlobeImageOverlayAddCompleteEventArgs", 
"GlobeImageOverlayInitializer", "GlobeOverlay", "GlobeOverlaySettings", "GradientDetectFilter", "GradientDetectFilterFactory", 
"GraphicsFont", "GraphicsFontFactory", "GreatArcInterpolator", "GreatArcInterpolatorFactory", "IAGICustomTerrainOverlay", 
"IAGICustomTerrainOverlayFactory", "IAGIProcessedImageGlobeOverlay", "IAGIProcessedImageGlobeOverlayFactory", "IAGIProcessedTerrainOverlay", 
"IAGIProcessedTerrainOverlayFactory", "IAGIRoamImageGlobeOverlay", "IAGIRoamImageGlobeOverlayFactory", "IAlphaFromLuminanceFilter", 
"IAlphaFromLuminanceFilterFactory", "IAlphaFromPixelFilter", "IAlphaFromPixelFilterFactory", "IAlphaFromRasterFilter", "IAlphaFromRasterFilterFactory", 
"IAltitudeDisplayCondition", "IAltitudeDisplayConditionFactory", "IAxesPrimitive", "IAxesPrimitiveFactory", "IBandExtractFilter", 
"IBandExtractFilterFactory", "IBandOrderFilter", "IBandOrderFilterFactory", "IBatchPrimitiveIndex", "IBlurFilter", "IBlurFilterFactory", 
"IBoundingSphere", "IBoundingSphereFactory", "IBoxTriangulatorInitializer", "IBrightnessFilter", "IBrightnessFilterFactory", 
"ICamera", "ICameraSnapshot", "ICameraVideoRecording", "ICentralBodyGraphics", "ICentralBodyGraphicsIndexer", "IClouds", 
"IColorToLuminanceFilter", "IColorToLuminanceFilterFactory", "ICompositeDisplayCondition", "ICompositeDisplayConditionFactory", 
"ICompositePrimitive", "ICompositePrimitiveFactory", "IConstantDisplayCondition", "IConstantDisplayConditionFactory", "IContrastFilter", 
"IContrastFilterFactory", "IConvolutionFilter", "IConvolutionFilterFactory", "ICustomImageGlobeOverlay", "ICustomImageGlobeOverlayPluginActivator", 
"ICustomImageGlobeOverlayPluginActivatorFactory", "ICustomImageGlobeOverlayPluginProxy", "ICylinderTriangulatorInitializer", 
"IDisplayCondition", "IDistanceDisplayCondition", "IDistanceDisplayConditionFactory", "IDistanceToGlobeOverlayDisplayCondition", 
"IDistanceToGlobeOverlayDisplayConditionFactory", "IDistanceToPositionDisplayCondition", "IDistanceToPositionDisplayConditionFactory", 
"IDistanceToPrimitiveDisplayCondition", "IDistanceToPrimitiveDisplayConditionFactory", "IDurationPathPrimitiveUpdatePolicy", 
"IDurationPathPrimitiveUpdatePolicyFactory", "IEdgeDetectFilter", "IEdgeDetectFilterFactory", "IEllipsoidTriangulatorInitializer", 
"IExtrudedPolylineTriangulatorInitializer", "IExtrudedPolylineTriangulatorResult", "IFactoryAndInitializers", "IFilteringRasterStream", 
"IFilteringRasterStreamFactory", "IFlipFilter", "IFlipFilterFactory", "IFrameRate", "IGammaCorrectionFilter", "IGammaCorrectionFilterFactory", 
"IGaussianBlurFilter", "IGaussianBlurFilterFactory", "IGeospatialImageGlobeOverlay", "IGeospatialImageGlobeOverlayFactory", 
"IGlobeImageOverlay", "IGlobeImageOverlayAddCompleteEventArgs", "IGlobeImageOverlayInitializer", "IGlobeOverlay", "IGlobeOverlaySettings", 
"IGradientDetectFilter", "IGradientDetectFilterFactory", "IGraphicsFont", "IGraphicsFontFactory", "IGreatArcInterpolator", 
"IGreatArcInterpolatorFactory", "IImageCollection", "IJpeg2000WriterInitializer", "IKmlContainer", "IKmlDocument", "IKmlDocumentCollection", 
"IKmlDocumentLoadedEventArgs", "IKmlFeature", "IKmlFeatureCollection", "IKmlFolder", "IKmlGraphics", "IKmlNetworkLink", 
"ILevelsFilter", "ILevelsFilterFactory", "ILighting", "IMarkerBatchPrimitive", "IMarkerBatchPrimitiveFactory", "IMarkerBatchPrimitiveOptionalParameters", 
"IMarkerBatchPrimitiveOptionalParametersFactory", "IMaximumCountPathPrimitiveUpdatePolicy", "IMaximumCountPathPrimitiveUpdatePolicyFactory", 
"IModelArticulation", "IModelArticulationCollection", "IModelPrimitive", "IModelPrimitiveFactory", "IModelTransformation", 
"IObjectCollection", "IOverlay", "IPathPoint", "IPathPointCollection", "IPathPointFactory", "IPathPrimitive", "IPathPrimitiveFactory", 
"IPathPrimitiveUpdatePolicy", "IPickResult", "IPickResultCollection", "IPixelSizeDisplayCondition", "IPixelSizeDisplayConditionFactory", 
"IPointBatchPrimitive", "IPointBatchPrimitiveFactory", "IPointBatchPrimitiveOptionalParameters", "IPointBatchPrimitiveOptionalParametersFactory", 
"IPolylinePrimitive", "IPolylinePrimitiveFactory", "IPolylinePrimitiveOptionalParameters", "IPolylinePrimitiveOptionalParametersFactory", 
"IPositionInterpolator", "IPrimitive", "IPrimitiveManager", "IProjectedRasterOverlay", "IProjectedRasterOverlayFactory", 
"IProjection", "IProjectionFactory", "IProjectionRasterStreamPluginActivator", "IProjectionRasterStreamPluginActivatorFactory", 
"IProjectionRasterStreamPluginProxy", "IProjectionStream", "IRaster", "IRasterAttributes", "IRasterAttributesFactory", "IRasterFactory", 
"IRasterFilter", "IRasterImageGlobeOverlay", "IRasterImageGlobeOverlayFactory", "IRasterStream", "IRendererTexture2D", "IRendererTextureTemplate2D", 
"IRenderingEventArgs", "IRhumbLineInterpolator", "IRhumbLineInterpolatorFactory", "IRotateFilter", "IRotateFilterFactory", 
"IScene", "ISceneCollection", "ISceneDisplayCondition", "ISceneDisplayConditionFactory", "ISceneGlobeOverlaySettings", "ISceneManager", 
"ISceneManagerInitializer", "IScreenOverlay", "IScreenOverlayCollection", "IScreenOverlayCollectionBase", "IScreenOverlayContainer", 
"IScreenOverlayFactory", "IScreenOverlayManager", "IScreenOverlayPickResult", "IScreenOverlayPickResultCollection", "ISequenceFilter", 
"ISequenceFilterFactory", "ISharpenFilter", "ISharpenFilterFactory", "ISolidPrimitive", "ISolidPrimitiveFactory", "ISolidTriangulatorResult", 
"IStereoscopic", "ISurfaceExtentTriangulatorInitializer", "ISurfaceMeshPrimitive", "ISurfaceMeshPrimitiveFactory", "ISurfacePolygonTriangulatorInitializer", 
"ISurfaceShapesInitializer", "ISurfaceShapesResult", "ISurfaceTriangulatorResult", "ITerrainOverlay", "ITerrainOverlayAddCompleteEventArgs", 
"ITerrainOverlayCollection", "ITerrainOverlayInitializer", "ITextBatchPrimitive", "ITextBatchPrimitiveFactory", "ITextBatchPrimitiveOptionalParameters", 
"ITextBatchPrimitiveOptionalParametersFactory", "ITextOverlay", "ITextOverlayFactory", "ITexture2DFactory", "ITextureFilter2D", 
"ITextureFilter2DFactory", "ITextureMatrix", "ITextureMatrixFactory", "ITextureScreenOverlay", "ITextureScreenOverlayFactory", 
"ITimeIntervalDisplayCondition", "ITimeIntervalDisplayConditionFactory", "ITriangleMeshPrimitive", "ITriangleMeshPrimitiveFactory", 
"ITriangleMeshPrimitiveOptionalParameters", "ITriangleMeshPrimitiveOptionalParametersFactory", "ITriangulatorResult", "IVectorPrimitive", 
"IVectorPrimitiveFactory", "IVideoStream", "IVideoStreamFactory", "IVisualEffects", "ImageCollection", "Jpeg2000WriterInitializer", 
"KmlContainer", "KmlDocument", "KmlDocumentCollection", "KmlDocumentLoadedEventArgs", "KmlFeature", "KmlFeatureCollection", 
"KmlFolder", "KmlGraphics", "KmlNetworkLink", "LevelsFilter", "LevelsFilterFactory", "Lighting", "MarkerBatchPrimitive", 
"MarkerBatchPrimitiveFactory", "MarkerBatchPrimitiveOptionalParameters", "MarkerBatchPrimitiveOptionalParametersFactory", 
"MaximumCountPathPrimitiveUpdatePolicy", "MaximumCountPathPrimitiveUpdatePolicyFactory", "ModelArticulation", "ModelArticulationCollection", 
"ModelPrimitive", "ModelPrimitiveFactory", "ModelTransformation", "ObjectCollection", "Overlay", "PathPoint", "PathPointCollection", 
"PathPointFactory", "PathPrimitive", "PathPrimitiveFactory", "PathPrimitiveUpdatePolicy", "PickResult", "PickResultCollection", 
"PixelSizeDisplayCondition", "PixelSizeDisplayConditionFactory", "PointBatchPrimitive", "PointBatchPrimitiveFactory", "PointBatchPrimitiveOptionalParameters", 
"PointBatchPrimitiveOptionalParametersFactory", "PolylinePrimitive", "PolylinePrimitiveFactory", "PolylinePrimitiveOptionalParameters", 
"PolylinePrimitiveOptionalParametersFactory", "PositionInterpolator", "Primitive", "PrimitiveManager", "ProjectedRasterOverlay", 
"ProjectedRasterOverlayFactory", "Projection", "ProjectionFactory", "ProjectionRasterStreamPluginActivator", "ProjectionRasterStreamPluginActivatorFactory", 
"ProjectionRasterStreamPluginProxy", "ProjectionStream", "Raster", "RasterAttributes", "RasterAttributesFactory", "RasterFactory", 
"RasterFilter", "RasterImageGlobeOverlay", "RasterImageGlobeOverlayFactory", "RasterStream", "RendererTexture2D", "RendererTextureTemplate2D", 
"RenderingEventArgs", "RhumbLineInterpolator", "RhumbLineInterpolatorFactory", "RotateFilter", "RotateFilterFactory", "Scene", 
"SceneCollection", "SceneDisplayCondition", "SceneDisplayConditionFactory", "SceneGlobeOverlaySettings", "SceneManager", 
"SceneManagerInitializer", "ScreenOverlay", "ScreenOverlayCollection", "ScreenOverlayCollectionBase", "ScreenOverlayFactory", 
"ScreenOverlayManager", "ScreenOverlayPickResult", "ScreenOverlayPickResultCollection", "SequenceFilter", "SequenceFilterFactory", 
"SharpenFilter", "SharpenFilterFactory", "SolidPrimitive", "SolidPrimitiveFactory", "SolidTriangulatorResult", "Stereoscopic", 
"SurfaceExtentTriangulatorInitializer", "SurfaceMeshPrimitive", "SurfaceMeshPrimitiveFactory", "SurfacePolygonTriangulatorInitializer", 
"SurfaceShapesInitializer", "SurfaceShapesResult", "SurfaceTriangulatorResult", "TerrainOverlay", "TerrainOverlayAddCompleteEventArgs", 
"TerrainOverlayCollection", "TerrainOverlayInitializer", "TextBatchPrimitive", "TextBatchPrimitiveFactory", "TextBatchPrimitiveOptionalParameters", 
"TextBatchPrimitiveOptionalParametersFactory", "TextOverlay", "TextOverlayFactory", "Texture2DFactory", "TextureFilter2D", 
"TextureFilter2DFactory", "TextureMatrix", "TextureMatrixFactory", "TextureScreenOverlay", "TextureScreenOverlayFactory", 
"TimeIntervalDisplayCondition", "TimeIntervalDisplayConditionFactory", "TriangleMeshPrimitive", "TriangleMeshPrimitiveFactory", 
"TriangleMeshPrimitiveOptionalParameters", "TriangleMeshPrimitiveOptionalParametersFactory", "TriangulatorResult", "VectorPrimitive", 
"VectorPrimitiveFactory", "VideoStream", "VideoStreamFactory", "VisualEffects"]

import typing

from ctypes   import byref, POINTER
from enum     import IntEnum, IntFlag

try:
    from numpy import ndarray # noqa
except ModuleNotFoundError:
    pass
    
try:
    from pandas import DataFrame # noqa
except ModuleNotFoundError:
    pass

from .internal  import comutil          as agcom
from .internal  import coclassutil      as agcls
from .internal  import marshall         as agmarshall
from .utilities import colors           as agcolor
from .internal.comutil     import IUnknown, IPictureDisp, IAGFUNCTYPE, IEnumVARIANT
from .internal.eventutil   import *
from .utilities.exceptions import *

from .stkutil import *
from .vgt import *


def _raise_uninitialized_error(*args):
    raise STKRuntimeError("Valid STK object model classes are returned from STK methods and should not be created independently.")

class AgEStkGraphicsCylinderFill(IntFlag):
    """Cylinder faces that can be filled."""
    # Fill the cylinder's wall.
    eStkGraphicsCylinderFillWall = 1
    # Fill the cylinder's bottom cap.
    eStkGraphicsCylinderFillBottomCap = 2
    # Fill the cylinder's top cap.
    eStkGraphicsCylinderFillTopCap = 4
    # Completely fill the cylinder, including its wall, bottom, and top cap.
    eStkGraphicsCylinderFillAll = 7

AgEStkGraphicsCylinderFill.eStkGraphicsCylinderFillWall.__doc__ = "Fill the cylinder's wall."
AgEStkGraphicsCylinderFill.eStkGraphicsCylinderFillBottomCap.__doc__ = "Fill the cylinder's bottom cap."
AgEStkGraphicsCylinderFill.eStkGraphicsCylinderFillTopCap.__doc__ = "Fill the cylinder's top cap."
AgEStkGraphicsCylinderFill.eStkGraphicsCylinderFillAll.__doc__ = "Completely fill the cylinder, including its wall, bottom, and top cap."

agcls.AgTypeNameMap["AgEStkGraphicsCylinderFill"] = AgEStkGraphicsCylinderFill

class AgEStkGraphicsWindingOrder(IntEnum):
    """Specifies the order for positions or front facing triangles. Winding order is important for triangulation and backface culling."""
    # Positions or triangles are defined in counter-clockwise order.
    eStkGraphicsWindingOrderCounterClockwise = 0
    # Positions or triangles are defined in clockwise order.
    eStkGraphicsWindingOrderClockwise = 1
    # The winding order is unknown and should be computed. For best performance, only use this value if you do not know the actual winding order.
    eStkGraphicsWindingOrderCompute = 2

AgEStkGraphicsWindingOrder.eStkGraphicsWindingOrderCounterClockwise.__doc__ = "Positions or triangles are defined in counter-clockwise order."
AgEStkGraphicsWindingOrder.eStkGraphicsWindingOrderClockwise.__doc__ = "Positions or triangles are defined in clockwise order."
AgEStkGraphicsWindingOrder.eStkGraphicsWindingOrderCompute.__doc__ = "The winding order is unknown and should be computed. For best performance, only use this value if you do not know the actual winding order."

agcls.AgTypeNameMap["AgEStkGraphicsWindingOrder"] = AgEStkGraphicsWindingOrder

class AgEStkGraphicsCameraSnapshotFileFormat(IntEnum):
    """When using camera snapshot or camera video recording to save a snapshot to a file, this specifies the file format."""
    # BMP file format
    eStkGraphicsCameraSnapshotFileFormatBmp = 0
    # TIFF file format
    eStkGraphicsCameraSnapshotFileFormatTiff = 2
    # JPEG file format
    eStkGraphicsCameraSnapshotFileFormatJpeg = 3
    # PNG file format
    eStkGraphicsCameraSnapshotFileFormatPng = 4

AgEStkGraphicsCameraSnapshotFileFormat.eStkGraphicsCameraSnapshotFileFormatBmp.__doc__ = "BMP file format"
AgEStkGraphicsCameraSnapshotFileFormat.eStkGraphicsCameraSnapshotFileFormatTiff.__doc__ = "TIFF file format"
AgEStkGraphicsCameraSnapshotFileFormat.eStkGraphicsCameraSnapshotFileFormatJpeg.__doc__ = "JPEG file format"
AgEStkGraphicsCameraSnapshotFileFormat.eStkGraphicsCameraSnapshotFileFormatPng.__doc__ = "PNG file format"

agcls.AgTypeNameMap["AgEStkGraphicsCameraSnapshotFileFormat"] = AgEStkGraphicsCameraSnapshotFileFormat

class AgEStkGraphicsCameraVideoFormat(IntEnum):
    """When using camera video recording to record a video, this specifies the file format."""
    # H.264 file format
    eStkGraphicsCameraVideoFormatH264 = 0
    # Windows Media Video (WMV) file format
    eStkGraphicsCameraVideoFormatWMV = 1

AgEStkGraphicsCameraVideoFormat.eStkGraphicsCameraVideoFormatH264.__doc__ = "H.264 file format"
AgEStkGraphicsCameraVideoFormat.eStkGraphicsCameraVideoFormatWMV.__doc__ = "Windows Media Video (WMV) file format"

agcls.AgTypeNameMap["AgEStkGraphicsCameraVideoFormat"] = AgEStkGraphicsCameraVideoFormat

class AgEStkGraphicsConstrainedUpAxis(IntEnum):
    """When setting the camera'saxes, this defines which axis of the axes is up in screen space, where up is from the bottom to the top of the screen."""
    # The X axis is constrained.
    eStkGraphicsConstrainedUpAxisX = 0
    # The Y axis is constrained.
    eStkGraphicsConstrainedUpAxisY = 1
    # The Z axis is constrained.
    eStkGraphicsConstrainedUpAxisZ = 2
    # The negative X axis is constrained.
    eStkGraphicsConstrainedUpAxisNegativeX = 3
    # The negative Y axis is constrained.
    eStkGraphicsConstrainedUpAxisNegativeY = 4
    # The negative Z axis is constrained.
    eStkGraphicsConstrainedUpAxisNegativeZ = 5
    # No axis is contained.
    eStkGraphicsConstrainedUpAxisNone = 6

AgEStkGraphicsConstrainedUpAxis.eStkGraphicsConstrainedUpAxisX.__doc__ = "The X axis is constrained."
AgEStkGraphicsConstrainedUpAxis.eStkGraphicsConstrainedUpAxisY.__doc__ = "The Y axis is constrained."
AgEStkGraphicsConstrainedUpAxis.eStkGraphicsConstrainedUpAxisZ.__doc__ = "The Z axis is constrained."
AgEStkGraphicsConstrainedUpAxis.eStkGraphicsConstrainedUpAxisNegativeX.__doc__ = "The negative X axis is constrained."
AgEStkGraphicsConstrainedUpAxis.eStkGraphicsConstrainedUpAxisNegativeY.__doc__ = "The negative Y axis is constrained."
AgEStkGraphicsConstrainedUpAxis.eStkGraphicsConstrainedUpAxisNegativeZ.__doc__ = "The negative Z axis is constrained."
AgEStkGraphicsConstrainedUpAxis.eStkGraphicsConstrainedUpAxisNone.__doc__ = "No axis is contained."

agcls.AgTypeNameMap["AgEStkGraphicsConstrainedUpAxis"] = AgEStkGraphicsConstrainedUpAxis

class AgEStkGraphicsGlobeOverlayRole(IntEnum):
    """The role of a globe overlay."""
    # The globe overlay is a base image.
    eStkGraphicsGlobeOverlayRoleBase = 0
    # The globe overlay is a base image that is only displayed on the area of the central body that is not lit by the sun.
    eStkGraphicsGlobeOverlayRoleNight = 1
    # The globe overlay is a base image that shows the glint of the sun on the central body.
    eStkGraphicsGlobeOverlayRoleSpecular = 2
    # The globe overlay is a normal overlay without a special role.
    eStkGraphicsGlobeOverlayRoleNormal = 4
    # The role of the globe overlay isn't set.
    eStkGraphicsGlobeOverlayRoleNone = 5

AgEStkGraphicsGlobeOverlayRole.eStkGraphicsGlobeOverlayRoleBase.__doc__ = "The globe overlay is a base image."
AgEStkGraphicsGlobeOverlayRole.eStkGraphicsGlobeOverlayRoleNight.__doc__ = "The globe overlay is a base image that is only displayed on the area of the central body that is not lit by the sun."
AgEStkGraphicsGlobeOverlayRole.eStkGraphicsGlobeOverlayRoleSpecular.__doc__ = "The globe overlay is a base image that shows the glint of the sun on the central body."
AgEStkGraphicsGlobeOverlayRole.eStkGraphicsGlobeOverlayRoleNormal.__doc__ = "The globe overlay is a normal overlay without a special role."
AgEStkGraphicsGlobeOverlayRole.eStkGraphicsGlobeOverlayRoleNone.__doc__ = "The role of the globe overlay isn't set."

agcls.AgTypeNameMap["AgEStkGraphicsGlobeOverlayRole"] = AgEStkGraphicsGlobeOverlayRole

class AgEStkGraphicsIndicesOrderHint(IntEnum):
    """An optimization hint optionally provided to a primitive'sSetPartial method to enhance performance."""
    # The indices passed to SetPartial are not sorted. Therefore, the primitive may sort them to improve performance of writing its geometry to video memory.
    eStkGraphicsIndicesOrderHintNotSorted = 0
    # The indices passed to SetPartial are sorted in ascending order. Therefore, the primitive does not need to sort them. It is recommended to only use SortedAscending if it is easy and efficient for you to provide the indices in ascending order...
    eStkGraphicsIndicesOrderHintSortedAscending = 1

AgEStkGraphicsIndicesOrderHint.eStkGraphicsIndicesOrderHintNotSorted.__doc__ = "The indices passed to SetPartial are not sorted. Therefore, the primitive may sort them to improve performance of writing its geometry to video memory."
AgEStkGraphicsIndicesOrderHint.eStkGraphicsIndicesOrderHintSortedAscending.__doc__ = "The indices passed to SetPartial are sorted in ascending order. Therefore, the primitive does not need to sort them. It is recommended to only use SortedAscending if it is easy and efficient for you to provide the indices in ascending order..."

agcls.AgTypeNameMap["AgEStkGraphicsIndicesOrderHint"] = AgEStkGraphicsIndicesOrderHint

class AgEStkGraphicsMaintainAspectRatio(IntEnum):
    """Specifies whether the aspect ratio of a texture will be maintained during sizing of a screen overlay."""
    # The aspect ratio of the texture is not maintained during sizing of the screen overlay.
    eStkGraphicsMaintainAspectRatioNone = 0
    # The aspect ratio of the texture is maintained based on the width property of the screen overlay. When used, the height property is ignored and the height is automatically calculated based on the aspect ratio of the texture and the overlay's width property.
    eStkGraphicsMaintainAspectRatioWidth = 1
    # The aspect ratio of the texture is maintained based on the height property of the screen overlay. When used, the width property is ignored and the width is automatically calculated based on the aspect ratio of the texture and the overlay's height property.
    eStkGraphicsMaintainAspectRatioHeight = 2

AgEStkGraphicsMaintainAspectRatio.eStkGraphicsMaintainAspectRatioNone.__doc__ = "The aspect ratio of the texture is not maintained during sizing of the screen overlay."
AgEStkGraphicsMaintainAspectRatio.eStkGraphicsMaintainAspectRatioWidth.__doc__ = "The aspect ratio of the texture is maintained based on the width property of the screen overlay. When used, the height property is ignored and the height is automatically calculated based on the aspect ratio of the texture and the overlay's width property."
AgEStkGraphicsMaintainAspectRatio.eStkGraphicsMaintainAspectRatioHeight.__doc__ = "The aspect ratio of the texture is maintained based on the height property of the screen overlay. When used, the width property is ignored and the width is automatically calculated based on the aspect ratio of the texture and the overlay's height property."

agcls.AgTypeNameMap["AgEStkGraphicsMaintainAspectRatio"] = AgEStkGraphicsMaintainAspectRatio

class AgEStkGraphicsMapProjection(IntEnum):
    """The projection of the pixel data returned from a custom image globe overlay."""
    # Mercator projection
    eStkGraphicsMapProjectionMercator = 0
    # Equidistant Cylindrical projection
    eStkGraphicsMapProjectionEquidistantCylindrical = 1

AgEStkGraphicsMapProjection.eStkGraphicsMapProjectionMercator.__doc__ = "Mercator projection"
AgEStkGraphicsMapProjection.eStkGraphicsMapProjectionEquidistantCylindrical.__doc__ = "Equidistant Cylindrical projection"

agcls.AgTypeNameMap["AgEStkGraphicsMapProjection"] = AgEStkGraphicsMapProjection

class AgEStkGraphicsMarkerBatchRenderingMethod(IntEnum):
    """Rendering methods available for use by the marker batch primitive. Different methods may have different performance characteristics and require different video card support. When in doubt, use Automatic."""
    # Render the marker batch using a geometry shader. Requires `OpenGL <https://www.opengl.org/>`_ 3.0 or 2.0 with the `ARB_geometry_shader4 <https://registry.khronos.org/OpenGL/extensions/ARB/ARB_geometry_shader4.txt>`_ extension.
    eStkGraphicsMarkerBatchRenderingMethodGeometryShader = 0
    # Render the marker batch using a vertex shader. Requires OpenGL 2.0 or 1.5 with the following `extensions <https://www.opengl.org/registry/>`_: <ul><li><a href='https://www.opengl.org/registry/specs/ARB/vertex_shader...
    eStkGraphicsMarkerBatchRenderingMethodVertexShader = 1
    # Render the marker batch using an automatically selected method based on the capabilities of the video card.
    eStkGraphicsMarkerBatchRenderingMethodAutomatic = 2
    # Render the marker batch using the fixed function pipeline. Generally, this is the slowest method but it supports all video cards.
    eStkGraphicsMarkerBatchRenderingMethodFixedFunction = 3

AgEStkGraphicsMarkerBatchRenderingMethod.eStkGraphicsMarkerBatchRenderingMethodGeometryShader.__doc__ = "Render the marker batch using a geometry shader. Requires `OpenGL <https://www.opengl.org/>`_ 3.0 or 2.0 with the `ARB_geometry_shader4 <https://registry.khronos.org/OpenGL/extensions/ARB/ARB_geometry_shader4.txt>`_ extension."
AgEStkGraphicsMarkerBatchRenderingMethod.eStkGraphicsMarkerBatchRenderingMethodVertexShader.__doc__ = "Render the marker batch using a vertex shader. Requires OpenGL 2.0 or 1.5 with the following `extensions <https://www.opengl.org/registry/>`_: <ul><li><a href='https://www.opengl.org/registry/specs/ARB/vertex_shader..."
AgEStkGraphicsMarkerBatchRenderingMethod.eStkGraphicsMarkerBatchRenderingMethodAutomatic.__doc__ = "Render the marker batch using an automatically selected method based on the capabilities of the video card."
AgEStkGraphicsMarkerBatchRenderingMethod.eStkGraphicsMarkerBatchRenderingMethodFixedFunction.__doc__ = "Render the marker batch using the fixed function pipeline. Generally, this is the slowest method but it supports all video cards."

agcls.AgTypeNameMap["AgEStkGraphicsMarkerBatchRenderingMethod"] = AgEStkGraphicsMarkerBatchRenderingMethod

class AgEStkGraphicsMarkerBatchRenderPass(IntEnum):
    """The pass during which the marker batch is rendered."""
    # The marker batch contains all opaque textures and therefore should be rendered using the opaque pass.
    eStkGraphicsMarkerBatchRenderPassOpaque = 0
    # The marker batch contains textures with translucency and therefore should be rendered using the translucent pass. For correct blending of overlapping textures, also consider using back to front.
    eStkGraphicsMarkerBatchRenderPassTranslucent = 1
    # The marker batch render pass should be determined based on the marker batch's translucency. This includes the translucency set per marker when SetColors is used.
    eStkGraphicsMarkerBatchRenderPassBasedOnTranslucency = 2

AgEStkGraphicsMarkerBatchRenderPass.eStkGraphicsMarkerBatchRenderPassOpaque.__doc__ = "The marker batch contains all opaque textures and therefore should be rendered using the opaque pass."
AgEStkGraphicsMarkerBatchRenderPass.eStkGraphicsMarkerBatchRenderPassTranslucent.__doc__ = "The marker batch contains textures with translucency and therefore should be rendered using the translucent pass. For correct blending of overlapping textures, also consider using back to front."
AgEStkGraphicsMarkerBatchRenderPass.eStkGraphicsMarkerBatchRenderPassBasedOnTranslucency.__doc__ = "The marker batch render pass should be determined based on the marker batch's translucency. This includes the translucency set per marker when SetColors is used."

agcls.AgTypeNameMap["AgEStkGraphicsMarkerBatchRenderPass"] = AgEStkGraphicsMarkerBatchRenderPass

class AgEStkGraphicsMarkerBatchSizeSource(IntEnum):
    """Determines which marker batch property is used to size each marker in a marker batch."""
    # The size of each marker is the same as the size of its texture. If the marker is not textured, the user defined size is used instead.
    eStkGraphicsMarkerBatchSizeSourceFromTexture = 0
    # The size of each marker in the marker batch is user defined. Either all markers have the same size (size) or each marker has a user defined size (SetSizes).
    eStkGraphicsMarkerBatchSizeSourceUserDefined = 1

AgEStkGraphicsMarkerBatchSizeSource.eStkGraphicsMarkerBatchSizeSourceFromTexture.__doc__ = "The size of each marker is the same as the size of its texture. If the marker is not textured, the user defined size is used instead."
AgEStkGraphicsMarkerBatchSizeSource.eStkGraphicsMarkerBatchSizeSourceUserDefined.__doc__ = "The size of each marker in the marker batch is user defined. Either all markers have the same size (size) or each marker has a user defined size (SetSizes)."

agcls.AgTypeNameMap["AgEStkGraphicsMarkerBatchSizeSource"] = AgEStkGraphicsMarkerBatchSizeSource

class AgEStkGraphicsMarkerBatchSortOrder(IntEnum):
    """The order in which markers in a marker batch are sorted before rendering."""
    # The markers are sorted in back to front order before rendering. For overlapping translucent markers, this enables correct blending results...
    eStkGraphicsMarkerBatchSortOrderBackToFront = 0
    # The markers are sorted in front to back order before rendering. For overlapping opaque markers, this can enable the GPU to quickly eliminate markers that are hidden behind other markers...
    eStkGraphicsMarkerBatchSortOrderFrontToBack = 1
    # The markers are sorted by texture. This minimizes costly texture changes during rendering and does not require resorting when the camera moves or a marker changes position.
    eStkGraphicsMarkerBatchSortOrderByTexture = 2

AgEStkGraphicsMarkerBatchSortOrder.eStkGraphicsMarkerBatchSortOrderBackToFront.__doc__ = "The markers are sorted in back to front order before rendering. For overlapping translucent markers, this enables correct blending results..."
AgEStkGraphicsMarkerBatchSortOrder.eStkGraphicsMarkerBatchSortOrderFrontToBack.__doc__ = "The markers are sorted in front to back order before rendering. For overlapping opaque markers, this can enable the GPU to quickly eliminate markers that are hidden behind other markers..."
AgEStkGraphicsMarkerBatchSortOrder.eStkGraphicsMarkerBatchSortOrderByTexture.__doc__ = "The markers are sorted by texture. This minimizes costly texture changes during rendering and does not require resorting when the camera moves or a marker changes position."

agcls.AgTypeNameMap["AgEStkGraphicsMarkerBatchSortOrder"] = AgEStkGraphicsMarkerBatchSortOrder

class AgEStkGraphicsMarkerBatchUnit(IntEnum):
    """The unit for marker sizes in a marker batch."""
    # The size of a marker is defined in pixels. As the camera zooms in and out the size of the marker doesn't change.
    eStkGraphicsMarkerBatchUnitPixels = 0
    # The size of a marker is defined in meters.
    eStkGraphicsMarkerBatchUnitMeters = 1

AgEStkGraphicsMarkerBatchUnit.eStkGraphicsMarkerBatchUnitPixels.__doc__ = "The size of a marker is defined in pixels. As the camera zooms in and out the size of the marker doesn't change."
AgEStkGraphicsMarkerBatchUnit.eStkGraphicsMarkerBatchUnitMeters.__doc__ = "The size of a marker is defined in meters."

agcls.AgTypeNameMap["AgEStkGraphicsMarkerBatchUnit"] = AgEStkGraphicsMarkerBatchUnit

class AgEStkGraphicsModelTransformationType(IntEnum):
    """Transformation types that define the way a model transformation changes the geometry of the model articulation it is associated with."""
    # Translates the geometry along the X axis.
    eStkGraphicsModelTransformationTypeTranslateX = 0
    # Translates the geometry along the Y axis.
    eStkGraphicsModelTransformationTypeTranslateY = 1
    # Translates the geometry along the Z axis.
    eStkGraphicsModelTransformationTypeTranslateZ = 2
    # Rotates the geometry about the X axis.
    eStkGraphicsModelTransformationTypeRotateX = 3
    # Rotates the geometry about the Y axis.
    eStkGraphicsModelTransformationTypeRotateY = 4
    # Rotates the geometry about the Z axis.
    eStkGraphicsModelTransformationTypeRotateZ = 5
    # Scales the geometry along the X axis.
    eStkGraphicsModelTransformationTypeScaleX = 6
    # Scales the geometry along the Y axis.
    eStkGraphicsModelTransformationTypeScaleY = 7
    # Scales the geometry along the Z axis.
    eStkGraphicsModelTransformationTypeScaleZ = 8
    # Scales the geometry uniformly along the X, Y, and Z axes.
    eStkGraphicsModelTransformationTypeScaleUniform = 9
    # Translates the texture associated with the geometry along the X axis.
    eStkGraphicsModelTransformationTypeTextureTranslateX = 10
    # Translates the texture associated with the geometry along the Y axis.
    eStkGraphicsModelTransformationTypeTextureTranslateY = 11
    # Translates the texture associated with the geometry along the Z axis.
    eStkGraphicsModelTransformationTypeTextureTranslateZ = 12
    # Rotates the texture associated with the geometry about the X axis.
    eStkGraphicsModelTransformationTypeTextureRotateX = 13
    # Rotates the texture associated with the geometry about the Y axis.
    eStkGraphicsModelTransformationTypeTextureRotateY = 14
    # Rotates the texture associated with the geometry about the Z axis.
    eStkGraphicsModelTransformationTypeTextureRotateZ = 15
    # Scales the texture associated with the geometry along the X axis.
    eStkGraphicsModelTransformationTypeTextureScaleX = 16
    # Scales the texture associated with the geometry along the Y axis.
    eStkGraphicsModelTransformationTypeTextureScaleY = 17
    # Scales the texture associated with the geometry along the Z axis.
    eStkGraphicsModelTransformationTypeTextureScaleZ = 18
    # Scales the texture associated with the geometry uniformly along the X, Y, and Z axes.
    eStkGraphicsModelTransformationTypeTextureScaleUniform = 19
    # Translates the red band of color associated with the geometry.
    eStkGraphicsModelTransformationTypeTranslateRed = 20
    # Translates the green band of color associated with the geometry.
    eStkGraphicsModelTransformationTypeTranslateGreen = 21
    # Translates the blue band of color associated with the geometry.
    eStkGraphicsModelTransformationTypeTranslateBlue = 22

AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTranslateX.__doc__ = "Translates the geometry along the X axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTranslateY.__doc__ = "Translates the geometry along the Y axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTranslateZ.__doc__ = "Translates the geometry along the Z axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeRotateX.__doc__ = "Rotates the geometry about the X axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeRotateY.__doc__ = "Rotates the geometry about the Y axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeRotateZ.__doc__ = "Rotates the geometry about the Z axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeScaleX.__doc__ = "Scales the geometry along the X axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeScaleY.__doc__ = "Scales the geometry along the Y axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeScaleZ.__doc__ = "Scales the geometry along the Z axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeScaleUniform.__doc__ = "Scales the geometry uniformly along the X, Y, and Z axes."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTextureTranslateX.__doc__ = "Translates the texture associated with the geometry along the X axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTextureTranslateY.__doc__ = "Translates the texture associated with the geometry along the Y axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTextureTranslateZ.__doc__ = "Translates the texture associated with the geometry along the Z axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTextureRotateX.__doc__ = "Rotates the texture associated with the geometry about the X axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTextureRotateY.__doc__ = "Rotates the texture associated with the geometry about the Y axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTextureRotateZ.__doc__ = "Rotates the texture associated with the geometry about the Z axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTextureScaleX.__doc__ = "Scales the texture associated with the geometry along the X axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTextureScaleY.__doc__ = "Scales the texture associated with the geometry along the Y axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTextureScaleZ.__doc__ = "Scales the texture associated with the geometry along the Z axis."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTextureScaleUniform.__doc__ = "Scales the texture associated with the geometry uniformly along the X, Y, and Z axes."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTranslateRed.__doc__ = "Translates the red band of color associated with the geometry."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTranslateGreen.__doc__ = "Translates the green band of color associated with the geometry."
AgEStkGraphicsModelTransformationType.eStkGraphicsModelTransformationTypeTranslateBlue.__doc__ = "Translates the blue band of color associated with the geometry."

agcls.AgTypeNameMap["AgEStkGraphicsModelTransformationType"] = AgEStkGraphicsModelTransformationType

class AgEStkGraphicsOrigin(IntEnum):
    """Vertical and horizontal origin."""
    # The object's origin is its bottom, left corner.
    eStkGraphicsOriginBottomLeft = 0
    # The object's origin is its bottom, center point.
    eStkGraphicsOriginBottomCenter = 1
    # The object's origin is its bottom, right corner.
    eStkGraphicsOriginBottomRight = 2
    # The object's origin is its center, left point.
    eStkGraphicsOriginCenterLeft = 3
    # The object's origin is its center.
    eStkGraphicsOriginCenter = 4
    # The object's origin is its center, right point.
    eStkGraphicsOriginCenterRight = 5
    # The object's origin is its top, left corner.
    eStkGraphicsOriginTopLeft = 6
    # The object's origin is its top, center point.
    eStkGraphicsOriginTopCenter = 7
    # The object's origin is its top, right corner.
    eStkGraphicsOriginTopRight = 8

AgEStkGraphicsOrigin.eStkGraphicsOriginBottomLeft.__doc__ = "The object's origin is its bottom, left corner."
AgEStkGraphicsOrigin.eStkGraphicsOriginBottomCenter.__doc__ = "The object's origin is its bottom, center point."
AgEStkGraphicsOrigin.eStkGraphicsOriginBottomRight.__doc__ = "The object's origin is its bottom, right corner."
AgEStkGraphicsOrigin.eStkGraphicsOriginCenterLeft.__doc__ = "The object's origin is its center, left point."
AgEStkGraphicsOrigin.eStkGraphicsOriginCenter.__doc__ = "The object's origin is its center."
AgEStkGraphicsOrigin.eStkGraphicsOriginCenterRight.__doc__ = "The object's origin is its center, right point."
AgEStkGraphicsOrigin.eStkGraphicsOriginTopLeft.__doc__ = "The object's origin is its top, left corner."
AgEStkGraphicsOrigin.eStkGraphicsOriginTopCenter.__doc__ = "The object's origin is its top, center point."
AgEStkGraphicsOrigin.eStkGraphicsOriginTopRight.__doc__ = "The object's origin is its top, right corner."

agcls.AgTypeNameMap["AgEStkGraphicsOrigin"] = AgEStkGraphicsOrigin

class AgEStkGraphicsPathPrimitiveRemoveLocation(IntEnum):
    """Represents the location of a point to be removed."""
    # Remove from the front of the line.
    eStkGraphicsRemoveLocationFront = 0
    # Remove from the back of the line.
    eStkGraphicsRemoveLocationBack = 1

AgEStkGraphicsPathPrimitiveRemoveLocation.eStkGraphicsRemoveLocationFront.__doc__ = "Remove from the front of the line."
AgEStkGraphicsPathPrimitiveRemoveLocation.eStkGraphicsRemoveLocationBack.__doc__ = "Remove from the back of the line."

agcls.AgTypeNameMap["AgEStkGraphicsPathPrimitiveRemoveLocation"] = AgEStkGraphicsPathPrimitiveRemoveLocation

class AgEStkGraphicsPrimitivesSortOrder(IntEnum):
    """The order in which primitives are sorted before rendering."""
    # Primitives are sorted by their internal state before rendering. This provides good performance but can lead to blending artifacts with translucent primitives along the same line of sight.
    eStkGraphicsPrimitivesSortOrderByState = 0
    # Primitives are sorted in back to front order before rendering. For translucent primitives, this enables correct blending results. This may not perform as well as PrimitivesSortOrderByState since the CPU has to sort the primitives before rendering.
    eStkGraphicsPrimitivesSortOrderBackToFront = 1

AgEStkGraphicsPrimitivesSortOrder.eStkGraphicsPrimitivesSortOrderByState.__doc__ = "Primitives are sorted by their internal state before rendering. This provides good performance but can lead to blending artifacts with translucent primitives along the same line of sight."
AgEStkGraphicsPrimitivesSortOrder.eStkGraphicsPrimitivesSortOrderBackToFront.__doc__ = "Primitives are sorted in back to front order before rendering. For translucent primitives, this enables correct blending results. This may not perform as well as PrimitivesSortOrderByState since the CPU has to sort the primitives before rendering."

agcls.AgTypeNameMap["AgEStkGraphicsPrimitivesSortOrder"] = AgEStkGraphicsPrimitivesSortOrder

class AgEStkGraphicsRefreshRate(IntEnum):
    """The rate at which animation frames will occur."""
    # The animation will occur as fast as possible. The maximum frame rate is the refresh rate of the display or is the maximum that video card is capable of if the video card's vertical sync is off.
    eStkGraphicsRefreshRateFastest = 0
    # The animation will target a specified frame rate.
    eStkGraphicsRefreshRateTargetedFramesPerSecond = 1

AgEStkGraphicsRefreshRate.eStkGraphicsRefreshRateFastest.__doc__ = "The animation will occur as fast as possible. The maximum frame rate is the refresh rate of the display or is the maximum that video card is capable of if the video card's vertical sync is off."
AgEStkGraphicsRefreshRate.eStkGraphicsRefreshRateTargetedFramesPerSecond.__doc__ = "The animation will target a specified frame rate."

agcls.AgTypeNameMap["AgEStkGraphicsRefreshRate"] = AgEStkGraphicsRefreshRate

class AgEStkGraphicsRenderPass(IntFlag):
    """Describes when a primitive will be rendered. Some primitives need to be rendered during or at a certain time. For example, translucent primitives need to be rendered after opaque primitives to allow proper blending..."""
    # Render during the opaque rendering pass.
    eStkGraphicsRenderPassOpaque = 1
    # Render during the translucent rendering pass.
    eStkGraphicsRenderPassTranslucent = 2
    # Render before the central body is rendered.
    eStkGraphicsRenderPassCentralBodyClipped = 4
    # Rendered in an ordered composite before all other primitives and before the central body is rendered.
    eStkGraphicsRenderPassOrderedCompositeCentralBodyClipped = 8
    # Rendered in an ordered composite before all primitives but after the central body is rendered.
    eStkGraphicsRenderPassOrderedComposite = 16
    # Render after the terrain is rendered.
    eStkGraphicsRenderPassTerrain = 32

AgEStkGraphicsRenderPass.eStkGraphicsRenderPassOpaque.__doc__ = "Render during the opaque rendering pass."
AgEStkGraphicsRenderPass.eStkGraphicsRenderPassTranslucent.__doc__ = "Render during the translucent rendering pass."
AgEStkGraphicsRenderPass.eStkGraphicsRenderPassCentralBodyClipped.__doc__ = "Render before the central body is rendered."
AgEStkGraphicsRenderPass.eStkGraphicsRenderPassOrderedCompositeCentralBodyClipped.__doc__ = "Rendered in an ordered composite before all other primitives and before the central body is rendered."
AgEStkGraphicsRenderPass.eStkGraphicsRenderPassOrderedComposite.__doc__ = "Rendered in an ordered composite before all primitives but after the central body is rendered."
AgEStkGraphicsRenderPass.eStkGraphicsRenderPassTerrain.__doc__ = "Render after the terrain is rendered."

agcls.AgTypeNameMap["AgEStkGraphicsRenderPass"] = AgEStkGraphicsRenderPass

class AgEStkGraphicsRenderPassHint(IntEnum):
    """An optimization hint optionally provided to a primitive'sSet method to enhance performance when per-position colors are used."""
    # The collection of colors contains only opaque colors. This implies that each color's alpha component is 255.
    eStkGraphicsRenderPassHintOpaque = 0
    # The collection of colors contains translucent colors. This implies that at least one color has an alpha component that is not 255.
    eStkGraphicsRenderPassHintTranslucent = 1
    # It is unknown if the collection of colors contains opaque or translucent colors.
    eStkGraphicsRenderPassHintUnknown = 2

AgEStkGraphicsRenderPassHint.eStkGraphicsRenderPassHintOpaque.__doc__ = "The collection of colors contains only opaque colors. This implies that each color's alpha component is 255."
AgEStkGraphicsRenderPassHint.eStkGraphicsRenderPassHintTranslucent.__doc__ = "The collection of colors contains translucent colors. This implies that at least one color has an alpha component that is not 255."
AgEStkGraphicsRenderPassHint.eStkGraphicsRenderPassHintUnknown.__doc__ = "It is unknown if the collection of colors contains opaque or translucent colors."

agcls.AgTypeNameMap["AgEStkGraphicsRenderPassHint"] = AgEStkGraphicsRenderPassHint

class AgEStkGraphicsScreenOverlayOrigin(IntEnum):
    """Specifies the origin of a screen overlay, as well as the direction of the horizontal and vertical axes. The origin specifies both the origin in the parent overlay's coordinate system and the origin within the overlay itself that is positioned."""
    # When the X and Y position are both set to 0, this value places the bottom, left corner of the overlay in its parent's bottom, left corner. Increasing X values move the overlay to the right and increasing Y values move it up.
    eStkGraphicsScreenOverlayOriginBottomLeft = 0
    # When the X and Y position are both set to 0, this value places the bottom edge of the overlay at its parent's bottom edge and the center of the overlay is horizontally centered within its parent...
    eStkGraphicsScreenOverlayOriginBottomCenter = 1
    # When the X and Y position are both set to 0, this value places the bottom, right corner of the overlay in its parent's bottom, right corner. Increasing X values move the overlay to the left and increasing Y values move it up.
    eStkGraphicsScreenOverlayOriginBottomRight = 2
    # When the X and Y position are both set to 0, this value places the left edge of the overlay at its parent's left edge and the center of the overlay is vertically centered within its parent...
    eStkGraphicsScreenOverlayOriginCenterLeft = 3
    # When the X and Y position are both set to 0, this value places the center of the overlay at its parent's center. Increasing X values move the overlay to the right and increasing Y values move it up.
    eStkGraphicsScreenOverlayOriginCenter = 4
    # When the X and Y position are both set to 0, this value places the right edge of the overlay at its parent's right edge and the center of the overlay is vertically centered within its parent...
    eStkGraphicsScreenOverlayOriginCenterRight = 5
    # When the X and Y position are both set to 0, this value places the top, left corner of the overlay in its parent's top, left corner. Increasing X values move the overlay to the right and increasing Y values move it down.
    eStkGraphicsScreenOverlayOriginTopLeft = 6
    # When the X and Y position are both set to 0, this value places the top edge of the overlay at its parent's top edge and the center of the overlay is horizontally centered within its parent...
    eStkGraphicsScreenOverlayOriginTopCenter = 7
    # When the X and Y position are both set to 0, this value places the top, right corner of the overlay in its parent's top, right corner. Increasing X values move the overlay to the left and increasing Y values move it down.
    eStkGraphicsScreenOverlayOriginTopRight = 8

AgEStkGraphicsScreenOverlayOrigin.eStkGraphicsScreenOverlayOriginBottomLeft.__doc__ = "When the X and Y position are both set to 0, this value places the bottom, left corner of the overlay in its parent's bottom, left corner. Increasing X values move the overlay to the right and increasing Y values move it up."
AgEStkGraphicsScreenOverlayOrigin.eStkGraphicsScreenOverlayOriginBottomCenter.__doc__ = "When the X and Y position are both set to 0, this value places the bottom edge of the overlay at its parent's bottom edge and the center of the overlay is horizontally centered within its parent..."
AgEStkGraphicsScreenOverlayOrigin.eStkGraphicsScreenOverlayOriginBottomRight.__doc__ = "When the X and Y position are both set to 0, this value places the bottom, right corner of the overlay in its parent's bottom, right corner. Increasing X values move the overlay to the left and increasing Y values move it up."
AgEStkGraphicsScreenOverlayOrigin.eStkGraphicsScreenOverlayOriginCenterLeft.__doc__ = "When the X and Y position are both set to 0, this value places the left edge of the overlay at its parent's left edge and the center of the overlay is vertically centered within its parent..."
AgEStkGraphicsScreenOverlayOrigin.eStkGraphicsScreenOverlayOriginCenter.__doc__ = "When the X and Y position are both set to 0, this value places the center of the overlay at its parent's center. Increasing X values move the overlay to the right and increasing Y values move it up."
AgEStkGraphicsScreenOverlayOrigin.eStkGraphicsScreenOverlayOriginCenterRight.__doc__ = "When the X and Y position are both set to 0, this value places the right edge of the overlay at its parent's right edge and the center of the overlay is vertically centered within its parent..."
AgEStkGraphicsScreenOverlayOrigin.eStkGraphicsScreenOverlayOriginTopLeft.__doc__ = "When the X and Y position are both set to 0, this value places the top, left corner of the overlay in its parent's top, left corner. Increasing X values move the overlay to the right and increasing Y values move it down."
AgEStkGraphicsScreenOverlayOrigin.eStkGraphicsScreenOverlayOriginTopCenter.__doc__ = "When the X and Y position are both set to 0, this value places the top edge of the overlay at its parent's top edge and the center of the overlay is horizontally centered within its parent..."
AgEStkGraphicsScreenOverlayOrigin.eStkGraphicsScreenOverlayOriginTopRight.__doc__ = "When the X and Y position are both set to 0, this value places the top, right corner of the overlay in its parent's top, right corner. Increasing X values move the overlay to the left and increasing Y values move it down."

agcls.AgTypeNameMap["AgEStkGraphicsScreenOverlayOrigin"] = AgEStkGraphicsScreenOverlayOrigin

class AgEStkGraphicsScreenOverlayPinningOrigin(IntEnum):
    """Specifies the origin of the pinning position of the screen overlay, as well as the direction of the horizontal and vertical axes for that pinning position. The pinning origin specifies the origin of the pinning position in the overlay's coordinate system."""
    # When the X and Y pinning position are both set to 0, this value places the pinning position in the overlay's bottom, left corner. Increasing X values move the pinning position to the right and increasing Y values move it up.
    eStkGraphicsScreenOverlayPinningOriginBottomLeft = 0
    # When the X and Y pinning position are both set to 0, this value places the pinning position at its overlay's bottom edge and the pinning position is horizontally centered within its overlay...
    eStkGraphicsScreenOverlayPinningOriginBottomCenter = 1
    # When the X and Y pinning position are both set to 0, this value places the pinning position in its overlay's bottom, right corner. Increasing X values move the pinning position to the left and increasing Y values move it up.
    eStkGraphicsScreenOverlayPinningOriginBottomRight = 2
    # When the X and Y pinning position are both set to 0, this value places the pinning position at its overlay's left edge and the pinning position is vertically centered within its overlay...
    eStkGraphicsScreenOverlayPinningOriginCenterLeft = 3
    # When the X and Y pinning position are both set to 0, this value places the pinning position at its overlay's center. Increasing X values move the pinning position to the right and increasing Y values move it up.
    eStkGraphicsScreenOverlayPinningOriginCenter = 4
    # When the X and Y pinning pinning position are both set to 0, this value places the pinning position at its overlay's right edge and the pinning position is vertically centered within its overlay...
    eStkGraphicsScreenOverlayPinningOriginCenterRight = 5
    # When the X and Y pinning position are both set to 0, this value places the pinning position in its overlay's top, left corner. Increasing X values move the pinning position to the right and increasing Y values move it down.
    eStkGraphicsScreenOverlayPinningOriginTopLeft = 6
    # When the X and Y pinning position are both set to 0, this value places the pinning position at its overlays's top edge and the pinning position is horizontally centered within its overlay...
    eStkGraphicsScreenOverlayPinningOriginTopCenter = 7
    # When the X and Y pinning position are both set to 0, this value places the pinning position in its overlay's top, right corner. Increasing X values move the pinning position to the left and increasing Y values move it down.
    eStkGraphicsScreenOverlayPinningOriginTopRight = 8
    # The pinning origin is automatically set to the origin of the overlay. For instance, if the origin of the overlay is ScreenOverlayOrigin.BottomLeft, the pinning origin will also be equivalent to ScreenOverlayPinningOrigin.BottomLeft.
    eStkGraphicsScreenOverlayPinningOriginAutomatic = 9

AgEStkGraphicsScreenOverlayPinningOrigin.eStkGraphicsScreenOverlayPinningOriginBottomLeft.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position in the overlay's bottom, left corner. Increasing X values move the pinning position to the right and increasing Y values move it up."
AgEStkGraphicsScreenOverlayPinningOrigin.eStkGraphicsScreenOverlayPinningOriginBottomCenter.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position at its overlay's bottom edge and the pinning position is horizontally centered within its overlay..."
AgEStkGraphicsScreenOverlayPinningOrigin.eStkGraphicsScreenOverlayPinningOriginBottomRight.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position in its overlay's bottom, right corner. Increasing X values move the pinning position to the left and increasing Y values move it up."
AgEStkGraphicsScreenOverlayPinningOrigin.eStkGraphicsScreenOverlayPinningOriginCenterLeft.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position at its overlay's left edge and the pinning position is vertically centered within its overlay..."
AgEStkGraphicsScreenOverlayPinningOrigin.eStkGraphicsScreenOverlayPinningOriginCenter.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position at its overlay's center. Increasing X values move the pinning position to the right and increasing Y values move it up."
AgEStkGraphicsScreenOverlayPinningOrigin.eStkGraphicsScreenOverlayPinningOriginCenterRight.__doc__ = "When the X and Y pinning pinning position are both set to 0, this value places the pinning position at its overlay's right edge and the pinning position is vertically centered within its overlay..."
AgEStkGraphicsScreenOverlayPinningOrigin.eStkGraphicsScreenOverlayPinningOriginTopLeft.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position in its overlay's top, left corner. Increasing X values move the pinning position to the right and increasing Y values move it down."
AgEStkGraphicsScreenOverlayPinningOrigin.eStkGraphicsScreenOverlayPinningOriginTopCenter.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position at its overlays's top edge and the pinning position is horizontally centered within its overlay..."
AgEStkGraphicsScreenOverlayPinningOrigin.eStkGraphicsScreenOverlayPinningOriginTopRight.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position in its overlay's top, right corner. Increasing X values move the pinning position to the left and increasing Y values move it down."
AgEStkGraphicsScreenOverlayPinningOrigin.eStkGraphicsScreenOverlayPinningOriginAutomatic.__doc__ = "The pinning origin is automatically set to the origin of the overlay. For instance, if the origin of the overlay is ScreenOverlayOrigin.BottomLeft, the pinning origin will also be equivalent to ScreenOverlayPinningOrigin.BottomLeft."

agcls.AgTypeNameMap["AgEStkGraphicsScreenOverlayPinningOrigin"] = AgEStkGraphicsScreenOverlayPinningOrigin

class AgEStkGraphicsScreenOverlayUnit(IntEnum):
    """A unit specifying how a screen overlay is sized and positioned relative to its parent."""
    # The value is specified in pixels.
    eStkGraphicsScreenOverlayUnitPixels = 0
    # The value is specified as a fraction of the overlay's parent, where 0.0 is 0% and 1.0 is 100%.
    eStkGraphicsScreenOverlayUnitFraction = 1

AgEStkGraphicsScreenOverlayUnit.eStkGraphicsScreenOverlayUnitPixels.__doc__ = "The value is specified in pixels."
AgEStkGraphicsScreenOverlayUnit.eStkGraphicsScreenOverlayUnitFraction.__doc__ = "The value is specified as a fraction of the overlay's parent, where 0.0 is 0% and 1.0 is 100%."

agcls.AgTypeNameMap["AgEStkGraphicsScreenOverlayUnit"] = AgEStkGraphicsScreenOverlayUnit

class AgEStkGraphicsSurfaceMeshRenderingMethod(IntEnum):
    """Rendering methods available for use by the surface mesh primitive. Different methods may have different performance characteristics and require different video card support. When in doubt, use Automatic."""
    # Render the surface mesh using a geometry shader. Requires `OpenGL <https://www.opengl.org/>`_ 3.0 or 2.0 with the `ARB_geometry_shader4 <https://registry.khronos.org/OpenGL/extensions/ARB/ARB_geometry_shader4.txt>`_ extension.
    eStkGraphicsSurfaceMeshRenderingMethodGeometryShader = 0
    # Render the surface mesh using a vertex shader. Requires OpenGL 2.0 or 1.5 with the following `extensions <https://www.opengl.org/registry/>`_: <ul><li><a href='https://www.opengl.org/registry/specs/ARB/vertex_shader...
    eStkGraphicsSurfaceMeshRenderingMethodVertexShader = 1
    # Render the surface mesh using an automatically selected method based on the capabilities of the video card.
    eStkGraphicsSurfaceMeshRenderingMethodAutomatic = 2

AgEStkGraphicsSurfaceMeshRenderingMethod.eStkGraphicsSurfaceMeshRenderingMethodGeometryShader.__doc__ = "Render the surface mesh using a geometry shader. Requires `OpenGL <https://www.opengl.org/>`_ 3.0 or 2.0 with the `ARB_geometry_shader4 <https://registry.khronos.org/OpenGL/extensions/ARB/ARB_geometry_shader4.txt>`_ extension."
AgEStkGraphicsSurfaceMeshRenderingMethod.eStkGraphicsSurfaceMeshRenderingMethodVertexShader.__doc__ = "Render the surface mesh using a vertex shader. Requires OpenGL 2.0 or 1.5 with the following `extensions <https://www.opengl.org/registry/>`_: <ul><li><a href='https://www.opengl.org/registry/specs/ARB/vertex_shader..."
AgEStkGraphicsSurfaceMeshRenderingMethod.eStkGraphicsSurfaceMeshRenderingMethodAutomatic.__doc__ = "Render the surface mesh using an automatically selected method based on the capabilities of the video card."

agcls.AgTypeNameMap["AgEStkGraphicsSurfaceMeshRenderingMethod"] = AgEStkGraphicsSurfaceMeshRenderingMethod

class AgEStkGraphicsVisibility(IntEnum):
    """Result of a visibility test, such as testing if a sphere intersects a frustum."""
    # The object is not visible.
    eStkGraphicsVisibilityNone = 0
    # The object is partially visible.
    eStkGraphicsVisibilityPartial = 1
    # The object is completely visible.
    eStkGraphicsVisibilityAll = 2

AgEStkGraphicsVisibility.eStkGraphicsVisibilityNone.__doc__ = "The object is not visible."
AgEStkGraphicsVisibility.eStkGraphicsVisibilityPartial.__doc__ = "The object is partially visible."
AgEStkGraphicsVisibility.eStkGraphicsVisibilityAll.__doc__ = "The object is completely visible."

agcls.AgTypeNameMap["AgEStkGraphicsVisibility"] = AgEStkGraphicsVisibility

class AgEStkGraphicsAntiAliasing(IntEnum):
    """The multisample anti-aliasing (MSAA) options for Scenes. As the level of anti-aliasing increases, performance will generally decrease, but the quality of the anti-aliasing will improve."""
    # No anti-aliasing
    eStkGraphicsAntiAliasingOff = 0
    # Fast Approximate Anti aliasing
    eStkGraphicsAntiAliasingFXAA = 1
    # Anti-aliasing at 2x
    eStkGraphicsAntiAliasingTwoX = 2
    # Anti-aliasing at 4x
    eStkGraphicsAntiAliasingFourX = 4
    # Anti-aliasing at 8x
    eStkGraphicsAntiAliasingEightX = 8
    # Anti-aliasing at 16x
    eStkGraphicsAntiAliasingSixteenX = 16
    # Anti-aliasing at 32x
    eStkGraphicsAntiAliasingThirtyTwoX = 32
    # Anti-aliasing at 64x
    eStkGraphicsAntiAliasingSixtyFourX = 64

AgEStkGraphicsAntiAliasing.eStkGraphicsAntiAliasingOff.__doc__ = "No anti-aliasing"
AgEStkGraphicsAntiAliasing.eStkGraphicsAntiAliasingFXAA.__doc__ = "Fast Approximate Anti aliasing"
AgEStkGraphicsAntiAliasing.eStkGraphicsAntiAliasingTwoX.__doc__ = "Anti-aliasing at 2x"
AgEStkGraphicsAntiAliasing.eStkGraphicsAntiAliasingFourX.__doc__ = "Anti-aliasing at 4x"
AgEStkGraphicsAntiAliasing.eStkGraphicsAntiAliasingEightX.__doc__ = "Anti-aliasing at 8x"
AgEStkGraphicsAntiAliasing.eStkGraphicsAntiAliasingSixteenX.__doc__ = "Anti-aliasing at 16x"
AgEStkGraphicsAntiAliasing.eStkGraphicsAntiAliasingThirtyTwoX.__doc__ = "Anti-aliasing at 32x"
AgEStkGraphicsAntiAliasing.eStkGraphicsAntiAliasingSixtyFourX.__doc__ = "Anti-aliasing at 64x"

agcls.AgTypeNameMap["AgEStkGraphicsAntiAliasing"] = AgEStkGraphicsAntiAliasing

class AgEStkGraphicsBinaryLogicOperation(IntEnum):
    """Binary logic operations that can be used by composite display condition."""
    # Logically and together display conditions in the composite.
    eStkGraphicsBinaryLogicOperationAnd = 0
    # Logically or together display conditions in the composite.
    eStkGraphicsBinaryLogicOperationOr = 1

AgEStkGraphicsBinaryLogicOperation.eStkGraphicsBinaryLogicOperationAnd.__doc__ = "Logically and together display conditions in the composite."
AgEStkGraphicsBinaryLogicOperation.eStkGraphicsBinaryLogicOperationOr.__doc__ = "Logically or together display conditions in the composite."

agcls.AgTypeNameMap["AgEStkGraphicsBinaryLogicOperation"] = AgEStkGraphicsBinaryLogicOperation

class AgEStkGraphicsBlurMethod(IntEnum):
    """The method used to blur or smooth a raster."""
    # Provides smoothing and noise reduction through mean filtering.
    eStkGraphicsBlurMethodMean = 0
    # Provides basic blurring.
    eStkGraphicsBlurMethodBasic = 1

AgEStkGraphicsBlurMethod.eStkGraphicsBlurMethodMean.__doc__ = "Provides smoothing and noise reduction through mean filtering."
AgEStkGraphicsBlurMethod.eStkGraphicsBlurMethodBasic.__doc__ = "Provides basic blurring."

agcls.AgTypeNameMap["AgEStkGraphicsBlurMethod"] = AgEStkGraphicsBlurMethod

class AgEStkGraphicsEdgeDetectMethod(IntEnum):
    """The method used to detect edges in a raster."""
    # Detects vertical edges.
    eStkGraphicsEdgeDetectMethodVertical = 0
    # Detects horizontal edges.
    eStkGraphicsEdgeDetectMethodHorizontal = 1
    # Detects left diagonal edges.
    eStkGraphicsEdgeDetectMethodLeftDiagonal = 2
    # Detects right diagonal edges.
    eStkGraphicsEdgeDetectMethodRightDiagonal = 3
    # Detects edges using the Laplacian method.
    eStkGraphicsEdgeDetectMethodLaplacian = 4
    # Detects edges using the Prewitt-Laplacian method.
    eStkGraphicsEdgeDetectMethodPrewittLaplacian = 5
    # Detects vertical edges using the Sobel method.
    eStkGraphicsEdgeDetectMethodSobelVertical = 6
    # Detects horizontal edges using the Sobel method.
    eStkGraphicsEdgeDetectMethodSobelHorizontal = 7

AgEStkGraphicsEdgeDetectMethod.eStkGraphicsEdgeDetectMethodVertical.__doc__ = "Detects vertical edges."
AgEStkGraphicsEdgeDetectMethod.eStkGraphicsEdgeDetectMethodHorizontal.__doc__ = "Detects horizontal edges."
AgEStkGraphicsEdgeDetectMethod.eStkGraphicsEdgeDetectMethodLeftDiagonal.__doc__ = "Detects left diagonal edges."
AgEStkGraphicsEdgeDetectMethod.eStkGraphicsEdgeDetectMethodRightDiagonal.__doc__ = "Detects right diagonal edges."
AgEStkGraphicsEdgeDetectMethod.eStkGraphicsEdgeDetectMethodLaplacian.__doc__ = "Detects edges using the Laplacian method."
AgEStkGraphicsEdgeDetectMethod.eStkGraphicsEdgeDetectMethodPrewittLaplacian.__doc__ = "Detects edges using the Prewitt-Laplacian method."
AgEStkGraphicsEdgeDetectMethod.eStkGraphicsEdgeDetectMethodSobelVertical.__doc__ = "Detects vertical edges using the Sobel method."
AgEStkGraphicsEdgeDetectMethod.eStkGraphicsEdgeDetectMethodSobelHorizontal.__doc__ = "Detects horizontal edges using the Sobel method."

agcls.AgTypeNameMap["AgEStkGraphicsEdgeDetectMethod"] = AgEStkGraphicsEdgeDetectMethod

class AgEStkGraphicsFlipAxis(IntEnum):
    """The axis on which a raster will be flipped."""
    # The horizontal axis.
    eStkGraphicsFlipAxisHorizontal = 0
    # The vertical axis.
    eStkGraphicsFlipAxisVertical = 1

AgEStkGraphicsFlipAxis.eStkGraphicsFlipAxisHorizontal.__doc__ = "The horizontal axis."
AgEStkGraphicsFlipAxis.eStkGraphicsFlipAxisVertical.__doc__ = "The vertical axis."

agcls.AgTypeNameMap["AgEStkGraphicsFlipAxis"] = AgEStkGraphicsFlipAxis

class AgEStkGraphicsGradientDetectMethod(IntEnum):
    """The method used to detect gradients in a raster. Gradient detection is commonly referred to as embossing."""
    # Detects east gradients.
    eStkGraphicsGradientDetectMethodEast = 0
    # Detects north gradients.
    eStkGraphicsGradientDetectMethodNorth = 1
    # Detects west gradients.
    eStkGraphicsGradientDetectMethodWest = 2
    # Detects south gradients.
    eStkGraphicsGradientDetectMethodSouth = 3
    # Detects north east gradients.
    eStkGraphicsGradientDetectMethodNorthEast = 4
    # Detects north west gradients.
    eStkGraphicsGradientDetectMethodNorthWest = 5
    # Detects south east gradients.
    eStkGraphicsGradientDetectMethodSouthEast = 6
    # Detects south west gradients.
    eStkGraphicsGradientDetectMethodSouthWest = 7

AgEStkGraphicsGradientDetectMethod.eStkGraphicsGradientDetectMethodEast.__doc__ = "Detects east gradients."
AgEStkGraphicsGradientDetectMethod.eStkGraphicsGradientDetectMethodNorth.__doc__ = "Detects north gradients."
AgEStkGraphicsGradientDetectMethod.eStkGraphicsGradientDetectMethodWest.__doc__ = "Detects west gradients."
AgEStkGraphicsGradientDetectMethod.eStkGraphicsGradientDetectMethodSouth.__doc__ = "Detects south gradients."
AgEStkGraphicsGradientDetectMethod.eStkGraphicsGradientDetectMethodNorthEast.__doc__ = "Detects north east gradients."
AgEStkGraphicsGradientDetectMethod.eStkGraphicsGradientDetectMethodNorthWest.__doc__ = "Detects north west gradients."
AgEStkGraphicsGradientDetectMethod.eStkGraphicsGradientDetectMethodSouthEast.__doc__ = "Detects south east gradients."
AgEStkGraphicsGradientDetectMethod.eStkGraphicsGradientDetectMethodSouthWest.__doc__ = "Detects south west gradients."

agcls.AgTypeNameMap["AgEStkGraphicsGradientDetectMethod"] = AgEStkGraphicsGradientDetectMethod

class AgEStkGraphicsJpeg2000CompressionProfile(IntEnum):
    """Defines the profile used when encoding a JPEG 2000 file."""
    # This is the default profile, which is recommended for those unfamiliar with the others.
    eStkGraphicsJpeg2000CompressionProfileDefault = 0
    # This profile is designed for U.S. and NATO military applications.
    eStkGraphicsJpeg2000CompressionProfileNITF_BIIF_NPJE = 1
    # This profile is designed for U.S. and NATO military applications. Based on NPJE, the profile is used for image exploitation, and improves image read times for lower resolutions in large images as compared to NPJE.
    eStkGraphicsJpeg2000CompressionProfileNITF_BIIF_EPJE = 2

AgEStkGraphicsJpeg2000CompressionProfile.eStkGraphicsJpeg2000CompressionProfileDefault.__doc__ = "This is the default profile, which is recommended for those unfamiliar with the others."
AgEStkGraphicsJpeg2000CompressionProfile.eStkGraphicsJpeg2000CompressionProfileNITF_BIIF_NPJE.__doc__ = "This profile is designed for U.S. and NATO military applications."
AgEStkGraphicsJpeg2000CompressionProfile.eStkGraphicsJpeg2000CompressionProfileNITF_BIIF_EPJE.__doc__ = "This profile is designed for U.S. and NATO military applications. Based on NPJE, the profile is used for image exploitation, and improves image read times for lower resolutions in large images as compared to NPJE."

agcls.AgTypeNameMap["AgEStkGraphicsJpeg2000CompressionProfile"] = AgEStkGraphicsJpeg2000CompressionProfile

class AgEStkGraphicsRasterBand(IntEnum):
    """Common band types that may be contained within a raster dataset. Each band can be thought of as a set of values, which are most commonly associated with colors when the raster represents an image..."""
    # A band containing red values.
    eStkGraphicsRasterBandRed = 0
    # A band containing green values.
    eStkGraphicsRasterBandGreen = 1
    # A band containing blue values.
    eStkGraphicsRasterBandBlue = 2
    # A band containing alpha values.
    eStkGraphicsRasterBandAlpha = 3
    # A band containing luminance values.
    eStkGraphicsRasterBandLuminance = 4

AgEStkGraphicsRasterBand.eStkGraphicsRasterBandRed.__doc__ = "A band containing red values."
AgEStkGraphicsRasterBand.eStkGraphicsRasterBandGreen.__doc__ = "A band containing green values."
AgEStkGraphicsRasterBand.eStkGraphicsRasterBandBlue.__doc__ = "A band containing blue values."
AgEStkGraphicsRasterBand.eStkGraphicsRasterBandAlpha.__doc__ = "A band containing alpha values."
AgEStkGraphicsRasterBand.eStkGraphicsRasterBandLuminance.__doc__ = "A band containing luminance values."

agcls.AgTypeNameMap["AgEStkGraphicsRasterBand"] = AgEStkGraphicsRasterBand

class AgEStkGraphicsRasterFormat(IntEnum):
    """Common raster band layouts that may be contained within a raster dataset. Each pixel of the raster will contain the bands defined by the layout in the specified order. A typical color raster image will have an rgbraster format."""
    # The format of the raster is a single band consisting of red values.
    eStkGraphicsRasterFormatRed = 0
    # The format of the raster is a single band consisting of green values.
    eStkGraphicsRasterFormatGreen = 1
    # The format of the raster is a single band consisting of blue values.
    eStkGraphicsRasterFormatBlue = 2
    # The format of the raster is a single band consisting of alpha values.
    eStkGraphicsRasterFormatAlpha = 3
    # The format of the raster is three bands consisting of red, green, and blue values.
    eStkGraphicsRasterFormatRgb = 4
    # The format of the raster is three bands consisting of blue, green, and red values.
    eStkGraphicsRasterFormatBgr = 5
    # The format of the raster is four bands consisting of red, green, blue, and alpha values.
    eStkGraphicsRasterFormatRgba = 6
    # The format of the raster is four bands consisting of blue, green, red, and alpha values.
    eStkGraphicsRasterFormatBgra = 7
    # The format of the raster is a single band consisting of luminance values.
    eStkGraphicsRasterFormatLuminance = 8
    # The format of the raster is two bands consisting of luminance and alpha values.
    eStkGraphicsRasterFormatLuminanceAlpha = 9

AgEStkGraphicsRasterFormat.eStkGraphicsRasterFormatRed.__doc__ = "The format of the raster is a single band consisting of red values."
AgEStkGraphicsRasterFormat.eStkGraphicsRasterFormatGreen.__doc__ = "The format of the raster is a single band consisting of green values."
AgEStkGraphicsRasterFormat.eStkGraphicsRasterFormatBlue.__doc__ = "The format of the raster is a single band consisting of blue values."
AgEStkGraphicsRasterFormat.eStkGraphicsRasterFormatAlpha.__doc__ = "The format of the raster is a single band consisting of alpha values."
AgEStkGraphicsRasterFormat.eStkGraphicsRasterFormatRgb.__doc__ = "The format of the raster is three bands consisting of red, green, and blue values."
AgEStkGraphicsRasterFormat.eStkGraphicsRasterFormatBgr.__doc__ = "The format of the raster is three bands consisting of blue, green, and red values."
AgEStkGraphicsRasterFormat.eStkGraphicsRasterFormatRgba.__doc__ = "The format of the raster is four bands consisting of red, green, blue, and alpha values."
AgEStkGraphicsRasterFormat.eStkGraphicsRasterFormatBgra.__doc__ = "The format of the raster is four bands consisting of blue, green, red, and alpha values."
AgEStkGraphicsRasterFormat.eStkGraphicsRasterFormatLuminance.__doc__ = "The format of the raster is a single band consisting of luminance values."
AgEStkGraphicsRasterFormat.eStkGraphicsRasterFormatLuminanceAlpha.__doc__ = "The format of the raster is two bands consisting of luminance and alpha values."

agcls.AgTypeNameMap["AgEStkGraphicsRasterFormat"] = AgEStkGraphicsRasterFormat

class AgEStkGraphicsRasterOrientation(IntEnum):
    """The vertical orientation of the raster."""
    # The raster has a top to bottom orientation.
    eStkGraphicsRasterOrientationTopToBottom = 0
    # The raster has a bottom to top orientation.
    eStkGraphicsRasterOrientationBottomToTop = 1

AgEStkGraphicsRasterOrientation.eStkGraphicsRasterOrientationTopToBottom.__doc__ = "The raster has a top to bottom orientation."
AgEStkGraphicsRasterOrientation.eStkGraphicsRasterOrientationBottomToTop.__doc__ = "The raster has a bottom to top orientation."

agcls.AgTypeNameMap["AgEStkGraphicsRasterOrientation"] = AgEStkGraphicsRasterOrientation

class AgEStkGraphicsRasterType(IntEnum):
    """The type of data contained within each band of a raster dataset."""
    # Each value contained within a band can be represented with an unsigned byte.
    eStkGraphicsRasterTypeUnsignedByte = 0
    # Each value contained within a band can be represented with a byte.
    eStkGraphicsRasterTypeByte = 1
    # Each value contained within a band can be represented with an unsigned short.
    eStkGraphicsRasterTypeUnsignedShort = 2
    # Each value contained within a band can be represented with a short.
    eStkGraphicsRasterTypeShort = 3
    # Each value contained within a band can be represented with an unsigned int.
    eStkGraphicsRasterTypeUnsignedInt = 4
    # Each value contained within a band can be represented with an int.
    eStkGraphicsRasterTypeInt = 5
    # Each value contained within a band can be represented with a float.
    eStkGraphicsRasterTypeFloat = 6
    # Each value contained within a band can be represented with a double.
    eStkGraphicsRasterTypeDouble = 7

AgEStkGraphicsRasterType.eStkGraphicsRasterTypeUnsignedByte.__doc__ = "Each value contained within a band can be represented with an unsigned byte."
AgEStkGraphicsRasterType.eStkGraphicsRasterTypeByte.__doc__ = "Each value contained within a band can be represented with a byte."
AgEStkGraphicsRasterType.eStkGraphicsRasterTypeUnsignedShort.__doc__ = "Each value contained within a band can be represented with an unsigned short."
AgEStkGraphicsRasterType.eStkGraphicsRasterTypeShort.__doc__ = "Each value contained within a band can be represented with a short."
AgEStkGraphicsRasterType.eStkGraphicsRasterTypeUnsignedInt.__doc__ = "Each value contained within a band can be represented with an unsigned int."
AgEStkGraphicsRasterType.eStkGraphicsRasterTypeInt.__doc__ = "Each value contained within a band can be represented with an int."
AgEStkGraphicsRasterType.eStkGraphicsRasterTypeFloat.__doc__ = "Each value contained within a band can be represented with a float."
AgEStkGraphicsRasterType.eStkGraphicsRasterTypeDouble.__doc__ = "Each value contained within a band can be represented with a double."

agcls.AgTypeNameMap["AgEStkGraphicsRasterType"] = AgEStkGraphicsRasterType

class AgEStkGraphicsSharpenMethod(IntEnum):
    """The method used to sharpen a raster."""
    # Provides sharpening through mean removal.
    eStkGraphicsSharpenMethodMeanRemoval = 0
    # Provides basic sharpening.
    eStkGraphicsSharpenMethodBasic = 1

AgEStkGraphicsSharpenMethod.eStkGraphicsSharpenMethodMeanRemoval.__doc__ = "Provides sharpening through mean removal."
AgEStkGraphicsSharpenMethod.eStkGraphicsSharpenMethodBasic.__doc__ = "Provides basic sharpening."

agcls.AgTypeNameMap["AgEStkGraphicsSharpenMethod"] = AgEStkGraphicsSharpenMethod

class AgEStkGraphicsVideoPlayback(IntEnum):
    """Specifies how the video stream will playback. When the playback is set to real time, the video will playback in real time..."""
    # The video will playback in realtime.
    eStkGraphicsVideoPlaybackRealTime = 0
    # The video will playback in coincidence with the scene manager time within the interval defined by interval start time and interval end time.
    eStkGraphicsVideoPlaybackTimeInterval = 1

AgEStkGraphicsVideoPlayback.eStkGraphicsVideoPlaybackRealTime.__doc__ = "The video will playback in realtime."
AgEStkGraphicsVideoPlayback.eStkGraphicsVideoPlaybackTimeInterval.__doc__ = "The video will playback in coincidence with the scene manager time within the interval defined by interval start time and interval end time."

agcls.AgTypeNameMap["AgEStkGraphicsVideoPlayback"] = AgEStkGraphicsVideoPlayback

class AgEStkGraphicsKmlNetworkLinkRefreshMode(IntEnum):
    """Defines the options available for a KmlNetworkLink's RefreshMode property."""
    # Refresh when the document is loaded and whenever the Link parameters change (the default).
    eStkGraphicsKmlNetworkLinkRefreshModeOnChange = 0
    # Refresh the network link at the duration specified by refresh interval.
    eStkGraphicsKmlNetworkLinkRefreshModeOnInterval = 1
    # Refresh the network link when the expiration time is reached.
    eStkGraphicsKmlNetworkLinkRefreshModeOnExpire = 2

AgEStkGraphicsKmlNetworkLinkRefreshMode.eStkGraphicsKmlNetworkLinkRefreshModeOnChange.__doc__ = "Refresh when the document is loaded and whenever the Link parameters change (the default)."
AgEStkGraphicsKmlNetworkLinkRefreshMode.eStkGraphicsKmlNetworkLinkRefreshModeOnInterval.__doc__ = "Refresh the network link at the duration specified by refresh interval."
AgEStkGraphicsKmlNetworkLinkRefreshMode.eStkGraphicsKmlNetworkLinkRefreshModeOnExpire.__doc__ = "Refresh the network link when the expiration time is reached."

agcls.AgTypeNameMap["AgEStkGraphicsKmlNetworkLinkRefreshMode"] = AgEStkGraphicsKmlNetworkLinkRefreshMode

class AgEStkGraphicsKmlNetworkLinkViewRefreshMode(IntEnum):
    """Defines the options available for a KmlNetworkLink's ViewRefreshMode property."""
    # Do not refresh the network link when the camera's view changes.
    eStkGraphicsKmlNetworkLinkViewRefreshModeNever = 0
    # Only refresh the network link when it is explicitly refreshed by calling the refresh method.
    eStkGraphicsKmlNetworkLinkViewRefreshModeOnRequest = 1
    # Refresh the network link after camera view movement stops for the duration specified by view refresh time.
    eStkGraphicsKmlNetworkLinkViewRefreshModeOnStop = 2
    # Refreshes the network link when the region associated with this link becomes active.
    eStkGraphicsKmlNetworkLinkViewRefreshModeOnRegion = 3

AgEStkGraphicsKmlNetworkLinkViewRefreshMode.eStkGraphicsKmlNetworkLinkViewRefreshModeNever.__doc__ = "Do not refresh the network link when the camera's view changes."
AgEStkGraphicsKmlNetworkLinkViewRefreshMode.eStkGraphicsKmlNetworkLinkViewRefreshModeOnRequest.__doc__ = "Only refresh the network link when it is explicitly refreshed by calling the refresh method."
AgEStkGraphicsKmlNetworkLinkViewRefreshMode.eStkGraphicsKmlNetworkLinkViewRefreshModeOnStop.__doc__ = "Refresh the network link after camera view movement stops for the duration specified by view refresh time."
AgEStkGraphicsKmlNetworkLinkViewRefreshMode.eStkGraphicsKmlNetworkLinkViewRefreshModeOnRegion.__doc__ = "Refreshes the network link when the region associated with this link becomes active."

agcls.AgTypeNameMap["AgEStkGraphicsKmlNetworkLinkViewRefreshMode"] = AgEStkGraphicsKmlNetworkLinkViewRefreshMode

class AgEStkGraphicsModelUpAxis(IntEnum):
    """When setting the camera'saxes, this defines which axis of the axes is up in screen space, where up is from the bottom to the top of the screen."""
    # The positive X axis.
    eStkGraphicsModelUpAxisX = 0
    # The positive Y axis.
    eStkGraphicsModelUpAxisY = 1
    # The positive Z axis.
    eStkGraphicsModelUpAxisZ = 2
    # The negative X axis.
    eStkGraphicsModelUpAxisNegativeX = 3
    # The negative Y axis.
    eStkGraphicsModelUpAxisNegativeY = 4
    # The negative Z axis.
    eStkGraphicsModelUpAxisNegativeZ = 5

AgEStkGraphicsModelUpAxis.eStkGraphicsModelUpAxisX.__doc__ = "The positive X axis."
AgEStkGraphicsModelUpAxis.eStkGraphicsModelUpAxisY.__doc__ = "The positive Y axis."
AgEStkGraphicsModelUpAxis.eStkGraphicsModelUpAxisZ.__doc__ = "The positive Z axis."
AgEStkGraphicsModelUpAxis.eStkGraphicsModelUpAxisNegativeX.__doc__ = "The negative X axis."
AgEStkGraphicsModelUpAxis.eStkGraphicsModelUpAxisNegativeY.__doc__ = "The negative Y axis."
AgEStkGraphicsModelUpAxis.eStkGraphicsModelUpAxisNegativeZ.__doc__ = "The negative Z axis."

agcls.AgTypeNameMap["AgEStkGraphicsModelUpAxis"] = AgEStkGraphicsModelUpAxis

class AgEStkGraphicsOutlineAppearance(IntEnum):
    """Possible appearances of an outline. Front lines are lines on front facing geometry and back lines are lines on back facing geometry."""
    # Both the front and back lines are displayed.
    eStkGraphicsFrontAndBackLines = 0
    # Only the front lines are displayed. This can be used to declutter the outline.
    eStkGraphicsFrontLinesOnly = 1
    # Both the front and back lines are displayed. The back lines are displayed using a different color, translucency, and width. This is used to declutter the outline but still provide a visual cue for the back facing geometry.
    eStkGraphicsStylizeBackLines = 2

AgEStkGraphicsOutlineAppearance.eStkGraphicsFrontAndBackLines.__doc__ = "Both the front and back lines are displayed."
AgEStkGraphicsOutlineAppearance.eStkGraphicsFrontLinesOnly.__doc__ = "Only the front lines are displayed. This can be used to declutter the outline."
AgEStkGraphicsOutlineAppearance.eStkGraphicsStylizeBackLines.__doc__ = "Both the front and back lines are displayed. The back lines are displayed using a different color, translucency, and width. This is used to declutter the outline but still provide a visual cue for the back facing geometry."

agcls.AgTypeNameMap["AgEStkGraphicsOutlineAppearance"] = AgEStkGraphicsOutlineAppearance

class AgEStkGraphicsPolylineType(IntEnum):
    """Describes how to interpret positions defining a polyline."""
    # Every two positions define a line segment. Line segments are not required to be connected to each other.
    eStkGraphicsPolylineTypeLines = 0
    # After the first position, each additional position defines a line segment from the previous position to the current position.
    eStkGraphicsPolylineTypeLineStrip = 1
    # Lines are drawn as points.
    eStkGraphicsPolylineTypePoints = 2

AgEStkGraphicsPolylineType.eStkGraphicsPolylineTypeLines.__doc__ = "Every two positions define a line segment. Line segments are not required to be connected to each other."
AgEStkGraphicsPolylineType.eStkGraphicsPolylineTypeLineStrip.__doc__ = "After the first position, each additional position defines a line segment from the previous position to the current position."
AgEStkGraphicsPolylineType.eStkGraphicsPolylineTypePoints.__doc__ = "Lines are drawn as points."

agcls.AgTypeNameMap["AgEStkGraphicsPolylineType"] = AgEStkGraphicsPolylineType

class AgEStkGraphicsCullFace(IntEnum):
    """Identifies whether front- and/or back-facing triangles are culled."""
    # Front-facing triangles are culled.
    eStkGraphicsECullFaceFront = 0
    # Back-facing triangles are culled.
    eStkGraphicsECullFaceBack = 1
    # Both front- and back-facing triangles are culled. Therefore, no triangles are rendered.
    eStkGraphicsECullFaceFrontAndBack = 2
    # No triangles are culled.
    eStkGraphicsECullFaceNeither = 3

AgEStkGraphicsCullFace.eStkGraphicsECullFaceFront.__doc__ = "Front-facing triangles are culled."
AgEStkGraphicsCullFace.eStkGraphicsECullFaceBack.__doc__ = "Back-facing triangles are culled."
AgEStkGraphicsCullFace.eStkGraphicsECullFaceFrontAndBack.__doc__ = "Both front- and back-facing triangles are culled. Therefore, no triangles are rendered."
AgEStkGraphicsCullFace.eStkGraphicsECullFaceNeither.__doc__ = "No triangles are culled."

agcls.AgTypeNameMap["AgEStkGraphicsCullFace"] = AgEStkGraphicsCullFace

class AgEStkGraphicsInternalTextureFormat(IntEnum):
    """The format of individual texels in a texture."""
    # Each texel is an 4-bit alpha component.
    eStkGraphicsInternalTextureFormatAlpha4 = 0
    # Each texel is an 8-bit alpha component.
    eStkGraphicsInternalTextureFormatAlpha8 = 1
    # Each texel is an 12-bit alpha component.
    eStkGraphicsInternalTextureFormatAlpha12 = 2
    # Each texel is an 16-bit alpha component.
    eStkGraphicsInternalTextureFormatAlpha16 = 3
    # Each texel contains 3-bit red and green components and 2-bit blue component.
    eStkGraphicsInternalTextureFormatR3G3B2 = 4
    # Each texel contains 4-bit red, green, and blue components.
    eStkGraphicsInternalTextureFormatRgb4 = 5
    # Each texel contains 5-bit red, green, and blue components.
    eStkGraphicsInternalTextureFormatRgb5 = 6
    # Each texel contains 8-bit red, green, and blue components.
    eStkGraphicsInternalTextureFormatRgb8 = 7
    # Each texel contains 10-bit red, green, and blue components.
    eStkGraphicsInternalTextureFormatRgb10 = 8
    # Each texel contains 12-bit red, green, and blue components.
    eStkGraphicsInternalTextureFormatRgb12 = 9
    # Each texel contains 16-bit red, green, and blue components.
    eStkGraphicsInternalTextureFormatRgb16 = 10
    # Each texel contains 16-bit red, green, and blue floating point components.
    eStkGraphicsInternalTextureFormatRgb16F = 11
    # Each texel contains 32-bit red, green, and blue floating point components.
    eStkGraphicsInternalTextureFormatRgb32F = 12
    # Each texel contains 2-bit red, green, blue, and alpha components.
    eStkGraphicsInternalTextureFormatRgba2 = 13
    # Each texel contains 4-bit red, green, blue, and alpha components.
    eStkGraphicsInternalTextureFormatRgba4 = 14
    # Each texel contains 5-bit red, green, blue components and 1-bit alpha component.
    eStkGraphicsInternalTextureFormatRgb5A1 = 15
    # Each texel contains 8-bit red, green, blue, and alpha components.
    eStkGraphicsInternalTextureFormatRgba8 = 16
    # Each texel contains 10-bit red, green, blue components and 2-bit alpha component.
    eStkGraphicsInternalTextureFormatRgb10A2 = 17
    # Each texel contains 12-bit red, green, blue, and alpha components.
    eStkGraphicsInternalTextureFormatRgba12 = 18
    # Each texel contains 16-bit red, green, blue, and alpha components.
    eStkGraphicsInternalTextureFormatRgba16 = 19
    # Each texel contains 16-bit red, green, blue, and alpha floating point components.
    eStkGraphicsInternalTextureFormatRgba16F = 20
    # Each texel contains 32-bit red, green, blue, and alpha floating point components.
    eStkGraphicsInternalTextureFormatRgba32F = 21
    # Each texel is an 4-bit luminance, e.g. intensity, component.
    eStkGraphicsInternalTextureFormatLuminance4 = 22
    # Each texel is an 8-bit luminance, e.g. intensity, component.
    eStkGraphicsInternalTextureFormatLuminance8 = 23
    # Each texel is an 12-bit luminance, e.g. intensity, component.
    eStkGraphicsInternalTextureFormatLuminance12 = 24
    # Each texel is an 16-bit luminance, e.g. intensity, component.
    eStkGraphicsInternalTextureFormatLuminance16 = 25
    # Each texel is an 16-bit luminance, e.g. intensity, floating point component.
    eStkGraphicsInternalTextureFormatLuminance16F = 26
    # Each texel is an 32-bit luminance, e.g. intensity, floating point component.
    eStkGraphicsInternalTextureFormatLuminance32F = 27
    # Each texel contains an 4-bit luminance and 4-bit alpha component.
    eStkGraphicsInternalTextureFormatLuminance4Alpha4 = 28
    # Each texel contains an 6-bit luminance and 2-bit alpha component.
    eStkGraphicsInternalTextureFormatLuminance6Alpha2 = 29
    # Each texel contains an 8-bit luminance and 8-bit alpha component.
    eStkGraphicsInternalTextureFormatLuminance8Alpha8 = 30
    # Each texel contains an 12-bit luminance and 4-bit alpha component.
    eStkGraphicsInternalTextureFormatLuminance12Alpha4 = 31
    # Each texel contains an 12-bit luminance and 12-bit alpha component.
    eStkGraphicsInternalTextureFormatLuminance12Alpha12 = 32
    # Each texel contains an 16-bit luminance and 16-bit alpha component.
    eStkGraphicsInternalTextureFormatLuminance16Alpha16 = 33
    # Each texel contains an 16-bit luminance and 16-bit alpha floating point component.
    eStkGraphicsInternalTextureFormatLuminance16Alpha16F = 34
    # Each texel contains an 32-bit luminance and 32-bit alpha floating point component.
    eStkGraphicsInternalTextureFormatLuminance32Alpha32F = 35

AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatAlpha4.__doc__ = "Each texel is an 4-bit alpha component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatAlpha8.__doc__ = "Each texel is an 8-bit alpha component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatAlpha12.__doc__ = "Each texel is an 12-bit alpha component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatAlpha16.__doc__ = "Each texel is an 16-bit alpha component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatR3G3B2.__doc__ = "Each texel contains 3-bit red and green components and 2-bit blue component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgb4.__doc__ = "Each texel contains 4-bit red, green, and blue components."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgb5.__doc__ = "Each texel contains 5-bit red, green, and blue components."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgb8.__doc__ = "Each texel contains 8-bit red, green, and blue components."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgb10.__doc__ = "Each texel contains 10-bit red, green, and blue components."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgb12.__doc__ = "Each texel contains 12-bit red, green, and blue components."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgb16.__doc__ = "Each texel contains 16-bit red, green, and blue components."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgb16F.__doc__ = "Each texel contains 16-bit red, green, and blue floating point components."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgb32F.__doc__ = "Each texel contains 32-bit red, green, and blue floating point components."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgba2.__doc__ = "Each texel contains 2-bit red, green, blue, and alpha components."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgba4.__doc__ = "Each texel contains 4-bit red, green, blue, and alpha components."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgb5A1.__doc__ = "Each texel contains 5-bit red, green, blue components and 1-bit alpha component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgba8.__doc__ = "Each texel contains 8-bit red, green, blue, and alpha components."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgb10A2.__doc__ = "Each texel contains 10-bit red, green, blue components and 2-bit alpha component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgba12.__doc__ = "Each texel contains 12-bit red, green, blue, and alpha components."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgba16.__doc__ = "Each texel contains 16-bit red, green, blue, and alpha components."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgba16F.__doc__ = "Each texel contains 16-bit red, green, blue, and alpha floating point components."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatRgba32F.__doc__ = "Each texel contains 32-bit red, green, blue, and alpha floating point components."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatLuminance4.__doc__ = "Each texel is an 4-bit luminance, e.g. intensity, component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatLuminance8.__doc__ = "Each texel is an 8-bit luminance, e.g. intensity, component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatLuminance12.__doc__ = "Each texel is an 12-bit luminance, e.g. intensity, component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatLuminance16.__doc__ = "Each texel is an 16-bit luminance, e.g. intensity, component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatLuminance16F.__doc__ = "Each texel is an 16-bit luminance, e.g. intensity, floating point component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatLuminance32F.__doc__ = "Each texel is an 32-bit luminance, e.g. intensity, floating point component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatLuminance4Alpha4.__doc__ = "Each texel contains an 4-bit luminance and 4-bit alpha component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatLuminance6Alpha2.__doc__ = "Each texel contains an 6-bit luminance and 2-bit alpha component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatLuminance8Alpha8.__doc__ = "Each texel contains an 8-bit luminance and 8-bit alpha component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatLuminance12Alpha4.__doc__ = "Each texel contains an 12-bit luminance and 4-bit alpha component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatLuminance12Alpha12.__doc__ = "Each texel contains an 12-bit luminance and 12-bit alpha component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatLuminance16Alpha16.__doc__ = "Each texel contains an 16-bit luminance and 16-bit alpha component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatLuminance16Alpha16F.__doc__ = "Each texel contains an 16-bit luminance and 16-bit alpha floating point component."
AgEStkGraphicsInternalTextureFormat.eStkGraphicsInternalTextureFormatLuminance32Alpha32F.__doc__ = "Each texel contains an 32-bit luminance and 32-bit alpha floating point component."

agcls.AgTypeNameMap["AgEStkGraphicsInternalTextureFormat"] = AgEStkGraphicsInternalTextureFormat

class AgEStkGraphicsMagnificationFilter(IntEnum):
    """The filter used when the pixel being textured maps to an area less than or equal to one texel."""
    # Use the texel that is closest to the center of the pixel being textured. This usually faster than Linear but can produce images with sharper edges.
    eStkGraphicsMagnificationFilterNearest = 0
    # Use the weighted average of the four texels that are closest to the center of the pixel being textured.
    eStkGraphicsMagnificationFilterLinear = 1

AgEStkGraphicsMagnificationFilter.eStkGraphicsMagnificationFilterNearest.__doc__ = "Use the texel that is closest to the center of the pixel being textured. This usually faster than Linear but can produce images with sharper edges."
AgEStkGraphicsMagnificationFilter.eStkGraphicsMagnificationFilterLinear.__doc__ = "Use the weighted average of the four texels that are closest to the center of the pixel being textured."

agcls.AgTypeNameMap["AgEStkGraphicsMagnificationFilter"] = AgEStkGraphicsMagnificationFilter

class AgEStkGraphicsMinificationFilter(IntEnum):
    """The filter used when the pixel being textured maps to an area greater than one texel."""
    # Use the texel that is closest to the center of the pixel being textured.
    eStkGraphicsMinificationFilterNearest = 0
    # Use the weighted average of the four (for 2D textures, two for 1D textures) texels that are closest to the center of the pixel being textured.
    eStkGraphicsMinificationFilterLinear = 1
    # Use the mipmap that most closely matches the size of the pixel being textured. Then use the texel from that mipmap that is closest to the center of the pixel being textured.
    eStkGraphicsMinificationFilterNearestMipMapNearest = 2
    # Use the mipmap that most closely matches the size of the pixel being textured. Then use the weighted average of the four (for 2D textures, two for 1D textures) texels from that mipmap that are closest to the center of the pixel being textured.
    eStkGraphicsMinificationFilterLinearMipMapNearest = 3
    # Use the two mipmaps that most closely match the size of the pixel being textured. Determine the texel that is closest to the center of the pixel being textured in each mipmap. The final texture value is a weighted average of these two texels.
    eStkGraphicsMinificationFilterNearestMipMapLinear = 4
    # Use the two mipmaps that most closely match the size of the pixel being textured. Determine the weighted average of the four (for 2D textures, two for 1D textures) texels that are closest to the center of the pixel being textured in each mipmap...
    eStkGraphicsMinificationFilterLinearMipMapLinear = 5

AgEStkGraphicsMinificationFilter.eStkGraphicsMinificationFilterNearest.__doc__ = "Use the texel that is closest to the center of the pixel being textured."
AgEStkGraphicsMinificationFilter.eStkGraphicsMinificationFilterLinear.__doc__ = "Use the weighted average of the four (for 2D textures, two for 1D textures) texels that are closest to the center of the pixel being textured."
AgEStkGraphicsMinificationFilter.eStkGraphicsMinificationFilterNearestMipMapNearest.__doc__ = "Use the mipmap that most closely matches the size of the pixel being textured. Then use the texel from that mipmap that is closest to the center of the pixel being textured."
AgEStkGraphicsMinificationFilter.eStkGraphicsMinificationFilterLinearMipMapNearest.__doc__ = "Use the mipmap that most closely matches the size of the pixel being textured. Then use the weighted average of the four (for 2D textures, two for 1D textures) texels from that mipmap that are closest to the center of the pixel being textured."
AgEStkGraphicsMinificationFilter.eStkGraphicsMinificationFilterNearestMipMapLinear.__doc__ = "Use the two mipmaps that most closely match the size of the pixel being textured. Determine the texel that is closest to the center of the pixel being textured in each mipmap. The final texture value is a weighted average of these two texels."
AgEStkGraphicsMinificationFilter.eStkGraphicsMinificationFilterLinearMipMapLinear.__doc__ = "Use the two mipmaps that most closely match the size of the pixel being textured. Determine the weighted average of the four (for 2D textures, two for 1D textures) texels that are closest to the center of the pixel being textured in each mipmap..."

agcls.AgTypeNameMap["AgEStkGraphicsMinificationFilter"] = AgEStkGraphicsMinificationFilter

class AgEStkGraphicsRendererShadeModel(IntEnum):
    """Identifies which shade model to use. The primitive can be drawn with a single color or multiple colors."""
    # Flat shading renders the primitive with one color across all of the vertices.
    eStkGraphicsRendererShadeModelFlat = 0
    # Gouraud shading renders the primitive by interpolating the color between the vertices.
    eStkGraphicsRendererShadeModelGouraud = 1

AgEStkGraphicsRendererShadeModel.eStkGraphicsRendererShadeModelFlat.__doc__ = "Flat shading renders the primitive with one color across all of the vertices."
AgEStkGraphicsRendererShadeModel.eStkGraphicsRendererShadeModelGouraud.__doc__ = "Gouraud shading renders the primitive by interpolating the color between the vertices."

agcls.AgTypeNameMap["AgEStkGraphicsRendererShadeModel"] = AgEStkGraphicsRendererShadeModel

class AgEStkGraphicsTextureWrap(IntEnum):
    """Determine how to handle textures coordinates that fall outside of the range [0, 1]."""
    # Clamp the texture coordinate to the range [0, 1].
    eStkGraphicsTextureWrapClamp = 0
    # Clamp the texture coordinate to the range [-1/2N, 1 + 1/2N], where N is the size the texture in the direction of clamping.
    eStkGraphicsTextureWrapClampToBorder = 1
    # Clamp the texture coordinate to the range [1/2N, 1 - 1/2N], where N is the size the texture in the direction of clamping.
    eStkGraphicsTextureWrapClampToEdge = 2
    # If the integer part of the texture coordinate is even, use the fractional part of the texture coordinate. Otherwise, use one minus the fractional part of the texture coordinate.
    eStkGraphicsTextureWrapMirroredRepeat = 3
    # Ignore the integer part of the texture coordinate.
    eStkGraphicsTextureWrapRepeat = 4

AgEStkGraphicsTextureWrap.eStkGraphicsTextureWrapClamp.__doc__ = "Clamp the texture coordinate to the range [0, 1]."
AgEStkGraphicsTextureWrap.eStkGraphicsTextureWrapClampToBorder.__doc__ = "Clamp the texture coordinate to the range [-1/2N, 1 + 1/2N], where N is the size the texture in the direction of clamping."
AgEStkGraphicsTextureWrap.eStkGraphicsTextureWrapClampToEdge.__doc__ = "Clamp the texture coordinate to the range [1/2N, 1 - 1/2N], where N is the size the texture in the direction of clamping."
AgEStkGraphicsTextureWrap.eStkGraphicsTextureWrapMirroredRepeat.__doc__ = "If the integer part of the texture coordinate is even, use the fractional part of the texture coordinate. Otherwise, use one minus the fractional part of the texture coordinate."
AgEStkGraphicsTextureWrap.eStkGraphicsTextureWrapRepeat.__doc__ = "Ignore the integer part of the texture coordinate."

agcls.AgTypeNameMap["AgEStkGraphicsTextureWrap"] = AgEStkGraphicsTextureWrap

class AgEStkGraphicsSetHint(IntEnum):
    """An optimization hint optionally provided to primitives to enhance performance for static or dynamic primitives. See the Set Hint Performance Overview for selecting an appropriate value."""
    # Rendering is optimized for static geometry. The primitive's vertices are not going to be updated with Set() or SetPartial() calls. Calls to SetPartial() will fail. Calls to Set() are allowed but may not be as efficient as SetHintFrequent.
    eStkGraphicsSetHintInfrequent = 0
    # Rendering is optimized for dynamic geometry. The primitive's vertices are expected to be updated with SetPartial() - some or all of the vertices will change but the number of vertices will not.
    eStkGraphicsSetHintPartial = 1
    # Rendering is optimized for streaming geometry. The primitive's vertices are expected to be updated with Set() - all the vertices will change and/or the number of vertices will change. Calls to SetPartial() will fail.
    eStkGraphicsSetHintFrequent = 2

AgEStkGraphicsSetHint.eStkGraphicsSetHintInfrequent.__doc__ = "Rendering is optimized for static geometry. The primitive's vertices are not going to be updated with Set() or SetPartial() calls. Calls to SetPartial() will fail. Calls to Set() are allowed but may not be as efficient as SetHintFrequent."
AgEStkGraphicsSetHint.eStkGraphicsSetHintPartial.__doc__ = "Rendering is optimized for dynamic geometry. The primitive's vertices are expected to be updated with SetPartial() - some or all of the vertices will change but the number of vertices will not."
AgEStkGraphicsSetHint.eStkGraphicsSetHintFrequent.__doc__ = "Rendering is optimized for streaming geometry. The primitive's vertices are expected to be updated with Set() - all the vertices will change and/or the number of vertices will change. Calls to SetPartial() will fail."

agcls.AgTypeNameMap["AgEStkGraphicsSetHint"] = AgEStkGraphicsSetHint

class AgEStkGraphicsStereoProjectionMode(IntEnum):
    """The stereoscopic projection mode used for the left and right eye scenes."""
    # Parallel projection. Parallel projection will ignore any projection distance that has been set and instead use a parallel projection for each eye. In parallel mode all objects will appear to go into the screen...
    eStkGraphicsStereoProjectionParallel = 0
    # Fixed distance projection. Objects at the fixed distance will appear to have no depth. Objects further than the distance will appear to go into the screen. Objects nearer than the distance will appear to pop out of the screen.
    eStkGraphicsStereoProjectionFixedDistance = 1
    # Automatic distance projection. Automatic distance projection will ignore any projection distance that has been set and instead automatically calculates the projection distance based on the distance between the camera and the center of the scene.
    eStkGraphicsStereoProjectionAutomatic = 2

AgEStkGraphicsStereoProjectionMode.eStkGraphicsStereoProjectionParallel.__doc__ = "Parallel projection. Parallel projection will ignore any projection distance that has been set and instead use a parallel projection for each eye. In parallel mode all objects will appear to go into the screen..."
AgEStkGraphicsStereoProjectionMode.eStkGraphicsStereoProjectionFixedDistance.__doc__ = "Fixed distance projection. Objects at the fixed distance will appear to have no depth. Objects further than the distance will appear to go into the screen. Objects nearer than the distance will appear to pop out of the screen."
AgEStkGraphicsStereoProjectionMode.eStkGraphicsStereoProjectionAutomatic.__doc__ = "Automatic distance projection. Automatic distance projection will ignore any projection distance that has been set and instead automatically calculates the projection distance based on the distance between the camera and the center of the scene."

agcls.AgTypeNameMap["AgEStkGraphicsStereoProjectionMode"] = AgEStkGraphicsStereoProjectionMode

class AgEStkGraphicsStereoscopicDisplayMode(IntEnum):
    """The stereoscopic display mode. To use a particular stereoscopic display mode, ensure that your system supports the feature and that it is enabled."""
    # No stereoscopic
    eStkGraphicsStereoscopicDisplayModeOff = 0
    # OpenGL Quad-buffer stereoscopic
    eStkGraphicsStereoscopicDisplayModeQuadBuffer = 1
    # Anaglyph or two-color stereoscopic
    eStkGraphicsStereoscopicDisplayModeAnaglyph = 2
    # Left eye view of the stereoscopic scene
    eStkGraphicsStereoscopicDisplayModeLeftEye = 3
    # Right eye view of the stereoscopic scene
    eStkGraphicsStereoscopicDisplayModeRightEye = 4
    # Side-by-side stereoscopic. Left and right eye views are rendered next to each other in the same window.
    eStkGraphicsStereoscopicDisplayModeSideBySide = 5

AgEStkGraphicsStereoscopicDisplayMode.eStkGraphicsStereoscopicDisplayModeOff.__doc__ = "No stereoscopic"
AgEStkGraphicsStereoscopicDisplayMode.eStkGraphicsStereoscopicDisplayModeQuadBuffer.__doc__ = "OpenGL Quad-buffer stereoscopic"
AgEStkGraphicsStereoscopicDisplayMode.eStkGraphicsStereoscopicDisplayModeAnaglyph.__doc__ = "Anaglyph or two-color stereoscopic"
AgEStkGraphicsStereoscopicDisplayMode.eStkGraphicsStereoscopicDisplayModeLeftEye.__doc__ = "Left eye view of the stereoscopic scene"
AgEStkGraphicsStereoscopicDisplayMode.eStkGraphicsStereoscopicDisplayModeRightEye.__doc__ = "Right eye view of the stereoscopic scene"
AgEStkGraphicsStereoscopicDisplayMode.eStkGraphicsStereoscopicDisplayModeSideBySide.__doc__ = "Side-by-side stereoscopic. Left and right eye views are rendered next to each other in the same window."

agcls.AgTypeNameMap["AgEStkGraphicsStereoscopicDisplayMode"] = AgEStkGraphicsStereoscopicDisplayMode

class AgEStkGraphicsFontStyle(IntEnum):
    """Font styles."""
    # Regular font.
    eStkGraphicsFontStyleRegular = 0x0
    # Bold font.
    eStkGraphicsFontStyleBold = 0x1
    # Italic font.
    eStkGraphicsFontStyleItalic = 0x2
    # Underlined font.
    eStkGraphicsFontStyleUnderline = 0x4
    # Strike-out style.
    eStkGraphicsFontStyleStrikeout = 0x8

AgEStkGraphicsFontStyle.eStkGraphicsFontStyleRegular.__doc__ = "Regular font."
AgEStkGraphicsFontStyle.eStkGraphicsFontStyleBold.__doc__ = "Bold font."
AgEStkGraphicsFontStyle.eStkGraphicsFontStyleItalic.__doc__ = "Italic font."
AgEStkGraphicsFontStyle.eStkGraphicsFontStyleUnderline.__doc__ = "Underlined font."
AgEStkGraphicsFontStyle.eStkGraphicsFontStyleStrikeout.__doc__ = "Strike-out style."

agcls.AgTypeNameMap["AgEStkGraphicsFontStyle"] = AgEStkGraphicsFontStyle


class IPathPoint(object):
    """A path point used with the Path Primitive."""
    _uuid = "{9107fca2-51b8-4347-9391-9ee6c6b792e3}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_position"] = _raise_uninitialized_error
        self.__dict__["_set_position"] = _raise_uninitialized_error
        self.__dict__["_get_date"] = _raise_uninitialized_error
        self.__dict__["_get_color"] = _raise_uninitialized_error
        self.__dict__["_set_color"] = _raise_uninitialized_error
        self.__dict__["_get_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_outline_color"] = _raise_uninitialized_error
        self.__dict__["_set_outline_color"] = _raise_uninitialized_error
        self.__dict__["_get_outline_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_outline_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_is_translucent"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPathPoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPathPoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPathPoint = agcom.GUID(IPathPoint._uuid)
        vtable_offset_local = IPathPoint._vtable_offset - 1
        self.__dict__["_get_position"] = IAGFUNCTYPE(pUnk, IID_IPathPoint, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_position"] = IAGFUNCTYPE(pUnk, IID_IPathPoint, vtable_offset_local+2, agcom.SAFEARRAY)
        self.__dict__["_get_date"] = IAGFUNCTYPE(pUnk, IID_IPathPoint, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_color"] = IAGFUNCTYPE(pUnk, IID_IPathPoint, vtable_offset_local+4, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_color"] = IAGFUNCTYPE(pUnk, IID_IPathPoint, vtable_offset_local+5, agcom.OLE_COLOR)
        self.__dict__["_get_translucency"] = IAGFUNCTYPE(pUnk, IID_IPathPoint, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_translucency"] = IAGFUNCTYPE(pUnk, IID_IPathPoint, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_get_outline_color"] = IAGFUNCTYPE(pUnk, IID_IPathPoint, vtable_offset_local+8, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_outline_color"] = IAGFUNCTYPE(pUnk, IID_IPathPoint, vtable_offset_local+9, agcom.OLE_COLOR)
        self.__dict__["_get_outline_translucency"] = IAGFUNCTYPE(pUnk, IID_IPathPoint, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_outline_translucency"] = IAGFUNCTYPE(pUnk, IID_IPathPoint, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_is_translucent"] = IAGFUNCTYPE(pUnk, IID_IPathPoint, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPathPoint.__dict__ and type(IPathPoint.__dict__[attrname]) == property:
            return IPathPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPathPoint.")
    
    @property
    def position(self) -> list:
        """A path point position as a one-dimensional array of three elements corresponding to (X,Y,Z) cartesian coordinates."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @position.setter
    def position(self, position:list) -> None:
        with agmarshall.SAFEARRAY_arg(position) as arg_position:
            agcls.evaluate_hresult(self.__dict__["_set_position"](arg_position.COM_val))

    @property
    def date(self) -> "IDate":
        """A date/time of the path point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_date"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def color(self) -> agcolor.Color:
        """The path point color."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @color.setter
    def color(self, color:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(color) as arg_color:
            agcls.evaluate_hresult(self.__dict__["_set_color"](arg_color.COM_val))

    @property
    def translucency(self) -> float:
        """The path point translucency."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @translucency.setter
    def translucency(self, translucency:float) -> None:
        with agmarshall.DOUBLE_arg(translucency) as arg_translucency:
            agcls.evaluate_hresult(self.__dict__["_set_translucency"](arg_translucency.COM_val))

    @property
    def outline_color(self) -> agcolor.Color:
        """The path point outline color."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_color.setter
    def outline_color(self, outlineColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(outlineColor) as arg_outlineColor:
            agcls.evaluate_hresult(self.__dict__["_set_outline_color"](arg_outlineColor.COM_val))

    @property
    def outline_translucency(self) -> float:
        """The path point outline translucency."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_translucency.setter
    def outline_translucency(self, outlineTranslucency:float) -> None:
        with agmarshall.DOUBLE_arg(outlineTranslucency) as arg_outlineTranslucency:
            agcls.evaluate_hresult(self.__dict__["_set_outline_translucency"](arg_outlineTranslucency.COM_val))

    @property
    def is_translucent(self) -> bool:
        """Whether the path point is translucent."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_translucent"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{9107fca2-51b8-4347-9391-9ee6c6b792e3}", IPathPoint)
agcls.AgTypeNameMap["IPathPoint"] = IPathPoint

class IPathPointFactory(object):
    """Creates Path Primitive's path points."""
    _uuid = "{efb486c4-09f0-4918-b051-7776acd13f66}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_date"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_date_and_position"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_date_position_and_color"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_date_position_color_and_translucency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPathPointFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPathPointFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPathPointFactory = agcom.GUID(IPathPointFactory._uuid)
        vtable_offset_local = IPathPointFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IPathPointFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_date"] = IAGFUNCTYPE(pUnk, IID_IPathPointFactory, vtable_offset_local+2, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_date_and_position"] = IAGFUNCTYPE(pUnk, IID_IPathPointFactory, vtable_offset_local+3, agcom.PVOID, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_date_position_and_color"] = IAGFUNCTYPE(pUnk, IID_IPathPointFactory, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.SAFEARRAY), agcom.OLE_COLOR, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_date_position_color_and_translucency"] = IAGFUNCTYPE(pUnk, IID_IPathPointFactory, vtable_offset_local+5, agcom.PVOID, POINTER(agcom.SAFEARRAY), agcom.OLE_COLOR, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPathPointFactory.__dict__ and type(IPathPointFactory.__dict__[attrname]) == property:
            return IPathPointFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPathPointFactory.")
    
    def initialize(self) -> "IPathPoint":
        """Initializes a new path point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_date(self, pathPointDate:"IDate") -> "IPathPoint":
        """Initializes a new path point with the given date."""
        with agmarshall.AgInterface_in_arg(pathPointDate, IDate) as arg_pathPointDate, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_date"](arg_pathPointDate.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_date_and_position(self, pathPointDate:"IDate", position:list) -> "IPathPoint":
        """Initializes a new path point with the given date and position."""
        with agmarshall.AgInterface_in_arg(pathPointDate, IDate) as arg_pathPointDate, \
             agmarshall.SAFEARRAY_arg(position) as arg_position, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_date_and_position"](arg_pathPointDate.COM_val, byref(arg_position.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_date_position_and_color(self, pathPointDate:"IDate", position:list, color:agcolor.Color) -> "IPathPoint":
        """Initializes a new path point with the given date, position and color."""
        with agmarshall.AgInterface_in_arg(pathPointDate, IDate) as arg_pathPointDate, \
             agmarshall.SAFEARRAY_arg(position) as arg_position, \
             agmarshall.OLE_COLOR_arg(color) as arg_color, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_date_position_and_color"](arg_pathPointDate.COM_val, byref(arg_position.COM_val), arg_color.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_date_position_color_and_translucency(self, pathPointDate:"IDate", position:list, color:agcolor.Color, translucency:float) -> "IPathPoint":
        """Initializes a new path point with the given date, position, color and translucency."""
        with agmarshall.AgInterface_in_arg(pathPointDate, IDate) as arg_pathPointDate, \
             agmarshall.SAFEARRAY_arg(position) as arg_position, \
             agmarshall.OLE_COLOR_arg(color) as arg_color, \
             agmarshall.DOUBLE_arg(translucency) as arg_translucency, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_date_position_color_and_translucency"](arg_pathPointDate.COM_val, byref(arg_position.COM_val), arg_color.COM_val, arg_translucency.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{efb486c4-09f0-4918-b051-7776acd13f66}", IPathPointFactory)
agcls.AgTypeNameMap["IPathPointFactory"] = IPathPointFactory

class IBoundingSphere(object):
    """A sphere that encapsulates an object."""
    _uuid = "{68e2776e-6e9a-449a-8146-99e67cf8d16c}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_center"] = _raise_uninitialized_error
        self.__dict__["_get_radius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBoundingSphere._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBoundingSphere from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBoundingSphere = agcom.GUID(IBoundingSphere._uuid)
        vtable_offset_local = IBoundingSphere._vtable_offset - 1
        self.__dict__["_get_center"] = IAGFUNCTYPE(pUnk, IID_IBoundingSphere, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_radius"] = IAGFUNCTYPE(pUnk, IID_IBoundingSphere, vtable_offset_local+2, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBoundingSphere.__dict__ and type(IBoundingSphere.__dict__[attrname]) == property:
            return IBoundingSphere.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBoundingSphere.")
    
    @property
    def center(self) -> list:
        """A center of the bounding sphere. The center point is specified as one-dimensional array with three elements corresponding to (X,Y,Z) cartesian coordinates."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_center"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def radius(self) -> float:
        """A radius of the bounding sphere."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_radius"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{68e2776e-6e9a-449a-8146-99e67cf8d16c}", IBoundingSphere)
agcls.AgTypeNameMap["IBoundingSphere"] = IBoundingSphere

class IBoundingSphereFactory(object):
    """Creates instances of the bounding sphere type."""
    _uuid = "{fdde5510-3231-4c01-9c23-8485643e47ff}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_radius_bounding_sphere"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBoundingSphereFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBoundingSphereFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBoundingSphereFactory = agcom.GUID(IBoundingSphereFactory._uuid)
        vtable_offset_local = IBoundingSphereFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IBoundingSphereFactory, vtable_offset_local+1, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_get_maximum_radius_bounding_sphere"] = IAGFUNCTYPE(pUnk, IID_IBoundingSphereFactory, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBoundingSphereFactory.__dict__ and type(IBoundingSphereFactory.__dict__[attrname]) == property:
            return IBoundingSphereFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBoundingSphereFactory.")
    
    def initialize(self, center:list, radius:float) -> "IBoundingSphere":
        """Create instances of BoundingSphere."""
        with agmarshall.SAFEARRAY_arg(center) as arg_center, \
             agmarshall.DOUBLE_arg(radius) as arg_radius, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_center.COM_val), arg_radius.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def maximum_radius_bounding_sphere(self) -> "IBoundingSphere":
        """Gets the bounding sphere of maximum possible radius."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_radius_bounding_sphere"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{fdde5510-3231-4c01-9c23-8485643e47ff}", IBoundingSphereFactory)
agcls.AgTypeNameMap["IBoundingSphereFactory"] = IBoundingSphereFactory

class ITextureFilter2D(object):
    """A texture filter."""
    _uuid = "{c71ed80c-abbc-4ce5-bf56-a21ea03c4593}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_minification_filter"] = _raise_uninitialized_error
        self.__dict__["_get_magnification_filter"] = _raise_uninitialized_error
        self.__dict__["_get_wrap_s"] = _raise_uninitialized_error
        self.__dict__["_get_wrap_t"] = _raise_uninitialized_error
        self.__dict__["_get_nearest_clamp_to_edge"] = _raise_uninitialized_error
        self.__dict__["_get_nearest_repeat"] = _raise_uninitialized_error
        self.__dict__["_get_linear_clamp_to_edge"] = _raise_uninitialized_error
        self.__dict__["_get_linear_repeat"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITextureFilter2D._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITextureFilter2D from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITextureFilter2D = agcom.GUID(ITextureFilter2D._uuid)
        vtable_offset_local = ITextureFilter2D._vtable_offset - 1
        self.__dict__["_get_minification_filter"] = IAGFUNCTYPE(pUnk, IID_ITextureFilter2D, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_get_magnification_filter"] = IAGFUNCTYPE(pUnk, IID_ITextureFilter2D, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_get_wrap_s"] = IAGFUNCTYPE(pUnk, IID_ITextureFilter2D, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_wrap_t"] = IAGFUNCTYPE(pUnk, IID_ITextureFilter2D, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_get_nearest_clamp_to_edge"] = IAGFUNCTYPE(pUnk, IID_ITextureFilter2D, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_nearest_repeat"] = IAGFUNCTYPE(pUnk, IID_ITextureFilter2D, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_linear_clamp_to_edge"] = IAGFUNCTYPE(pUnk, IID_ITextureFilter2D, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_linear_repeat"] = IAGFUNCTYPE(pUnk, IID_ITextureFilter2D, vtable_offset_local+8, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITextureFilter2D.__dict__ and type(ITextureFilter2D.__dict__[attrname]) == property:
            return ITextureFilter2D.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITextureFilter2D.")
    
    @property
    def minification_filter(self) -> "AgEStkGraphicsMinificationFilter":
        """Gets the minification filter used when the pixel being textured maps to an area less than or equal to one texel."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMinificationFilter) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minification_filter"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def magnification_filter(self) -> "AgEStkGraphicsMagnificationFilter":
        """Gets the magnification filter used when the pixel being textured maps to an area greater than one texel."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMagnificationFilter) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_magnification_filter"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def wrap_s(self) -> "AgEStkGraphicsTextureWrap":
        """Gets the texture wrap for the s direction."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsTextureWrap) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_wrap_s"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def wrap_t(self) -> "AgEStkGraphicsTextureWrap":
        """Gets the texture wrap for the t direction."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsTextureWrap) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_wrap_t"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def nearest_clamp_to_edge(self) -> "ITextureFilter2D":
        """Gets a texture filter with the following properties: MinificationFilter: Nearest, MagnificationFilter: Nearest, WrapS: ClampToEdge, WrapT: ClampToEdge"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_nearest_clamp_to_edge"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def nearest_repeat(self) -> "ITextureFilter2D":
        """Gets a texture filter with the following properties: MinificationFilter: Nearest, MagnificationFilter: Nearest, WrapS: Repeat, WrapT: Repeat"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_nearest_repeat"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def linear_clamp_to_edge(self) -> "ITextureFilter2D":
        """Gets a texture filter with the following properties: MinificationFilter: Linear, MagnificationFilter: Linear, WrapS: ClampToEdge, WrapT: ClampToEdge"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_linear_clamp_to_edge"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def linear_repeat(self) -> "ITextureFilter2D":
        """Gets a texture filter with the following properties: MinificationFilter: Linear, MagnificationFilter: Linear, WrapS: Repeat, WrapT: Repeat"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_linear_repeat"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{c71ed80c-abbc-4ce5-bf56-a21ea03c4593}", ITextureFilter2D)
agcls.AgTypeNameMap["ITextureFilter2D"] = ITextureFilter2D

class ITextureFilter2DFactory(object):
    """Creates texture filters."""
    _uuid = "{8e616d0f-4cf9-4dfd-b7fd-1295dd9131e5}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_nearest_clamp_to_edge"] = _raise_uninitialized_error
        self.__dict__["_get_nearest_repeat"] = _raise_uninitialized_error
        self.__dict__["_get_linear_clamp_to_edge"] = _raise_uninitialized_error
        self.__dict__["_get_linear_repeat"] = _raise_uninitialized_error
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_texture_wrap"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_minification_and_magnification"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITextureFilter2DFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITextureFilter2DFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITextureFilter2DFactory = agcom.GUID(ITextureFilter2DFactory._uuid)
        vtable_offset_local = ITextureFilter2DFactory._vtable_offset - 1
        self.__dict__["_get_nearest_clamp_to_edge"] = IAGFUNCTYPE(pUnk, IID_ITextureFilter2DFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_nearest_repeat"] = IAGFUNCTYPE(pUnk, IID_ITextureFilter2DFactory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_linear_clamp_to_edge"] = IAGFUNCTYPE(pUnk, IID_ITextureFilter2DFactory, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_linear_repeat"] = IAGFUNCTYPE(pUnk, IID_ITextureFilter2DFactory, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ITextureFilter2DFactory, vtable_offset_local+5, agcom.LONG, agcom.LONG, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_texture_wrap"] = IAGFUNCTYPE(pUnk, IID_ITextureFilter2DFactory, vtable_offset_local+6, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_minification_and_magnification"] = IAGFUNCTYPE(pUnk, IID_ITextureFilter2DFactory, vtable_offset_local+7, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITextureFilter2DFactory.__dict__ and type(ITextureFilter2DFactory.__dict__[attrname]) == property:
            return ITextureFilter2DFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITextureFilter2DFactory.")
    
    @property
    def nearest_clamp_to_edge(self) -> "ITextureFilter2D":
        """Gets a texture filter with the following properties: MinificationFilter: Nearest, MagnificationFilter: Nearest, WrapS: ClampToEdge, WrapT: ClampToEdge"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_nearest_clamp_to_edge"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def nearest_repeat(self) -> "ITextureFilter2D":
        """Gets a texture filter with the following properties: MinificationFilter: Nearest, MagnificationFilter: Nearest, WrapS: Repeat, WrapT: Repeat"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_nearest_repeat"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def linear_clamp_to_edge(self) -> "ITextureFilter2D":
        """Gets a texture filter with the following properties: MinificationFilter: Linear, MagnificationFilter: Linear, WrapS: ClampToEdge, WrapT: ClampToEdge"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_linear_clamp_to_edge"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def linear_repeat(self) -> "ITextureFilter2D":
        """Gets a texture filter with the following properties: MinificationFilter: Linear, MagnificationFilter: Linear, WrapS: Repeat, WrapT: Repeat"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_linear_repeat"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize(self, minificationFilter:"AgEStkGraphicsMinificationFilter", magnificationFilter:"AgEStkGraphicsMagnificationFilter", wrapS:"AgEStkGraphicsTextureWrap", wrapT:"AgEStkGraphicsTextureWrap") -> "ITextureFilter2D":
        """Creates a texture filter using the specified minification/magnification options and texture wrap."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMinificationFilter, minificationFilter) as arg_minificationFilter, \
             agmarshall.AgEnum_arg(AgEStkGraphicsMagnificationFilter, magnificationFilter) as arg_magnificationFilter, \
             agmarshall.AgEnum_arg(AgEStkGraphicsTextureWrap, wrapS) as arg_wrapS, \
             agmarshall.AgEnum_arg(AgEStkGraphicsTextureWrap, wrapT) as arg_wrapT, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](arg_minificationFilter.COM_val, arg_magnificationFilter.COM_val, arg_wrapS.COM_val, arg_wrapT.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_texture_wrap(self, wrapS:"AgEStkGraphicsTextureWrap", wrapT:"AgEStkGraphicsTextureWrap") -> "ITextureFilter2D":
        """Creates a texture filter using the specified texture wrap."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsTextureWrap, wrapS) as arg_wrapS, \
             agmarshall.AgEnum_arg(AgEStkGraphicsTextureWrap, wrapT) as arg_wrapT, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_texture_wrap"](arg_wrapS.COM_val, arg_wrapT.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_minification_and_magnification(self, minificationFilter:"AgEStkGraphicsMinificationFilter", magnificationFilter:"AgEStkGraphicsMagnificationFilter") -> "ITextureFilter2D":
        """Creates a texture filter using the specified minification/magnification options."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMinificationFilter, minificationFilter) as arg_minificationFilter, \
             agmarshall.AgEnum_arg(AgEStkGraphicsMagnificationFilter, magnificationFilter) as arg_magnificationFilter, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_minification_and_magnification"](arg_minificationFilter.COM_val, arg_magnificationFilter.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8e616d0f-4cf9-4dfd-b7fd-1295dd9131e5}", ITextureFilter2DFactory)
agcls.AgTypeNameMap["ITextureFilter2DFactory"] = ITextureFilter2DFactory

class IRendererTexture2D(object):
    """A 2D Texture. A texture represents an image that is ready for use by objects such as primitives and overlays. Textures typically reside in video memory."""
    _uuid = "{b207af7e-f2b5-4b2f-89f6-1fc3721102b3}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_template"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRendererTexture2D._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRendererTexture2D from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRendererTexture2D = agcom.GUID(IRendererTexture2D._uuid)
        vtable_offset_local = IRendererTexture2D._vtable_offset - 1
        self.__dict__["_get_template"] = IAGFUNCTYPE(pUnk, IID_IRendererTexture2D, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRendererTexture2D.__dict__ and type(IRendererTexture2D.__dict__[attrname]) == property:
            return IRendererTexture2D.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRendererTexture2D.")
    
    @property
    def template(self) -> "IRendererTextureTemplate2D":
        """Gets a template from which the texture was created."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_template"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{b207af7e-f2b5-4b2f-89f6-1fc3721102b3}", IRendererTexture2D)
agcls.AgTypeNameMap["IRendererTexture2D"] = IRendererTexture2D

class IRendererTextureTemplate2D(object):
    """Template object containing attributes required to create a 2D texture."""
    _uuid = "{46fbfc4c-29b8-49c7-beb7-77bc5d836f10}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_internal_format"] = _raise_uninitialized_error
        self.__dict__["_get_width"] = _raise_uninitialized_error
        self.__dict__["_get_height"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRendererTextureTemplate2D._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRendererTextureTemplate2D from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRendererTextureTemplate2D = agcom.GUID(IRendererTextureTemplate2D._uuid)
        vtable_offset_local = IRendererTextureTemplate2D._vtable_offset - 1
        self.__dict__["_get_internal_format"] = IAGFUNCTYPE(pUnk, IID_IRendererTextureTemplate2D, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_get_width"] = IAGFUNCTYPE(pUnk, IID_IRendererTextureTemplate2D, vtable_offset_local+2, POINTER(agcom.INT))
        self.__dict__["_get_height"] = IAGFUNCTYPE(pUnk, IID_IRendererTextureTemplate2D, vtable_offset_local+3, POINTER(agcom.INT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRendererTextureTemplate2D.__dict__ and type(IRendererTextureTemplate2D.__dict__[attrname]) == property:
            return IRendererTextureTemplate2D.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRendererTextureTemplate2D.")
    
    @property
    def internal_format(self) -> "AgEStkGraphicsInternalTextureFormat":
        """Gets an internal format of the texture."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsInternalTextureFormat) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_internal_format"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def width(self) -> int:
        """Gets a width of the texture in texels."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def height(self) -> int:
        """Gets a height of the texture in texels."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_height"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{46fbfc4c-29b8-49c7-beb7-77bc5d836f10}", IRendererTextureTemplate2D)
agcls.AgTypeNameMap["IRendererTextureTemplate2D"] = IRendererTextureTemplate2D

class IPathPointCollection(object):
    """A collection of path points."""
    _uuid = "{9214e199-6476-4ef1-a741-13362718bdd5}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPathPointCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPathPointCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPathPointCollection = agcom.GUID(IPathPointCollection._uuid)
        vtable_offset_local = IPathPointCollection._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IPathPointCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IPathPointCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IPathPointCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPathPointCollection.__dict__ and type(IPathPointCollection.__dict__[attrname]) == property:
            return IPathPointCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPathPointCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IPathPoint":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """A total number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> "IPathPoint":
        """Returns a path point at the specified position in the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{9214e199-6476-4ef1-a741-13362718bdd5}", IPathPointCollection)
agcls.AgTypeNameMap["IPathPointCollection"] = IPathPointCollection

class IObjectCollection(object):
    """A collection of objects."""
    _uuid = "{feb3a8c8-dc5b-4246-a8ec-1d6154b4cf68}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IObjectCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IObjectCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IObjectCollection = agcom.GUID(IObjectCollection._uuid)
        vtable_offset_local = IObjectCollection._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IObjectCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IObjectCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IObjectCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IObjectCollection.__dict__ and type(IObjectCollection.__dict__[attrname]) == property:
            return IObjectCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IObjectCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> typing.Any:
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """A total number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> typing.Any:
        """An item in the collection at the specified index."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{feb3a8c8-dc5b-4246-a8ec-1d6154b4cf68}", IObjectCollection)
agcls.AgTypeNameMap["IObjectCollection"] = IObjectCollection

class ISceneCollection(object):
    """A collection of scenes."""
    _uuid = "{aac03f9e-8c23-4a8d-ad88-455deb232f0b}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISceneCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISceneCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISceneCollection = agcom.GUID(ISceneCollection._uuid)
        vtable_offset_local = ISceneCollection._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ISceneCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_ISceneCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_ISceneCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISceneCollection.__dict__ and type(ISceneCollection.__dict__[attrname]) == property:
            return ISceneCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISceneCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IScene":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """Total number of scenes in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> "IScene":
        """A scene in the collection at a specified index."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{aac03f9e-8c23-4a8d-ad88-455deb232f0b}", ISceneCollection)
agcls.AgTypeNameMap["ISceneCollection"] = ISceneCollection

class IScreenOverlayContainer(object):
    """The interface for screen overlays that contain a collection of other overlays. This interface is implemented by ScreenOverlayManager and ScreenOverlay."""
    _uuid = "{5e57d9b7-f014-46d7-8b6d-b38d47e7ce41}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_overlays"] = _raise_uninitialized_error
        self.__dict__["_get_padding"] = _raise_uninitialized_error
        self.__dict__["_set_padding"] = _raise_uninitialized_error
        self.__dict__["_get_display"] = _raise_uninitialized_error
        self.__dict__["_set_display"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScreenOverlayContainer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScreenOverlayContainer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScreenOverlayContainer = agcom.GUID(IScreenOverlayContainer._uuid)
        vtable_offset_local = IScreenOverlayContainer._vtable_offset - 1
        self.__dict__["_get_overlays"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayContainer, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_padding"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayContainer, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_padding"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayContainer, vtable_offset_local+3, agcom.SAFEARRAY)
        self.__dict__["_get_display"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayContainer, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayContainer, vtable_offset_local+5, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScreenOverlayContainer.__dict__ and type(IScreenOverlayContainer.__dict__[attrname]) == property:
            return IScreenOverlayContainer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScreenOverlayContainer.")
    
    @property
    def overlays(self) -> "IScreenOverlayCollection":
        """Gets the collection of overlays that are contained within this overlay."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_overlays"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def padding(self) -> list:
        """Gets or sets the padding surrounding the overlays that are contained within this overlay. The array contains the components of the padding arranged in the order left, top, right, bottom."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_padding"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @padding.setter
    def padding(self, padding:list) -> None:
        with agmarshall.SAFEARRAY_arg(padding) as arg_padding:
            agcls.evaluate_hresult(self.__dict__["_set_padding"](arg_padding.COM_val))

    @property
    def display(self) -> bool:
        """Gets or sets if this overlay and the collection of overlays that are contained within this overlay should be rendered."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display.setter
    def display(self, display:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(display) as arg_display:
            agcls.evaluate_hresult(self.__dict__["_set_display"](arg_display.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5e57d9b7-f014-46d7-8b6d-b38d47e7ce41}", IScreenOverlayContainer)
agcls.AgTypeNameMap["IScreenOverlayContainer"] = IScreenOverlayContainer

class IScreenOverlayPickResultCollection(object):
    """A collection of pick results."""
    _uuid = "{6c1f8d2c-1b38-482c-b935-b174003284bb}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScreenOverlayPickResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScreenOverlayPickResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScreenOverlayPickResultCollection = agcom.GUID(IScreenOverlayPickResultCollection._uuid)
        vtable_offset_local = IScreenOverlayPickResultCollection._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayPickResultCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayPickResultCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayPickResultCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScreenOverlayPickResultCollection.__dict__ and type(IScreenOverlayPickResultCollection.__dict__[attrname]) == property:
            return IScreenOverlayPickResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScreenOverlayPickResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IScreenOverlayPickResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """A total number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> "IScreenOverlayPickResult":
        """Get an element at the specified position in the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{6c1f8d2c-1b38-482c-b935-b174003284bb}", IScreenOverlayPickResultCollection)
agcls.AgTypeNameMap["IScreenOverlayPickResultCollection"] = IScreenOverlayPickResultCollection

class IGlobeImageOverlayAddCompleteEventArgs(object):
    """The event is raised when the globe image overlay is displayed for the first time after being added using AddAsync."""
    _uuid = "{bbe097c9-d64c-4474-ba9a-fb47c76388ba}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_overlay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGlobeImageOverlayAddCompleteEventArgs._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGlobeImageOverlayAddCompleteEventArgs from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGlobeImageOverlayAddCompleteEventArgs = agcom.GUID(IGlobeImageOverlayAddCompleteEventArgs._uuid)
        vtable_offset_local = IGlobeImageOverlayAddCompleteEventArgs._vtable_offset - 1
        self.__dict__["_get_overlay"] = IAGFUNCTYPE(pUnk, IID_IGlobeImageOverlayAddCompleteEventArgs, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGlobeImageOverlayAddCompleteEventArgs.__dict__ and type(IGlobeImageOverlayAddCompleteEventArgs.__dict__[attrname]) == property:
            return IGlobeImageOverlayAddCompleteEventArgs.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGlobeImageOverlayAddCompleteEventArgs.")
    
    @property
    def overlay(self) -> "IGlobeImageOverlay":
        """The overlay object that was added earlier using AddAsync."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{bbe097c9-d64c-4474-ba9a-fb47c76388ba}", IGlobeImageOverlayAddCompleteEventArgs)
agcls.AgTypeNameMap["IGlobeImageOverlayAddCompleteEventArgs"] = IGlobeImageOverlayAddCompleteEventArgs

class ITerrainOverlayAddCompleteEventArgs(object):
    """The event is raised when the terrain overlay is displayed for the first time after having been added using AddAsync."""
    _uuid = "{76a70982-21b5-427f-9db1-c0b92950b516}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_overlay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITerrainOverlayAddCompleteEventArgs._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITerrainOverlayAddCompleteEventArgs from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITerrainOverlayAddCompleteEventArgs = agcom.GUID(ITerrainOverlayAddCompleteEventArgs._uuid)
        vtable_offset_local = ITerrainOverlayAddCompleteEventArgs._vtable_offset - 1
        self.__dict__["_get_overlay"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayAddCompleteEventArgs, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITerrainOverlayAddCompleteEventArgs.__dict__ and type(ITerrainOverlayAddCompleteEventArgs.__dict__[attrname]) == property:
            return ITerrainOverlayAddCompleteEventArgs.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITerrainOverlayAddCompleteEventArgs.")
    
    @property
    def overlay(self) -> "ITerrainOverlay":
        """The terrain overlay being displayed for the first time."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{76a70982-21b5-427f-9db1-c0b92950b516}", ITerrainOverlayAddCompleteEventArgs)
agcls.AgTypeNameMap["ITerrainOverlayAddCompleteEventArgs"] = ITerrainOverlayAddCompleteEventArgs

class IPickResultCollection(object):
    """A collection of picked objects."""
    _uuid = "{2d29d5b1-b160-49ad-8f58-cef696bc952a}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPickResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPickResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPickResultCollection = agcom.GUID(IPickResultCollection._uuid)
        vtable_offset_local = IPickResultCollection._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IPickResultCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IPickResultCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IPickResultCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPickResultCollection.__dict__ and type(IPickResultCollection.__dict__[attrname]) == property:
            return IPickResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPickResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IPickResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """A total number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> "IPickResult":
        """Returns a picked object at the specified position in the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{2d29d5b1-b160-49ad-8f58-cef696bc952a}", IPickResultCollection)
agcls.AgTypeNameMap["IPickResultCollection"] = IPickResultCollection

class IRenderingEventArgs(object):
    """The event is raised when the scene is rendered."""
    _uuid = "{7c1eea22-fad1-437e-9282-f9202cd103bd}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_time"] = _raise_uninitialized_error
        self.__dict__["_get_time_in_ep_secs"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRenderingEventArgs._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRenderingEventArgs from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRenderingEventArgs = agcom.GUID(IRenderingEventArgs._uuid)
        vtable_offset_local = IRenderingEventArgs._vtable_offset - 1
        self.__dict__["_get_time"] = IAGFUNCTYPE(pUnk, IID_IRenderingEventArgs, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_time_in_ep_secs"] = IAGFUNCTYPE(pUnk, IID_IRenderingEventArgs, vtable_offset_local+2, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRenderingEventArgs.__dict__ and type(IRenderingEventArgs.__dict__[attrname]) == property:
            return IRenderingEventArgs.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRenderingEventArgs.")
    
    @property
    def time(self) -> "IDate":
        """The time of the rendering event."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_time"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def time_in_ep_secs(self) -> float:
        """The time of the rendering event (in STK's scenario epoch units)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_time_in_ep_secs"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7c1eea22-fad1-437e-9282-f9202cd103bd}", IRenderingEventArgs)
agcls.AgTypeNameMap["IRenderingEventArgs"] = IRenderingEventArgs

class IBatchPrimitiveIndex(object):
    """Represents an individual item index that is associated with a batch primitive. Provides the Index of the individual item and the Primitive that contains that index..."""
    _uuid = "{15dae589-33b5-4629-a50f-485a49546ddf}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_index"] = _raise_uninitialized_error
        self.__dict__["_get_primitive"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBatchPrimitiveIndex._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBatchPrimitiveIndex from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBatchPrimitiveIndex = agcom.GUID(IBatchPrimitiveIndex._uuid)
        vtable_offset_local = IBatchPrimitiveIndex._vtable_offset - 1
        self.__dict__["_get_index"] = IAGFUNCTYPE(pUnk, IID_IBatchPrimitiveIndex, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_get_primitive"] = IAGFUNCTYPE(pUnk, IID_IBatchPrimitiveIndex, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBatchPrimitiveIndex.__dict__ and type(IBatchPrimitiveIndex.__dict__[attrname]) == property:
            return IBatchPrimitiveIndex.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBatchPrimitiveIndex.")
    
    @property
    def index(self) -> int:
        """The index of the item contained by the Primitive."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_index"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def primitive(self) -> "IPrimitive":
        """The Primitive that contains the item at the Index specified."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_primitive"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{15dae589-33b5-4629-a50f-485a49546ddf}", IBatchPrimitiveIndex)
agcls.AgTypeNameMap["IBatchPrimitiveIndex"] = IBatchPrimitiveIndex

class IKmlDocumentCollection(object):
    """A collection of KML documents."""
    _uuid = "{8f385d51-5b9c-4f8d-8340-1e8f49b51a6a}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IKmlDocumentCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IKmlDocumentCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IKmlDocumentCollection = agcom.GUID(IKmlDocumentCollection._uuid)
        vtable_offset_local = IKmlDocumentCollection._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IKmlDocumentCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IKmlDocumentCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IKmlDocumentCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IKmlDocumentCollection.__dict__ and type(IKmlDocumentCollection.__dict__[attrname]) == property:
            return IKmlDocumentCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IKmlDocumentCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IKmlDocument":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """A total number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> "IKmlDocument":
        """Get an element at the specified position in the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{8f385d51-5b9c-4f8d-8340-1e8f49b51a6a}", IKmlDocumentCollection)
agcls.AgTypeNameMap["IKmlDocumentCollection"] = IKmlDocumentCollection

class IKmlFeatureCollection(object):
    """A collection of KML features."""
    _uuid = "{e4f1dff5-fbb1-4951-bfc0-abfeec89acc8}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IKmlFeatureCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IKmlFeatureCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IKmlFeatureCollection = agcom.GUID(IKmlFeatureCollection._uuid)
        vtable_offset_local = IKmlFeatureCollection._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IKmlFeatureCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IKmlFeatureCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IKmlFeatureCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IKmlFeatureCollection.__dict__ and type(IKmlFeatureCollection.__dict__[attrname]) == property:
            return IKmlFeatureCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IKmlFeatureCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IKmlFeature":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """A total number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> "IKmlFeature":
        """Get an element at the specified position in the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{e4f1dff5-fbb1-4951-bfc0-abfeec89acc8}", IKmlFeatureCollection)
agcls.AgTypeNameMap["IKmlFeatureCollection"] = IKmlFeatureCollection

class IKmlDocumentLoadedEventArgs(object):
    """The event is raised when a KML document has been loaded."""
    _uuid = "{60d78883-928f-45f2-ab60-0becb167af3d}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_document"] = _raise_uninitialized_error
        self.__dict__["_get_exception"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IKmlDocumentLoadedEventArgs._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IKmlDocumentLoadedEventArgs from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IKmlDocumentLoadedEventArgs = agcom.GUID(IKmlDocumentLoadedEventArgs._uuid)
        vtable_offset_local = IKmlDocumentLoadedEventArgs._vtable_offset - 1
        self.__dict__["_get_document"] = IAGFUNCTYPE(pUnk, IID_IKmlDocumentLoadedEventArgs, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_exception"] = IAGFUNCTYPE(pUnk, IID_IKmlDocumentLoadedEventArgs, vtable_offset_local+2, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IKmlDocumentLoadedEventArgs.__dict__ and type(IKmlDocumentLoadedEventArgs.__dict__[attrname]) == property:
            return IKmlDocumentLoadedEventArgs.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IKmlDocumentLoadedEventArgs.")
    
    @property
    def document(self) -> "IKmlDocument":
        """Gets the KML document associated with the load event."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_document"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def exception(self) -> str:
        """Returns an error message, if an error occurred while loading the KML; otherwise an empty string."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_exception"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{60d78883-928f-45f2-ab60-0becb167af3d}", IKmlDocumentLoadedEventArgs)
agcls.AgTypeNameMap["IKmlDocumentLoadedEventArgs"] = IKmlDocumentLoadedEventArgs

class IFactoryAndInitializers(object):
    """Methods and properties are used to initialize new primitives, display conditions, screen overlays, textures and many other types; compute and retrieve triangulator results and access global properties (what's known as static properties, static methods a..."""
    _uuid = "{5ccf1ef3-48a0-4b22-9fcf-c32eae3f8d69}"
    _num_methods = 83
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_box_triangulator"] = _raise_uninitialized_error
        self.__dict__["_get_cylinder_triangulator"] = _raise_uninitialized_error
        self.__dict__["_get_ellipsoid_triangulator"] = _raise_uninitialized_error
        self.__dict__["_get_extruded_polyline_triangulator"] = _raise_uninitialized_error
        self.__dict__["_get_surface_extent_triangulator"] = _raise_uninitialized_error
        self.__dict__["_get_surface_polygon_triangulator"] = _raise_uninitialized_error
        self.__dict__["_get_surface_shapes"] = _raise_uninitialized_error
        self.__dict__["_get_agi_processed_image_globe_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_agi_processed_terrain_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_agi_roam_image_globe_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_custom_image_globe_overlay_plugin_activator"] = _raise_uninitialized_error
        self.__dict__["_get_geospatial_image_globe_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_projected_raster_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_projection"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_display_condition"] = _raise_uninitialized_error
        self.__dict__["_get_composite_display_condition"] = _raise_uninitialized_error
        self.__dict__["_get_composite_primitive"] = _raise_uninitialized_error
        self.__dict__["_get_constant_display_condition"] = _raise_uninitialized_error
        self.__dict__["_get_distance_display_condition"] = _raise_uninitialized_error
        self.__dict__["_get_distance_to_globe_overlay_display_condition"] = _raise_uninitialized_error
        self.__dict__["_get_distance_to_position_display_condition"] = _raise_uninitialized_error
        self.__dict__["_get_distance_to_primitive_display_condition"] = _raise_uninitialized_error
        self.__dict__["_get_duration_path_primitive_update_policy"] = _raise_uninitialized_error
        self.__dict__["_get_globe_image_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_graphics_font"] = _raise_uninitialized_error
        self.__dict__["_get_great_arc_interpolator"] = _raise_uninitialized_error
        self.__dict__["_get_alpha_from_luminance_filter"] = _raise_uninitialized_error
        self.__dict__["_get_alpha_from_pixel_filter"] = _raise_uninitialized_error
        self.__dict__["_get_alpha_from_raster_filter"] = _raise_uninitialized_error
        self.__dict__["_get_band_extract_filter"] = _raise_uninitialized_error
        self.__dict__["_get_band_order_filter"] = _raise_uninitialized_error
        self.__dict__["_get_blur_filter"] = _raise_uninitialized_error
        self.__dict__["_get_brightness_filter"] = _raise_uninitialized_error
        self.__dict__["_get_color_to_luminance_filter"] = _raise_uninitialized_error
        self.__dict__["_get_contrast_filter"] = _raise_uninitialized_error
        self.__dict__["_get_convolution_filter"] = _raise_uninitialized_error
        self.__dict__["_get_edge_detect_filter"] = _raise_uninitialized_error
        self.__dict__["_get_filtering_raster_stream"] = _raise_uninitialized_error
        self.__dict__["_get_flip_filter"] = _raise_uninitialized_error
        self.__dict__["_get_gamma_correction_filter"] = _raise_uninitialized_error
        self.__dict__["_get_gaussian_blur_filter"] = _raise_uninitialized_error
        self.__dict__["_get_gradient_detect_filter"] = _raise_uninitialized_error
        self.__dict__["_get_jpeg2000_writer"] = _raise_uninitialized_error
        self.__dict__["_get_levels_filter"] = _raise_uninitialized_error
        self.__dict__["_get_projection_raster_stream_plugin_activator"] = _raise_uninitialized_error
        self.__dict__["_get_raster"] = _raise_uninitialized_error
        self.__dict__["_get_raster_attributes"] = _raise_uninitialized_error
        self.__dict__["_get_rotate_filter"] = _raise_uninitialized_error
        self.__dict__["_get_sequence_filter"] = _raise_uninitialized_error
        self.__dict__["_get_sharpen_filter"] = _raise_uninitialized_error
        self.__dict__["_get_video_stream"] = _raise_uninitialized_error
        self.__dict__["_get_marker_batch_primitive"] = _raise_uninitialized_error
        self.__dict__["_get_marker_batch_primitive_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_count_path_primitive_update_policy"] = _raise_uninitialized_error
        self.__dict__["_get_model_primitive"] = _raise_uninitialized_error
        self.__dict__["_get_path_primitive"] = _raise_uninitialized_error
        self.__dict__["_get_pixel_size_display_condition"] = _raise_uninitialized_error
        self.__dict__["_get_point_batch_primitive"] = _raise_uninitialized_error
        self.__dict__["_get_polyline_primitive"] = _raise_uninitialized_error
        self.__dict__["_get_raster_image_globe_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_rhumb_line_interpolator"] = _raise_uninitialized_error
        self.__dict__["_get_scene_display_condition"] = _raise_uninitialized_error
        self.__dict__["_get_scene_manager"] = _raise_uninitialized_error
        self.__dict__["_get_screen_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_solid_primitive"] = _raise_uninitialized_error
        self.__dict__["_get_surface_mesh_primitive"] = _raise_uninitialized_error
        self.__dict__["_get_terrain_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_text_batch_primitive"] = _raise_uninitialized_error
        self.__dict__["_get_text_batch_primitive_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_get_texture_matrix"] = _raise_uninitialized_error
        self.__dict__["_get_texture_screen_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_time_interval_display_condition"] = _raise_uninitialized_error
        self.__dict__["_get_triangle_mesh_primitive"] = _raise_uninitialized_error
        self.__dict__["_get_triangle_mesh_primitive_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_get_texture_filter2_d"] = _raise_uninitialized_error
        self.__dict__["_get_bounding_sphere"] = _raise_uninitialized_error
        self.__dict__["_get_path_point"] = _raise_uninitialized_error
        self.__dict__["_get_text_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_agi_custom_terrain_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_axes_primitive"] = _raise_uninitialized_error
        self.__dict__["_get_vector_primitive"] = _raise_uninitialized_error
        self.__dict__["_get_polyline_primitive_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_get_point_batch_primitive_optional_parameters"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IFactoryAndInitializers._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IFactoryAndInitializers from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IFactoryAndInitializers = agcom.GUID(IFactoryAndInitializers._uuid)
        vtable_offset_local = IFactoryAndInitializers._vtable_offset - 1
        self.__dict__["_get_box_triangulator"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_cylinder_triangulator"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_ellipsoid_triangulator"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_extruded_polyline_triangulator"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_surface_extent_triangulator"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_surface_polygon_triangulator"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_surface_shapes"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_agi_processed_image_globe_overlay"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_get_agi_processed_terrain_overlay"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_agi_roam_image_globe_overlay"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_get_custom_image_globe_overlay_plugin_activator"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_get_geospatial_image_globe_overlay"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+12, POINTER(agcom.PVOID))
        self.__dict__["_get_projected_raster_overlay"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_get_projection"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+14, POINTER(agcom.PVOID))
        self.__dict__["_get_altitude_display_condition"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_get_composite_display_condition"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+16, POINTER(agcom.PVOID))
        self.__dict__["_get_composite_primitive"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_get_constant_display_condition"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+18, POINTER(agcom.PVOID))
        self.__dict__["_get_distance_display_condition"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+19, POINTER(agcom.PVOID))
        self.__dict__["_get_distance_to_globe_overlay_display_condition"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+20, POINTER(agcom.PVOID))
        self.__dict__["_get_distance_to_position_display_condition"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+21, POINTER(agcom.PVOID))
        self.__dict__["_get_distance_to_primitive_display_condition"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+22, POINTER(agcom.PVOID))
        self.__dict__["_get_duration_path_primitive_update_policy"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_get_globe_image_overlay"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+24, POINTER(agcom.PVOID))
        self.__dict__["_get_graphics_font"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_get_great_arc_interpolator"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+26, POINTER(agcom.PVOID))
        self.__dict__["_get_alpha_from_luminance_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+27, POINTER(agcom.PVOID))
        self.__dict__["_get_alpha_from_pixel_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+28, POINTER(agcom.PVOID))
        self.__dict__["_get_alpha_from_raster_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+29, POINTER(agcom.PVOID))
        self.__dict__["_get_band_extract_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+30, POINTER(agcom.PVOID))
        self.__dict__["_get_band_order_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+31, POINTER(agcom.PVOID))
        self.__dict__["_get_blur_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+32, POINTER(agcom.PVOID))
        self.__dict__["_get_brightness_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+33, POINTER(agcom.PVOID))
        self.__dict__["_get_color_to_luminance_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+34, POINTER(agcom.PVOID))
        self.__dict__["_get_contrast_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+35, POINTER(agcom.PVOID))
        self.__dict__["_get_convolution_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+36, POINTER(agcom.PVOID))
        self.__dict__["_get_edge_detect_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+37, POINTER(agcom.PVOID))
        self.__dict__["_get_filtering_raster_stream"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+38, POINTER(agcom.PVOID))
        self.__dict__["_get_flip_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+39, POINTER(agcom.PVOID))
        self.__dict__["_get_gamma_correction_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+40, POINTER(agcom.PVOID))
        self.__dict__["_get_gaussian_blur_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+41, POINTER(agcom.PVOID))
        self.__dict__["_get_gradient_detect_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+42, POINTER(agcom.PVOID))
        self.__dict__["_get_jpeg2000_writer"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+43, POINTER(agcom.PVOID))
        self.__dict__["_get_levels_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+44, POINTER(agcom.PVOID))
        self.__dict__["_get_projection_raster_stream_plugin_activator"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+45, POINTER(agcom.PVOID))
        self.__dict__["_get_raster"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+46, POINTER(agcom.PVOID))
        self.__dict__["_get_raster_attributes"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+47, POINTER(agcom.PVOID))
        self.__dict__["_get_rotate_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+48, POINTER(agcom.PVOID))
        self.__dict__["_get_sequence_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+49, POINTER(agcom.PVOID))
        self.__dict__["_get_sharpen_filter"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+50, POINTER(agcom.PVOID))
        self.__dict__["_get_video_stream"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+51, POINTER(agcom.PVOID))
        self.__dict__["_get_marker_batch_primitive"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+52, POINTER(agcom.PVOID))
        self.__dict__["_get_marker_batch_primitive_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+53, POINTER(agcom.PVOID))
        self.__dict__["_get_maximum_count_path_primitive_update_policy"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+54, POINTER(agcom.PVOID))
        self.__dict__["_get_model_primitive"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+55, POINTER(agcom.PVOID))
        self.__dict__["_get_path_primitive"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+56, POINTER(agcom.PVOID))
        self.__dict__["_get_pixel_size_display_condition"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+57, POINTER(agcom.PVOID))
        self.__dict__["_get_point_batch_primitive"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+58, POINTER(agcom.PVOID))
        self.__dict__["_get_polyline_primitive"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+59, POINTER(agcom.PVOID))
        self.__dict__["_get_raster_image_globe_overlay"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+60, POINTER(agcom.PVOID))
        self.__dict__["_get_rhumb_line_interpolator"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+61, POINTER(agcom.PVOID))
        self.__dict__["_get_scene_display_condition"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+62, POINTER(agcom.PVOID))
        self.__dict__["_get_scene_manager"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+63, POINTER(agcom.PVOID))
        self.__dict__["_get_screen_overlay"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+64, POINTER(agcom.PVOID))
        self.__dict__["_get_solid_primitive"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+65, POINTER(agcom.PVOID))
        self.__dict__["_get_surface_mesh_primitive"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+66, POINTER(agcom.PVOID))
        self.__dict__["_get_terrain_overlay"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+67, POINTER(agcom.PVOID))
        self.__dict__["_get_text_batch_primitive"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+68, POINTER(agcom.PVOID))
        self.__dict__["_get_text_batch_primitive_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+69, POINTER(agcom.PVOID))
        self.__dict__["_get_texture_matrix"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+70, POINTER(agcom.PVOID))
        self.__dict__["_get_texture_screen_overlay"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+71, POINTER(agcom.PVOID))
        self.__dict__["_get_time_interval_display_condition"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+72, POINTER(agcom.PVOID))
        self.__dict__["_get_triangle_mesh_primitive"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+73, POINTER(agcom.PVOID))
        self.__dict__["_get_triangle_mesh_primitive_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+74, POINTER(agcom.PVOID))
        self.__dict__["_get_texture_filter2_d"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+75, POINTER(agcom.PVOID))
        self.__dict__["_get_bounding_sphere"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+76, POINTER(agcom.PVOID))
        self.__dict__["_get_path_point"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+77, POINTER(agcom.PVOID))
        self.__dict__["_get_text_overlay"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+78, POINTER(agcom.PVOID))
        self.__dict__["_get_agi_custom_terrain_overlay"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+79, POINTER(agcom.PVOID))
        self.__dict__["_get_axes_primitive"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+80, POINTER(agcom.PVOID))
        self.__dict__["_get_vector_primitive"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+81, POINTER(agcom.PVOID))
        self.__dict__["_get_polyline_primitive_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+82, POINTER(agcom.PVOID))
        self.__dict__["_get_point_batch_primitive_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_IFactoryAndInitializers, vtable_offset_local+83, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFactoryAndInitializers.__dict__ and type(IFactoryAndInitializers.__dict__[attrname]) == property:
            return IFactoryAndInitializers.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFactoryAndInitializers.")
    
    @property
    def box_triangulator(self) -> "IBoxTriangulatorInitializer":
        """Access global methods and properties of BoxTriangulator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_box_triangulator"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def cylinder_triangulator(self) -> "ICylinderTriangulatorInitializer":
        """Access global methods and properties of CylinderTriangulator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_cylinder_triangulator"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ellipsoid_triangulator(self) -> "IEllipsoidTriangulatorInitializer":
        """Access global methods and properties of EllipsoidTriangulator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_ellipsoid_triangulator"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def extruded_polyline_triangulator(self) -> "IExtrudedPolylineTriangulatorInitializer":
        """Access global methods and properties of ExtrudedPolylineTriangulator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_extruded_polyline_triangulator"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def surface_extent_triangulator(self) -> "ISurfaceExtentTriangulatorInitializer":
        """Access global methods and properties of SurfaceExtentTriangulator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_surface_extent_triangulator"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def surface_polygon_triangulator(self) -> "ISurfacePolygonTriangulatorInitializer":
        """Access global methods and properties of SurfacePolygonTriangulator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_surface_polygon_triangulator"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def surface_shapes(self) -> "ISurfaceShapesInitializer":
        """Access global methods and properties of SurfaceShapes (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_surface_shapes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def agi_processed_image_globe_overlay(self) -> "IAGIProcessedImageGlobeOverlayFactory":
        """Access global methods and properties of AGIProcessedImageGlobeOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_agi_processed_image_globe_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def agi_processed_terrain_overlay(self) -> "IAGIProcessedTerrainOverlayFactory":
        """Access global methods and properties of AGIProcessedTerrainOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_agi_processed_terrain_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def agi_roam_image_globe_overlay(self) -> "IAGIRoamImageGlobeOverlayFactory":
        """Access global methods and properties of AGIRoamImageGlobeOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_agi_roam_image_globe_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def custom_image_globe_overlay_plugin_activator(self) -> "ICustomImageGlobeOverlayPluginActivatorFactory":
        """Access global methods and properties of CustomImageGlobeOverlayPluginActivator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_image_globe_overlay_plugin_activator"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def geospatial_image_globe_overlay(self) -> "IGeospatialImageGlobeOverlayFactory":
        """Access global methods and properties of GeospatialImageGlobeOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_geospatial_image_globe_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def projected_raster_overlay(self) -> "IProjectedRasterOverlayFactory":
        """Access global methods and properties of ProjectedRasterOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_projected_raster_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def projection(self) -> "IProjectionFactory":
        """Access global methods and properties of Projection (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_projection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def altitude_display_condition(self) -> "IAltitudeDisplayConditionFactory":
        """Access global methods and properties of AltitudeDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_display_condition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def composite_display_condition(self) -> "ICompositeDisplayConditionFactory":
        """Access global methods and properties of CompositeDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_composite_display_condition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def composite_primitive(self) -> "ICompositePrimitiveFactory":
        """Access global methods and properties of CompositePrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_composite_primitive"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def constant_display_condition(self) -> "IConstantDisplayConditionFactory":
        """Access global methods and properties of ConstantDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_constant_display_condition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def distance_display_condition(self) -> "IDistanceDisplayConditionFactory":
        """Access global methods and properties of DistanceDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_distance_display_condition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def distance_to_globe_overlay_display_condition(self) -> "IDistanceToGlobeOverlayDisplayConditionFactory":
        """Access global methods and properties of DistanceToGlobeOverlayDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_distance_to_globe_overlay_display_condition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def distance_to_position_display_condition(self) -> "IDistanceToPositionDisplayConditionFactory":
        """Access global methods and properties of DistanceToPositionDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_distance_to_position_display_condition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def distance_to_primitive_display_condition(self) -> "IDistanceToPrimitiveDisplayConditionFactory":
        """Access global methods and properties of DistanceToPrimitiveDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_distance_to_primitive_display_condition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def duration_path_primitive_update_policy(self) -> "IDurationPathPrimitiveUpdatePolicyFactory":
        """Access global methods and properties of DurationPathPrimitiveUpdatePolicy (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_duration_path_primitive_update_policy"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def globe_image_overlay(self) -> "IGlobeImageOverlayInitializer":
        """Access global methods and properties of GlobeImageOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_globe_image_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def graphics_font(self) -> "IGraphicsFontFactory":
        """Access global methods and properties of GraphicsFont (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_graphics_font"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def great_arc_interpolator(self) -> "IGreatArcInterpolatorFactory":
        """Access global methods and properties of GreatArcInterpolator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_great_arc_interpolator"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def alpha_from_luminance_filter(self) -> "IAlphaFromLuminanceFilterFactory":
        """Access global methods and properties of AlphaFromLuminanceFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_alpha_from_luminance_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def alpha_from_pixel_filter(self) -> "IAlphaFromPixelFilterFactory":
        """Access global methods and properties of AlphaFromPixelFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_alpha_from_pixel_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def alpha_from_raster_filter(self) -> "IAlphaFromRasterFilterFactory":
        """Access global methods and properties of AlphaFromRasterFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_alpha_from_raster_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def band_extract_filter(self) -> "IBandExtractFilterFactory":
        """Access global methods and properties of BandExtractFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_band_extract_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def band_order_filter(self) -> "IBandOrderFilterFactory":
        """Access global methods and properties of BandOrderFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_band_order_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def blur_filter(self) -> "IBlurFilterFactory":
        """Access global methods and properties of BlurFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_blur_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def brightness_filter(self) -> "IBrightnessFilterFactory":
        """Access global methods and properties of BrightnessFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_brightness_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def color_to_luminance_filter(self) -> "IColorToLuminanceFilterFactory":
        """Access global methods and properties of ColorToLuminanceFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_color_to_luminance_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def contrast_filter(self) -> "IContrastFilterFactory":
        """Access global methods and properties of ContrastFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_contrast_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def convolution_filter(self) -> "IConvolutionFilterFactory":
        """Access global methods and properties of ConvolutionFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_convolution_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def edge_detect_filter(self) -> "IEdgeDetectFilterFactory":
        """Access global methods and properties of EdgeDetectFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_edge_detect_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def filtering_raster_stream(self) -> "IFilteringRasterStreamFactory":
        """Access global methods and properties of FilteringRasterStream (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_filtering_raster_stream"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def flip_filter(self) -> "IFlipFilterFactory":
        """Access global methods and properties of FlipFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_flip_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def gamma_correction_filter(self) -> "IGammaCorrectionFilterFactory":
        """Access global methods and properties of GammaCorrectionFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_gamma_correction_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def gaussian_blur_filter(self) -> "IGaussianBlurFilterFactory":
        """Access global methods and properties of GaussianBlurFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_gaussian_blur_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def gradient_detect_filter(self) -> "IGradientDetectFilterFactory":
        """Access global methods and properties of GradientDetectFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_gradient_detect_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def jpeg2000_writer(self) -> "IJpeg2000WriterInitializer":
        """Access global methods and properties of Jpeg2000Writer (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_jpeg2000_writer"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def levels_filter(self) -> "ILevelsFilterFactory":
        """Access global methods and properties of LevelsFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_levels_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def projection_raster_stream_plugin_activator(self) -> "IProjectionRasterStreamPluginActivatorFactory":
        """Access global methods and properties of ProjectionRasterStreamPluginActivator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_projection_raster_stream_plugin_activator"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def raster(self) -> "IRasterFactory":
        """Access global methods and properties of Raster (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_raster"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def raster_attributes(self) -> "IRasterAttributesFactory":
        """Access global methods and properties of RasterAttributes (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_raster_attributes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def rotate_filter(self) -> "IRotateFilterFactory":
        """Access global methods and properties of RotateFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_rotate_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def sequence_filter(self) -> "ISequenceFilterFactory":
        """Access global methods and properties of SequenceFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_sequence_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def sharpen_filter(self) -> "ISharpenFilterFactory":
        """Access global methods and properties of SharpenFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_sharpen_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def video_stream(self) -> "IVideoStreamFactory":
        """Access global methods and properties of VideoStream (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_video_stream"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def marker_batch_primitive(self) -> "IMarkerBatchPrimitiveFactory":
        """Access global methods and properties of MarkerBatchPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_marker_batch_primitive"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def marker_batch_primitive_optional_parameters(self) -> "IMarkerBatchPrimitiveOptionalParametersFactory":
        """Access global methods and properties of MarkerBatchPrimitiveOptionalParameters (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_marker_batch_primitive_optional_parameters"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def maximum_count_path_primitive_update_policy(self) -> "IMaximumCountPathPrimitiveUpdatePolicyFactory":
        """Access global methods and properties of MaximumCountPathPrimitiveUpdatePolicy (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_count_path_primitive_update_policy"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def model_primitive(self) -> "IModelPrimitiveFactory":
        """Access global methods and properties of ModelPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_model_primitive"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def path_primitive(self) -> "IPathPrimitiveFactory":
        """Access global methods and properties of PathPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_path_primitive"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def pixel_size_display_condition(self) -> "IPixelSizeDisplayConditionFactory":
        """Access global methods and properties of PixelSizeDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_pixel_size_display_condition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def point_batch_primitive(self) -> "IPointBatchPrimitiveFactory":
        """Access global methods and properties of PointBatchPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_point_batch_primitive"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def polyline_primitive(self) -> "IPolylinePrimitiveFactory":
        """Access global methods and properties of PolylinePrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_polyline_primitive"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def raster_image_globe_overlay(self) -> "IRasterImageGlobeOverlayFactory":
        """Access global methods and properties of RasterImageGlobeOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_raster_image_globe_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def rhumb_line_interpolator(self) -> "IRhumbLineInterpolatorFactory":
        """Access global methods and properties of RhumbLineInterpolator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_rhumb_line_interpolator"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def scene_display_condition(self) -> "ISceneDisplayConditionFactory":
        """Access global methods and properties of SceneDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scene_display_condition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def scene_manager(self) -> "ISceneManagerInitializer":
        """Access global methods and properties of SceneManager (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scene_manager"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def screen_overlay(self) -> "IScreenOverlayFactory":
        """Access global methods and properties of ScreenOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_screen_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def solid_primitive(self) -> "ISolidPrimitiveFactory":
        """Access global methods and properties of SolidPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_solid_primitive"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def surface_mesh_primitive(self) -> "ISurfaceMeshPrimitiveFactory":
        """Access global methods and properties of SurfaceMeshPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_surface_mesh_primitive"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def terrain_overlay(self) -> "ITerrainOverlayInitializer":
        """Access global methods and properties of TerrainOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_terrain_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def text_batch_primitive(self) -> "ITextBatchPrimitiveFactory":
        """Access global methods and properties of TextBatchPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_text_batch_primitive"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def text_batch_primitive_optional_parameters(self) -> "ITextBatchPrimitiveOptionalParametersFactory":
        """Access global methods and properties of TextBatchPrimitiveOptionalParameters (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_text_batch_primitive_optional_parameters"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def texture_matrix(self) -> "ITextureMatrixFactory":
        """Access global methods and properties of TextureMatrix (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_texture_matrix"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def texture_screen_overlay(self) -> "ITextureScreenOverlayFactory":
        """Access global methods and properties of TextureScreenOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_texture_screen_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def time_interval_display_condition(self) -> "ITimeIntervalDisplayConditionFactory":
        """Access global methods and properties of TimeIntervalDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_time_interval_display_condition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def triangle_mesh_primitive(self) -> "ITriangleMeshPrimitiveFactory":
        """Access global methods and properties of TriangleMeshPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_triangle_mesh_primitive"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def triangle_mesh_primitive_optional_parameters(self) -> "ITriangleMeshPrimitiveOptionalParametersFactory":
        """Access global methods and properties of TriangleMeshPrimitiveOptionalParameters (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_triangle_mesh_primitive_optional_parameters"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def texture_filter2_d(self) -> "ITextureFilter2DFactory":
        """Factory creates texture filters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_texture_filter2_d"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def bounding_sphere(self) -> "IBoundingSphereFactory":
        """Factory creates bounding spheres."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_bounding_sphere"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def path_point(self) -> "IPathPointFactory":
        """Factory creates path points."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_path_point"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def text_overlay(self) -> "ITextOverlayFactory":
        """Access global methods and properties of TextOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_text_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def agi_custom_terrain_overlay(self) -> "IAGICustomTerrainOverlayFactory":
        """Access global methods and properties of AGICustomTerrainOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_agi_custom_terrain_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def axes_primitive(self) -> "IAxesPrimitiveFactory":
        """Access global methods and properties of AxesPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_axes_primitive"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def vector_primitive(self) -> "IVectorPrimitiveFactory":
        """Access global methods and properties of VectorPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_vector_primitive"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def polyline_primitive_optional_parameters(self) -> "IPolylinePrimitiveOptionalParametersFactory":
        """Access global methods and properties of PolylinePrimitiveOptionalParameters (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_polyline_primitive_optional_parameters"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def point_batch_primitive_optional_parameters(self) -> "IPointBatchPrimitiveOptionalParametersFactory":
        """Access global methods and properties of PointBatchPrimitiveOptionalParameters (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_point_batch_primitive_optional_parameters"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5ccf1ef3-48a0-4b22-9fcf-c32eae3f8d69}", IFactoryAndInitializers)
agcls.AgTypeNameMap["IFactoryAndInitializers"] = IFactoryAndInitializers

class IExtrudedPolylineTriangulatorResult(object):
    """The result from extruded polyline triangulation: a triangle mesh defined using an indexed triangle list with top and bottom boundary positions. The mesh is commonly visualized with the triangle mesh primitive or surface mesh primitive..."""
    _uuid = "{5d94d077-0a56-4d83-ac90-369344533684}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_top_boundary_positions"] = _raise_uninitialized_error
        self.__dict__["_get_bottom_boundary_positions"] = _raise_uninitialized_error
        self.__dict__["_get_boundary_positions_winding_order"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IExtrudedPolylineTriangulatorResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IExtrudedPolylineTriangulatorResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IExtrudedPolylineTriangulatorResult = agcom.GUID(IExtrudedPolylineTriangulatorResult._uuid)
        vtable_offset_local = IExtrudedPolylineTriangulatorResult._vtable_offset - 1
        self.__dict__["_get_top_boundary_positions"] = IAGFUNCTYPE(pUnk, IID_IExtrudedPolylineTriangulatorResult, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_bottom_boundary_positions"] = IAGFUNCTYPE(pUnk, IID_IExtrudedPolylineTriangulatorResult, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_boundary_positions_winding_order"] = IAGFUNCTYPE(pUnk, IID_IExtrudedPolylineTriangulatorResult, vtable_offset_local+3, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IExtrudedPolylineTriangulatorResult.__dict__ and type(IExtrudedPolylineTriangulatorResult.__dict__[attrname]) == property:
            return IExtrudedPolylineTriangulatorResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IExtrudedPolylineTriangulatorResult.")
    
    @property
    def top_boundary_positions(self) -> list:
        """Gets the boundary positions along the top of the extrusion. Three array elements (in the order x, y, z) constitute one position."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_top_boundary_positions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def bottom_boundary_positions(self) -> list:
        """Gets the boundary positions along the bottom of the extrusion. Three array elements (in the order x, y, z) constitute one position."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_bottom_boundary_positions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def boundary_positions_winding_order(self) -> "AgEStkGraphicsWindingOrder":
        """Gets the winding order of top boundary positions and bottom boundary positions."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_boundary_positions_winding_order"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5d94d077-0a56-4d83-ac90-369344533684}", IExtrudedPolylineTriangulatorResult)
agcls.AgTypeNameMap["IExtrudedPolylineTriangulatorResult"] = IExtrudedPolylineTriangulatorResult

class ISolidTriangulatorResult(object):
    """The result from a triangulation of a solid: a triangle mesh defined using an indexed triangle list and positions outlining the solid. It is recommended to visualize the solid using a solid primitive..."""
    _uuid = "{a7ba0673-f944-4dc6-a450-5cb62915cb7b}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_outline_indices"] = _raise_uninitialized_error
        self.__dict__["_get_outline_positions"] = _raise_uninitialized_error
        self.__dict__["_get_outline_polyline_type"] = _raise_uninitialized_error
        self.__dict__["_get_closed"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISolidTriangulatorResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISolidTriangulatorResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISolidTriangulatorResult = agcom.GUID(ISolidTriangulatorResult._uuid)
        vtable_offset_local = ISolidTriangulatorResult._vtable_offset - 1
        self.__dict__["_get_outline_indices"] = IAGFUNCTYPE(pUnk, IID_ISolidTriangulatorResult, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_outline_positions"] = IAGFUNCTYPE(pUnk, IID_ISolidTriangulatorResult, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_outline_polyline_type"] = IAGFUNCTYPE(pUnk, IID_ISolidTriangulatorResult, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_closed"] = IAGFUNCTYPE(pUnk, IID_ISolidTriangulatorResult, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISolidTriangulatorResult.__dict__ and type(ISolidTriangulatorResult.__dict__[attrname]) == property:
            return ISolidTriangulatorResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISolidTriangulatorResult.")
    
    @property
    def outline_indices(self) -> list:
        """Gets indices into positions that define the positions outlining the solid. The indices returned consider the three components of a position (x, y, and z) as a single array element..."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_indices"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def outline_positions(self) -> list:
        """Gets the positions outlining the solid. Three array elements (in the order x, y, z) constitute one position."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_positions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def outline_polyline_type(self) -> "AgEStkGraphicsPolylineType":
        """Gets the polyline type of outline indices and outline positions."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsPolylineType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_polyline_type"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def closed(self) -> bool:
        """Gets whether the solid is closed. For example, a box with six faces is closed. If one face is removed, the box is open."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_closed"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{a7ba0673-f944-4dc6-a450-5cb62915cb7b}", ISolidTriangulatorResult)
agcls.AgTypeNameMap["ISolidTriangulatorResult"] = ISolidTriangulatorResult

class ISurfaceShapesResult(object):
    """Represents the boundary positions of a shape on the surface computed from by a surface shapes method."""
    _uuid = "{0efd15db-d9f7-4e1f-925b-ade0b0a22a21}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_positions"] = _raise_uninitialized_error
        self.__dict__["_get_positions_winding_order"] = _raise_uninitialized_error
        self.__dict__["_get_polyline_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISurfaceShapesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISurfaceShapesResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISurfaceShapesResult = agcom.GUID(ISurfaceShapesResult._uuid)
        vtable_offset_local = ISurfaceShapesResult._vtable_offset - 1
        self.__dict__["_get_positions"] = IAGFUNCTYPE(pUnk, IID_ISurfaceShapesResult, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_positions_winding_order"] = IAGFUNCTYPE(pUnk, IID_ISurfaceShapesResult, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_get_polyline_type"] = IAGFUNCTYPE(pUnk, IID_ISurfaceShapesResult, vtable_offset_local+3, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISurfaceShapesResult.__dict__ and type(ISurfaceShapesResult.__dict__[attrname]) == property:
            return ISurfaceShapesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISurfaceShapesResult.")
    
    @property
    def positions(self) -> list:
        """Gets the positions of the computed shape. Three array elements (in the order x, y, z) constitute one position."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_positions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def positions_winding_order(self) -> "AgEStkGraphicsWindingOrder":
        """Gets the winding order of positions."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_positions_winding_order"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def polyline_type(self) -> "AgEStkGraphicsPolylineType":
        """Gets the polyline type of positions."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsPolylineType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_polyline_type"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{0efd15db-d9f7-4e1f-925b-ade0b0a22a21}", ISurfaceShapesResult)
agcls.AgTypeNameMap["ISurfaceShapesResult"] = ISurfaceShapesResult

class ISurfaceTriangulatorResult(object):
    """The result from a triangulation on the surface of a central body: a triangle mesh defined using an indexed triangle list and boundary positions surrounding the mesh..."""
    _uuid = "{27cedd3e-86cd-4d18-862f-eeb0e6de62aa}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_granularity"] = _raise_uninitialized_error
        self.__dict__["_get_boundary_indices"] = _raise_uninitialized_error
        self.__dict__["_get_boundary_positions"] = _raise_uninitialized_error
        self.__dict__["_get_boundary_positions_winding_order"] = _raise_uninitialized_error
        self.__dict__["_get_boundary_polyline_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISurfaceTriangulatorResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISurfaceTriangulatorResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISurfaceTriangulatorResult = agcom.GUID(ISurfaceTriangulatorResult._uuid)
        vtable_offset_local = ISurfaceTriangulatorResult._vtable_offset - 1
        self.__dict__["_get_granularity"] = IAGFUNCTYPE(pUnk, IID_ISurfaceTriangulatorResult, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_get_boundary_indices"] = IAGFUNCTYPE(pUnk, IID_ISurfaceTriangulatorResult, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_boundary_positions"] = IAGFUNCTYPE(pUnk, IID_ISurfaceTriangulatorResult, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_boundary_positions_winding_order"] = IAGFUNCTYPE(pUnk, IID_ISurfaceTriangulatorResult, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_get_boundary_polyline_type"] = IAGFUNCTYPE(pUnk, IID_ISurfaceTriangulatorResult, vtable_offset_local+5, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISurfaceTriangulatorResult.__dict__ and type(ISurfaceTriangulatorResult.__dict__[attrname]) == property:
            return ISurfaceTriangulatorResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISurfaceTriangulatorResult.")
    
    @property
    def granularity(self) -> float:
        """Gets the granularity used when the triangulation was computed. Lower granularities are more precise but create more triangles."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_granularity"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def boundary_indices(self) -> list:
        """Gets indices into positions that define the boundary positions that surround the mesh. The indices returned consider the three components of a position (x, y, and z) as a single array element..."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_boundary_indices"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def boundary_positions(self) -> list:
        """Gets the boundary positions that surround the mesh. Three array elements (in the order x, y, z) constitute one position."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_boundary_positions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def boundary_positions_winding_order(self) -> "AgEStkGraphicsWindingOrder":
        """Gets the winding order of boundary positions."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_boundary_positions_winding_order"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def boundary_polyline_type(self) -> "AgEStkGraphicsPolylineType":
        """Gets the polyline type of boundary positions."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsPolylineType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_boundary_polyline_type"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{27cedd3e-86cd-4d18-862f-eeb0e6de62aa}", ISurfaceTriangulatorResult)
agcls.AgTypeNameMap["ISurfaceTriangulatorResult"] = ISurfaceTriangulatorResult

class ITriangulatorResult(object):
    """The result from triangulation: a triangle mesh defined using an indexed triangle list. This is commonly visualized with the triangle mesh primitive or surface mesh primitive."""
    _uuid = "{9dece859-d370-4674-8ffa-8caa98e60632}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_positions"] = _raise_uninitialized_error
        self.__dict__["_get_normals"] = _raise_uninitialized_error
        self.__dict__["_get_indices"] = _raise_uninitialized_error
        self.__dict__["_get_triangle_winding_order"] = _raise_uninitialized_error
        self.__dict__["_get_bounding_sphere"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITriangulatorResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITriangulatorResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITriangulatorResult = agcom.GUID(ITriangulatorResult._uuid)
        vtable_offset_local = ITriangulatorResult._vtable_offset - 1
        self.__dict__["_get_positions"] = IAGFUNCTYPE(pUnk, IID_ITriangulatorResult, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_normals"] = IAGFUNCTYPE(pUnk, IID_ITriangulatorResult, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_indices"] = IAGFUNCTYPE(pUnk, IID_ITriangulatorResult, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_triangle_winding_order"] = IAGFUNCTYPE(pUnk, IID_ITriangulatorResult, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_get_bounding_sphere"] = IAGFUNCTYPE(pUnk, IID_ITriangulatorResult, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITriangulatorResult.__dict__ and type(ITriangulatorResult.__dict__[attrname]) == property:
            return ITriangulatorResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITriangulatorResult.")
    
    @property
    def positions(self) -> list:
        """Gets the positions of the mesh. Three array elements (in the order x, y, z) constitute one position."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_positions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def normals(self) -> list:
        """Gets the normals of the mesh. Every position in positions has corresponding normal. Normals are commonly used for lighting. Three array elements (in the order x, y, z) constitute one normal."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_normals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def indices(self) -> list:
        """Gets indices into positions and normals. Every 3 indices represent 1 triangle. The indices returned consider the three components of a position or normal (x, y, and z) as a single array element..."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_indices"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def triangle_winding_order(self) -> "AgEStkGraphicsWindingOrder":
        """Gets the orientation of front-facing triangles in the mesh."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_triangle_winding_order"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def bounding_sphere(self) -> "IBoundingSphere":
        """Gets the bounding sphere that encompasses the mesh."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_bounding_sphere"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{9dece859-d370-4674-8ffa-8caa98e60632}", ITriangulatorResult)
agcls.AgTypeNameMap["ITriangulatorResult"] = ITriangulatorResult

class IAGICustomTerrainOverlay(object):
    """A terrain overlay for handling AGI Cesium Terrain."""
    _uuid = "{59ef8436-aeec-4e60-8e3d-920e0f11feba}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAGICustomTerrainOverlay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAGICustomTerrainOverlay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAGICustomTerrainOverlay = agcom.GUID(IAGICustomTerrainOverlay._uuid)
        vtable_offset_local = IAGICustomTerrainOverlay._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAGICustomTerrainOverlay.__dict__ and type(IAGICustomTerrainOverlay.__dict__[attrname]) == property:
            return IAGICustomTerrainOverlay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAGICustomTerrainOverlay.")
    

agcls.AgClassCatalog.add_catalog_entry("{59ef8436-aeec-4e60-8e3d-920e0f11feba}", IAGICustomTerrainOverlay)
agcls.AgTypeNameMap["IAGICustomTerrainOverlay"] = IAGICustomTerrainOverlay

class IAGIProcessedImageGlobeOverlay(object):
    """A globe image overlay for handling AGI Processed Image (PDTTX) files."""
    _uuid = "{5c2d7cca-54f6-4b27-93d6-58bddac0befe}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAGIProcessedImageGlobeOverlay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAGIProcessedImageGlobeOverlay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAGIProcessedImageGlobeOverlay = agcom.GUID(IAGIProcessedImageGlobeOverlay._uuid)
        vtable_offset_local = IAGIProcessedImageGlobeOverlay._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAGIProcessedImageGlobeOverlay.__dict__ and type(IAGIProcessedImageGlobeOverlay.__dict__[attrname]) == property:
            return IAGIProcessedImageGlobeOverlay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAGIProcessedImageGlobeOverlay.")
    

agcls.AgClassCatalog.add_catalog_entry("{5c2d7cca-54f6-4b27-93d6-58bddac0befe}", IAGIProcessedImageGlobeOverlay)
agcls.AgTypeNameMap["IAGIProcessedImageGlobeOverlay"] = IAGIProcessedImageGlobeOverlay

class IAGIProcessedTerrainOverlay(object):
    """A terrain overlay for handling AGI Processed Terrain (PDTT) files."""
    _uuid = "{093a5b12-abdd-4029-adc5-2cbab7e4216d}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAGIProcessedTerrainOverlay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAGIProcessedTerrainOverlay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAGIProcessedTerrainOverlay = agcom.GUID(IAGIProcessedTerrainOverlay._uuid)
        vtable_offset_local = IAGIProcessedTerrainOverlay._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAGIProcessedTerrainOverlay.__dict__ and type(IAGIProcessedTerrainOverlay.__dict__[attrname]) == property:
            return IAGIProcessedTerrainOverlay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAGIProcessedTerrainOverlay.")
    

agcls.AgClassCatalog.add_catalog_entry("{093a5b12-abdd-4029-adc5-2cbab7e4216d}", IAGIProcessedTerrainOverlay)
agcls.AgTypeNameMap["IAGIProcessedTerrainOverlay"] = IAGIProcessedTerrainOverlay

class IAGIRoamImageGlobeOverlay(object):
    """A globe image overlay for handling ROAM (TXM/TXB) files."""
    _uuid = "{d76d82b7-7a13-452d-b661-1d416fae732e}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAGIRoamImageGlobeOverlay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAGIRoamImageGlobeOverlay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAGIRoamImageGlobeOverlay = agcom.GUID(IAGIRoamImageGlobeOverlay._uuid)
        vtable_offset_local = IAGIRoamImageGlobeOverlay._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAGIRoamImageGlobeOverlay.__dict__ and type(IAGIRoamImageGlobeOverlay.__dict__[attrname]) == property:
            return IAGIRoamImageGlobeOverlay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAGIRoamImageGlobeOverlay.")
    

agcls.AgClassCatalog.add_catalog_entry("{d76d82b7-7a13-452d-b661-1d416fae732e}", IAGIRoamImageGlobeOverlay)
agcls.AgTypeNameMap["IAGIRoamImageGlobeOverlay"] = IAGIRoamImageGlobeOverlay

class ICameraSnapshot(object):
    """Takes snapshots of the 3D window."""
    _uuid = "{6b6a8d90-ff4d-49b2-9fb4-5bf459818cd1}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_save_to_file"] = _raise_uninitialized_error
        self.__dict__["_save_to_file_with_width_and_dpi"] = _raise_uninitialized_error
        self.__dict__["_save_to_clipboard"] = _raise_uninitialized_error
        self.__dict__["_save_to_raster"] = _raise_uninitialized_error
        self.__dict__["_save_to_texture"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICameraSnapshot._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICameraSnapshot from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICameraSnapshot = agcom.GUID(ICameraSnapshot._uuid)
        vtable_offset_local = ICameraSnapshot._vtable_offset - 1
        self.__dict__["_save_to_file"] = IAGFUNCTYPE(pUnk, IID_ICameraSnapshot, vtable_offset_local+1, agcom.BSTR, agcom.LONG)
        self.__dict__["_save_to_file_with_width_and_dpi"] = IAGFUNCTYPE(pUnk, IID_ICameraSnapshot, vtable_offset_local+2, agcom.BSTR, agcom.LONG, agcom.DOUBLE, agcom.DOUBLE)
        self.__dict__["_save_to_clipboard"] = IAGFUNCTYPE(pUnk, IID_ICameraSnapshot, vtable_offset_local+3, )
        self.__dict__["_save_to_raster"] = IAGFUNCTYPE(pUnk, IID_ICameraSnapshot, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_save_to_texture"] = IAGFUNCTYPE(pUnk, IID_ICameraSnapshot, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICameraSnapshot.__dict__ and type(ICameraSnapshot.__dict__[attrname]) == property:
            return ICameraSnapshot.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICameraSnapshot.")
    
    def save_to_file(self, filename:str, cameraSnapshotFormat:"AgEStkGraphicsCameraSnapshotFileFormat") -> None:
        """Saves a snapshot of the 3D window to the filename with the specified format."""
        with agmarshall.BSTR_arg(filename) as arg_filename, \
             agmarshall.AgEnum_arg(AgEStkGraphicsCameraSnapshotFileFormat, cameraSnapshotFormat) as arg_cameraSnapshotFormat:
            agcls.evaluate_hresult(self.__dict__["_save_to_file"](arg_filename.COM_val, arg_cameraSnapshotFormat.COM_val))

    def save_to_file_with_width_and_dpi(self, filename:str, cameraSnapshotFormat:"AgEStkGraphicsCameraSnapshotFileFormat", widthInInches:float, dotsPerInch:float) -> None:
        """Saves a snapshot of the 3D window to the filename with the specified format at high resolution..."""
        with agmarshall.BSTR_arg(filename) as arg_filename, \
             agmarshall.AgEnum_arg(AgEStkGraphicsCameraSnapshotFileFormat, cameraSnapshotFormat) as arg_cameraSnapshotFormat, \
             agmarshall.DOUBLE_arg(widthInInches) as arg_widthInInches, \
             agmarshall.DOUBLE_arg(dotsPerInch) as arg_dotsPerInch:
            agcls.evaluate_hresult(self.__dict__["_save_to_file_with_width_and_dpi"](arg_filename.COM_val, arg_cameraSnapshotFormat.COM_val, arg_widthInInches.COM_val, arg_dotsPerInch.COM_val))

    def save_to_clipboard(self) -> None:
        """Saves a single frame of the 3D window to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_save_to_clipboard"]())

    def save_to_raster(self) -> "IRaster":
        """Saves a snapshot of the 3D window to a raster."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_save_to_raster"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def save_to_texture(self) -> "IRendererTexture2D":
        """Saves a snapshot of the 3D window to a texture 2d."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_save_to_texture"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6b6a8d90-ff4d-49b2-9fb4-5bf459818cd1}", ICameraSnapshot)
agcls.AgTypeNameMap["ICameraSnapshot"] = ICameraSnapshot

class ICameraVideoRecording(object):
    """Records the 3D window to either a movie file or to consecutively ordered image files each time the scene is rendered."""
    _uuid = "{f519ee7a-e452-451a-839d-0eda6cf69c0a}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_is_recording"] = _raise_uninitialized_error
        self.__dict__["_start_recording"] = _raise_uninitialized_error
        self.__dict__["_start_recording_frame_stack"] = _raise_uninitialized_error
        self.__dict__["_stop_recording"] = _raise_uninitialized_error
        self.__dict__["_start_recording_video"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICameraVideoRecording._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICameraVideoRecording from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICameraVideoRecording = agcom.GUID(ICameraVideoRecording._uuid)
        vtable_offset_local = ICameraVideoRecording._vtable_offset - 1
        self.__dict__["_get_is_recording"] = IAGFUNCTYPE(pUnk, IID_ICameraVideoRecording, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_start_recording"] = IAGFUNCTYPE(pUnk, IID_ICameraVideoRecording, vtable_offset_local+2, agcom.BSTR, agcom.INT, agcom.INT)
        self.__dict__["_start_recording_frame_stack"] = IAGFUNCTYPE(pUnk, IID_ICameraVideoRecording, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, agcom.LONG, agcom.INT, agcom.INT)
        self.__dict__["_stop_recording"] = IAGFUNCTYPE(pUnk, IID_ICameraVideoRecording, vtable_offset_local+4, )
        self.__dict__["_start_recording_video"] = IAGFUNCTYPE(pUnk, IID_ICameraVideoRecording, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, agcom.LONG, agcom.INT, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICameraVideoRecording.__dict__ and type(ICameraVideoRecording.__dict__[attrname]) == property:
            return ICameraVideoRecording.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICameraVideoRecording.")
    
    @property
    def is_recording(self) -> bool:
        """Gets if recording is occurring or not."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_recording"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def start_recording(self, wmvFilename:str, videoBitRate:int, videoFrameRate:int) -> None:
        """This method is deprecated. Use StartRecordingVideo instead. Starts recording a file in the WMV format at the specified bit and frame rate."""
        with agmarshall.BSTR_arg(wmvFilename) as arg_wmvFilename, \
             agmarshall.INT_arg(videoBitRate) as arg_videoBitRate, \
             agmarshall.INT_arg(videoFrameRate) as arg_videoFrameRate:
            agcls.evaluate_hresult(self.__dict__["_start_recording"](arg_wmvFilename.COM_val, arg_videoBitRate.COM_val, arg_videoFrameRate.COM_val))

    def start_recording_frame_stack(self, fileDirectory:str, filePrefix:str, cameraSnapshotFileFormat:"AgEStkGraphicsCameraSnapshotFileFormat", startingFrameNumber:int, numberOfFrameDigits:int) -> None:
        """Starts recording a frame stack. Each frame is saved as a separate image file. The filename of each frame is defined by a prefix followed by a frame number."""
        with agmarshall.BSTR_arg(fileDirectory) as arg_fileDirectory, \
             agmarshall.BSTR_arg(filePrefix) as arg_filePrefix, \
             agmarshall.AgEnum_arg(AgEStkGraphicsCameraSnapshotFileFormat, cameraSnapshotFileFormat) as arg_cameraSnapshotFileFormat, \
             agmarshall.INT_arg(startingFrameNumber) as arg_startingFrameNumber, \
             agmarshall.INT_arg(numberOfFrameDigits) as arg_numberOfFrameDigits:
            agcls.evaluate_hresult(self.__dict__["_start_recording_frame_stack"](arg_fileDirectory.COM_val, arg_filePrefix.COM_val, arg_cameraSnapshotFileFormat.COM_val, arg_startingFrameNumber.COM_val, arg_numberOfFrameDigits.COM_val))

    def stop_recording(self) -> None:
        """Stops recording."""
        agcls.evaluate_hresult(self.__dict__["_stop_recording"]())

    def start_recording_video(self, fileDirectory:str, filePrefix:str, videoFormat:"AgEStkGraphicsCameraVideoFormat", videoBitRate:int, videoFrameRate:int) -> None:
        """Starts recording a video file at the specified bit and frame rate."""
        with agmarshall.BSTR_arg(fileDirectory) as arg_fileDirectory, \
             agmarshall.BSTR_arg(filePrefix) as arg_filePrefix, \
             agmarshall.AgEnum_arg(AgEStkGraphicsCameraVideoFormat, videoFormat) as arg_videoFormat, \
             agmarshall.INT_arg(videoBitRate) as arg_videoBitRate, \
             agmarshall.INT_arg(videoFrameRate) as arg_videoFrameRate:
            agcls.evaluate_hresult(self.__dict__["_start_recording_video"](arg_fileDirectory.COM_val, arg_filePrefix.COM_val, arg_videoFormat.COM_val, arg_videoBitRate.COM_val, arg_videoFrameRate.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{f519ee7a-e452-451a-839d-0eda6cf69c0a}", ICameraVideoRecording)
agcls.AgTypeNameMap["ICameraVideoRecording"] = ICameraVideoRecording

class ICentralBodyGraphicsIndexer(object):
    """An indexer into the central body graphics for a particular central body, which provides graphical properties such as showing or hiding the central body in the scene, and working with terrain and imagery for the specified central body."""
    _uuid = "{fc4eafc1-217c-4a1b-9640-4a678d84813a}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_earth"] = _raise_uninitialized_error
        self.__dict__["_get_moon"] = _raise_uninitialized_error
        self.__dict__["_get_sun"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyGraphicsIndexer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyGraphicsIndexer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICentralBodyGraphicsIndexer = agcom.GUID(ICentralBodyGraphicsIndexer._uuid)
        vtable_offset_local = ICentralBodyGraphicsIndexer._vtable_offset - 1
        self.__dict__["_get_earth"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphicsIndexer, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_moon"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphicsIndexer, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_sun"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphicsIndexer, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphicsIndexer, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_by_name"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphicsIndexer, vtable_offset_local+5, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyGraphicsIndexer.__dict__ and type(ICentralBodyGraphicsIndexer.__dict__[attrname]) == property:
            return ICentralBodyGraphicsIndexer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICentralBodyGraphicsIndexer.")
    
    @property
    def earth(self) -> "ICentralBodyGraphics":
        """Gets the central body graphics for the planet Earth. This is equivalent to passing a central body equal to an instance of earth central body to the indexer."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_earth"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def moon(self) -> "ICentralBodyGraphics":
        """Gets the central body graphics for the Moon."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_moon"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def sun(self) -> "ICentralBodyGraphics":
        """Gets the central body graphics for the Sun."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def item(self, centralBody:str) -> "ICentralBodyGraphics":
        """Gets the central body graphics for the specified central body."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_centralBody.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_by_name(self, name:str) -> "ICentralBodyGraphics":
        """Returns the central body graphics for the central body with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_by_name"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{fc4eafc1-217c-4a1b-9640-4a678d84813a}", ICentralBodyGraphicsIndexer)
agcls.AgTypeNameMap["ICentralBodyGraphicsIndexer"] = ICentralBodyGraphicsIndexer

class ICustomImageGlobeOverlay(object):
    """A globe image overlay that allows for a user defined image to be specified."""
    _uuid = "{f8086ed2-4b18-4d6d-a39f-1ab5801cf886}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_is_translucent"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_meters_per_pixel"] = _raise_uninitialized_error
        self.__dict__["_get_projection"] = _raise_uninitialized_error
        self.__dict__["_start_up"] = _raise_uninitialized_error
        self.__dict__["_shut_down"] = _raise_uninitialized_error
        self.__dict__["_clear_cache"] = _raise_uninitialized_error
        self.__dict__["_reload"] = _raise_uninitialized_error
        self.__dict__["_read"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICustomImageGlobeOverlay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICustomImageGlobeOverlay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICustomImageGlobeOverlay = agcom.GUID(ICustomImageGlobeOverlay._uuid)
        vtable_offset_local = ICustomImageGlobeOverlay._vtable_offset - 1
        self.__dict__["_get_is_translucent"] = IAGFUNCTYPE(pUnk, IID_ICustomImageGlobeOverlay, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_maximum_meters_per_pixel"] = IAGFUNCTYPE(pUnk, IID_ICustomImageGlobeOverlay, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_get_projection"] = IAGFUNCTYPE(pUnk, IID_ICustomImageGlobeOverlay, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_start_up"] = IAGFUNCTYPE(pUnk, IID_ICustomImageGlobeOverlay, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_shut_down"] = IAGFUNCTYPE(pUnk, IID_ICustomImageGlobeOverlay, vtable_offset_local+5, agcom.PVOID)
        self.__dict__["_clear_cache"] = IAGFUNCTYPE(pUnk, IID_ICustomImageGlobeOverlay, vtable_offset_local+6, )
        self.__dict__["_reload"] = IAGFUNCTYPE(pUnk, IID_ICustomImageGlobeOverlay, vtable_offset_local+7, )
        self.__dict__["_read"] = IAGFUNCTYPE(pUnk, IID_ICustomImageGlobeOverlay, vtable_offset_local+8, POINTER(agcom.SAFEARRAY), agcom.VARIANT, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICustomImageGlobeOverlay.__dict__ and type(ICustomImageGlobeOverlay.__dict__[attrname]) == property:
            return ICustomImageGlobeOverlay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICustomImageGlobeOverlay.")
    
    @property
    def is_translucent(self) -> bool:
        """Gets whether the overlay contains translucent imagery."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_translucent"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def maximum_meters_per_pixel(self) -> float:
        """Gets the maximum resolution of the inlay in meters per pixel."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_meters_per_pixel"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def projection(self) -> "AgEStkGraphicsMapProjection":
        """Gets the map projection. Valid values are mercator and equidistant cylindrical."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMapProjection) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_projection"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def start_up(self, scene:"IScene") -> None:
        """Called automatically when imagery is being added to the globe."""
        with agmarshall.AgInterface_in_arg(scene, IScene) as arg_scene:
            agcls.evaluate_hresult(self.__dict__["_start_up"](arg_scene.COM_val))

    def shut_down(self, scene:"IScene") -> None:
        """Called automatically when imagery is being removed from the globe."""
        with agmarshall.AgInterface_in_arg(scene, IScene) as arg_scene:
            agcls.evaluate_hresult(self.__dict__["_shut_down"](arg_scene.COM_val))

    def clear_cache(self) -> None:
        """Clears the image data cache associated with this instance. This is equivalent to deleting and re-adding the overlay."""
        agcls.evaluate_hresult(self.__dict__["_clear_cache"]())

    def reload(self) -> None:
        """Reloads the image data associated with this instance. Preserves the current image data until new image data replaces it."""
        agcls.evaluate_hresult(self.__dict__["_reload"]())

    def read(self, extent:list, userTileData:typing.Any, image:"IPictureDisp") -> bool:
        """Reads a tile from the specified extent, scales it to and stores the result in image."""
        with agmarshall.SAFEARRAY_arg(extent) as arg_extent, \
             agmarshall.VARIANT_arg(userTileData) as arg_userTileData, \
             agmarshall.PVOID_arg(image, IPictureDisp) as arg_image, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_read"](byref(arg_extent.COM_val), arg_userTileData.COM_val, arg_image.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{f8086ed2-4b18-4d6d-a39f-1ab5801cf886}", ICustomImageGlobeOverlay)
agcls.AgTypeNameMap["ICustomImageGlobeOverlay"] = ICustomImageGlobeOverlay

class ICustomImageGlobeOverlayPluginActivator(object):
    """The Activator class provides methods to load COM plugins that implement custom image globe overlays. For more information about custom image globe overlays, see the STK Programming Interface."""
    _uuid = "{efb59b20-9f79-4043-a3bd-6cd1a3395738}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_create_from_display_name"] = _raise_uninitialized_error
        self.__dict__["_get_available_display_names"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICustomImageGlobeOverlayPluginActivator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICustomImageGlobeOverlayPluginActivator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICustomImageGlobeOverlayPluginActivator = agcom.GUID(ICustomImageGlobeOverlayPluginActivator._uuid)
        vtable_offset_local = ICustomImageGlobeOverlayPluginActivator._vtable_offset - 1
        self.__dict__["_create_from_display_name"] = IAGFUNCTYPE(pUnk, IID_ICustomImageGlobeOverlayPluginActivator, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_available_display_names"] = IAGFUNCTYPE(pUnk, IID_ICustomImageGlobeOverlayPluginActivator, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICustomImageGlobeOverlayPluginActivator.__dict__ and type(ICustomImageGlobeOverlayPluginActivator.__dict__[attrname]) == property:
            return ICustomImageGlobeOverlayPluginActivator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICustomImageGlobeOverlayPluginActivator.")
    
    def create_from_display_name(self, displayName:str) -> "ICustomImageGlobeOverlayPluginProxy":
        """Loads a custom image globe overlay COM plugin associated with the specified display name and returns a proxy object that allows accessing the custom image globe overlays implemented by the plugin."""
        with agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_create_from_display_name"](arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_available_display_names(self) -> list:
        """Gets a list of available custom image globe overlay Display Names (Programmatic Identifiers)."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_available_display_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{efb59b20-9f79-4043-a3bd-6cd1a3395738}", ICustomImageGlobeOverlayPluginActivator)
agcls.AgTypeNameMap["ICustomImageGlobeOverlayPluginActivator"] = ICustomImageGlobeOverlayPluginActivator

class ICustomImageGlobeOverlayPluginProxy(object):
    """A proxy class provides access to a custom image globe overlay implemented by a plugin. Proxies are instantiated using custom image globe overlay plugin activator."""
    _uuid = "{197fbafd-0f9c-44d9-b2d0-14c8b30f312e}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_custom_image_globe_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_is_custom_image_globe_overlay_supported"] = _raise_uninitialized_error
        self.__dict__["_get_real_plugin_object"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICustomImageGlobeOverlayPluginProxy._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICustomImageGlobeOverlayPluginProxy from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICustomImageGlobeOverlayPluginProxy = agcom.GUID(ICustomImageGlobeOverlayPluginProxy._uuid)
        vtable_offset_local = ICustomImageGlobeOverlayPluginProxy._vtable_offset - 1
        self.__dict__["_get_custom_image_globe_overlay"] = IAGFUNCTYPE(pUnk, IID_ICustomImageGlobeOverlayPluginProxy, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_is_custom_image_globe_overlay_supported"] = IAGFUNCTYPE(pUnk, IID_ICustomImageGlobeOverlayPluginProxy, vtable_offset_local+2, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_real_plugin_object"] = IAGFUNCTYPE(pUnk, IID_ICustomImageGlobeOverlayPluginProxy, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICustomImageGlobeOverlayPluginProxy.__dict__ and type(ICustomImageGlobeOverlayPluginProxy.__dict__[attrname]) == property:
            return ICustomImageGlobeOverlayPluginProxy.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICustomImageGlobeOverlayPluginProxy.")
    
    @property
    def custom_image_globe_overlay(self) -> "ICustomImageGlobeOverlay":
        """Returns a custom image globe overlay."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_image_globe_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def is_custom_image_globe_overlay_supported(self) -> bool:
        """Returns true if custom image globe overlays are supported."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_custom_image_globe_overlay_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def real_plugin_object(self) -> typing.Any:
        """Returns a pointer to plugin object's IUnknown interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_real_plugin_object"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{197fbafd-0f9c-44d9-b2d0-14c8b30f312e}", ICustomImageGlobeOverlayPluginProxy)
agcls.AgTypeNameMap["ICustomImageGlobeOverlayPluginProxy"] = ICustomImageGlobeOverlayPluginProxy

class IGeospatialImageGlobeOverlay(object):
    """A globe image overlay for handling `JPEG 2000 <https://jpeg.org/jpeg2000/>`_ (.jp2), ECW (.ecw), ECWP, and MrSid (.sid) image formats in the WGS84 geographic projection."""
    _uuid = "{fd42a5ba-5049-4c58-bf40-61ca5943dccf}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_transparent_color"] = _raise_uninitialized_error
        self.__dict__["_set_use_transparent_color"] = _raise_uninitialized_error
        self.__dict__["_get_transparent_color"] = _raise_uninitialized_error
        self.__dict__["_set_transparent_color"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGeospatialImageGlobeOverlay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGeospatialImageGlobeOverlay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGeospatialImageGlobeOverlay = agcom.GUID(IGeospatialImageGlobeOverlay._uuid)
        vtable_offset_local = IGeospatialImageGlobeOverlay._vtable_offset - 1
        self.__dict__["_get_use_transparent_color"] = IAGFUNCTYPE(pUnk, IID_IGeospatialImageGlobeOverlay, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_transparent_color"] = IAGFUNCTYPE(pUnk, IID_IGeospatialImageGlobeOverlay, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_transparent_color"] = IAGFUNCTYPE(pUnk, IID_IGeospatialImageGlobeOverlay, vtable_offset_local+3, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_transparent_color"] = IAGFUNCTYPE(pUnk, IID_IGeospatialImageGlobeOverlay, vtable_offset_local+4, agcom.OLE_COLOR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGeospatialImageGlobeOverlay.__dict__ and type(IGeospatialImageGlobeOverlay.__dict__[attrname]) == property:
            return IGeospatialImageGlobeOverlay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGeospatialImageGlobeOverlay.")
    
    @property
    def use_transparent_color(self) -> bool:
        """Gets or sets whether transparent color should be used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_transparent_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @use_transparent_color.setter
    def use_transparent_color(self, useTransparentColor:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useTransparentColor) as arg_useTransparentColor:
            agcls.evaluate_hresult(self.__dict__["_set_use_transparent_color"](arg_useTransparentColor.COM_val))

    @property
    def transparent_color(self) -> agcolor.Color:
        """Gets or sets the color that will become transparent."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_transparent_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @transparent_color.setter
    def transparent_color(self, transparentColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(transparentColor) as arg_transparentColor:
            agcls.evaluate_hresult(self.__dict__["_set_transparent_color"](arg_transparentColor.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{fd42a5ba-5049-4c58-bf40-61ca5943dccf}", IGeospatialImageGlobeOverlay)
agcls.AgTypeNameMap["IGeospatialImageGlobeOverlay"] = IGeospatialImageGlobeOverlay

class IGlobeOverlay(object):
    """The base class of all terrain overlay and globe image overlay objects."""
    _uuid = "{983949c2-68a3-46ee-9670-f174091286ad}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body"] = _raise_uninitialized_error
        self.__dict__["_get_extent"] = _raise_uninitialized_error
        self.__dict__["_get_role"] = _raise_uninitialized_error
        self.__dict__["_get_uri_as_string"] = _raise_uninitialized_error
        self.__dict__["_get_is_valid"] = _raise_uninitialized_error
        self.__dict__["_get_display_condition"] = _raise_uninitialized_error
        self.__dict__["_set_display_condition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGlobeOverlay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGlobeOverlay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGlobeOverlay = agcom.GUID(IGlobeOverlay._uuid)
        vtable_offset_local = IGlobeOverlay._vtable_offset - 1
        self.__dict__["_get_central_body"] = IAGFUNCTYPE(pUnk, IID_IGlobeOverlay, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_get_extent"] = IAGFUNCTYPE(pUnk, IID_IGlobeOverlay, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_role"] = IAGFUNCTYPE(pUnk, IID_IGlobeOverlay, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_uri_as_string"] = IAGFUNCTYPE(pUnk, IID_IGlobeOverlay, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_get_is_valid"] = IAGFUNCTYPE(pUnk, IID_IGlobeOverlay, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_display_condition"] = IAGFUNCTYPE(pUnk, IID_IGlobeOverlay, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_set_display_condition"] = IAGFUNCTYPE(pUnk, IID_IGlobeOverlay, vtable_offset_local+7, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGlobeOverlay.__dict__ and type(IGlobeOverlay.__dict__[attrname]) == property:
            return IGlobeOverlay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGlobeOverlay.")
    
    @property
    def central_body(self) -> str:
        """Gets the central body that the globe overlay is displayed on. It will return <see langword='null' /> if the globe overlay hasn't been added to a central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def extent(self) -> list:
        """Gets the cartographic extent that represents the area covered by the globe overlay. The array elements are arranged in the order west longitude, south latitude, east longitude, north latitude."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_extent"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def role(self) -> "AgEStkGraphicsGlobeOverlayRole":
        """Gets the globe overlay role of the globe overlay."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsGlobeOverlayRole) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_role"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def uri_as_string(self) -> str:
        """Gets the absolute URI specifying the location of the globe overlay."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_uri_as_string"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def is_valid(self) -> bool:
        """Gets whether or not the overlay is valid. It can be invalid because of a missing file, corrupt file, unlicensed file, or a file on the incorrect central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_valid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def display_condition(self) -> "IDisplayCondition":
        """Gets or sets the display condition that controls whether or not the globe overlay is displayed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_condition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @display_condition.setter
    def display_condition(self, displayCondition:"IDisplayCondition") -> None:
        with agmarshall.AgInterface_in_arg(displayCondition, IDisplayCondition) as arg_displayCondition:
            agcls.evaluate_hresult(self.__dict__["_set_display_condition"](arg_displayCondition.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{983949c2-68a3-46ee-9670-f174091286ad}", IGlobeOverlay)
agcls.AgTypeNameMap["IGlobeOverlay"] = IGlobeOverlay

class IGlobeOverlaySettings(object):
    """Settings used by globe overlay objects. These setting affect all scenes."""
    _uuid = "{2864d6df-bbe2-42b7-9838-27d1f5ff5be6}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_terrain_cache_size"] = _raise_uninitialized_error
        self.__dict__["_set_terrain_cache_size"] = _raise_uninitialized_error
        self.__dict__["_get_imagery_cache_size"] = _raise_uninitialized_error
        self.__dict__["_set_imagery_cache_size"] = _raise_uninitialized_error
        self.__dict__["_get_preload_terrain_and_imagery"] = _raise_uninitialized_error
        self.__dict__["_set_preload_terrain_and_imagery"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGlobeOverlaySettings._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGlobeOverlaySettings from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGlobeOverlaySettings = agcom.GUID(IGlobeOverlaySettings._uuid)
        vtable_offset_local = IGlobeOverlaySettings._vtable_offset - 1
        self.__dict__["_get_terrain_cache_size"] = IAGFUNCTYPE(pUnk, IID_IGlobeOverlaySettings, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_set_terrain_cache_size"] = IAGFUNCTYPE(pUnk, IID_IGlobeOverlaySettings, vtable_offset_local+2, agcom.INT)
        self.__dict__["_get_imagery_cache_size"] = IAGFUNCTYPE(pUnk, IID_IGlobeOverlaySettings, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_set_imagery_cache_size"] = IAGFUNCTYPE(pUnk, IID_IGlobeOverlaySettings, vtable_offset_local+4, agcom.INT)
        self.__dict__["_get_preload_terrain_and_imagery"] = IAGFUNCTYPE(pUnk, IID_IGlobeOverlaySettings, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_preload_terrain_and_imagery"] = IAGFUNCTYPE(pUnk, IID_IGlobeOverlaySettings, vtable_offset_local+6, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGlobeOverlaySettings.__dict__ and type(IGlobeOverlaySettings.__dict__[attrname]) == property:
            return IGlobeOverlaySettings.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGlobeOverlaySettings.")
    
    @property
    def terrain_cache_size(self) -> int:
        """Gets or sets the size of the terrain cache in megabytes. It is not recommended to go above 128 megabytes. Large cache sizes can slow down rendering since so much imagery will be rendered."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_terrain_cache_size"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @terrain_cache_size.setter
    def terrain_cache_size(self, terrainCacheSize:int) -> None:
        with agmarshall.INT_arg(terrainCacheSize) as arg_terrainCacheSize:
            agcls.evaluate_hresult(self.__dict__["_set_terrain_cache_size"](arg_terrainCacheSize.COM_val))

    @property
    def imagery_cache_size(self) -> int:
        """Gets or sets the size of the imagery cache in megabytes. It is not recommended to go above 128 megabytes. Large cache sizes can slow down rendering since so much imagery will be rendered."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_imagery_cache_size"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @imagery_cache_size.setter
    def imagery_cache_size(self, imageryCacheSize:int) -> None:
        with agmarshall.INT_arg(imageryCacheSize) as arg_imageryCacheSize:
            agcls.evaluate_hresult(self.__dict__["_set_imagery_cache_size"](arg_imageryCacheSize.COM_val))

    @property
    def preload_terrain_and_imagery(self) -> bool:
        """Gets or sets whether terrain and imagery are preloaded. When set to true, terrain and imagery are preloaded to get the best visual quality; when set to false, they are not preloaded..."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_preload_terrain_and_imagery"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @preload_terrain_and_imagery.setter
    def preload_terrain_and_imagery(self, preloadTerrainAndImagery:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(preloadTerrainAndImagery) as arg_preloadTerrainAndImagery:
            agcls.evaluate_hresult(self.__dict__["_set_preload_terrain_and_imagery"](arg_preloadTerrainAndImagery.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2864d6df-bbe2-42b7-9838-27d1f5ff5be6}", IGlobeOverlaySettings)
agcls.AgTypeNameMap["IGlobeOverlaySettings"] = IGlobeOverlaySettings

class ILighting(object):
    """Lighting in the 3D scene."""
    _uuid = "{683cd020-54fc-48af-b7e4-0dbe06c9bf12}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enabled"] = _raise_uninitialized_error
        self.__dict__["_set_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_ambient_intensity"] = _raise_uninitialized_error
        self.__dict__["_set_ambient_intensity"] = _raise_uninitialized_error
        self.__dict__["_get_diffuse_intensity"] = _raise_uninitialized_error
        self.__dict__["_set_diffuse_intensity"] = _raise_uninitialized_error
        self.__dict__["_get_night_lights_intensity"] = _raise_uninitialized_error
        self.__dict__["_set_night_lights_intensity"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ILighting._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ILighting from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ILighting = agcom.GUID(ILighting._uuid)
        vtable_offset_local = ILighting._vtable_offset - 1
        self.__dict__["_get_enabled"] = IAGFUNCTYPE(pUnk, IID_ILighting, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enabled"] = IAGFUNCTYPE(pUnk, IID_ILighting, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_ambient_intensity"] = IAGFUNCTYPE(pUnk, IID_ILighting, vtable_offset_local+3, POINTER(agcom.FLOAT))
        self.__dict__["_set_ambient_intensity"] = IAGFUNCTYPE(pUnk, IID_ILighting, vtable_offset_local+4, agcom.FLOAT)
        self.__dict__["_get_diffuse_intensity"] = IAGFUNCTYPE(pUnk, IID_ILighting, vtable_offset_local+5, POINTER(agcom.FLOAT))
        self.__dict__["_set_diffuse_intensity"] = IAGFUNCTYPE(pUnk, IID_ILighting, vtable_offset_local+6, agcom.FLOAT)
        self.__dict__["_get_night_lights_intensity"] = IAGFUNCTYPE(pUnk, IID_ILighting, vtable_offset_local+7, POINTER(agcom.FLOAT))
        self.__dict__["_set_night_lights_intensity"] = IAGFUNCTYPE(pUnk, IID_ILighting, vtable_offset_local+8, agcom.FLOAT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ILighting.__dict__ and type(ILighting.__dict__[attrname]) == property:
            return ILighting.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ILighting.")
    
    @property
    def enabled(self) -> bool:
        """Gets or sets whether or not lighting is enabled."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_enabled"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @enabled.setter
    def enabled(self, enabled:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(enabled) as arg_enabled:
            agcls.evaluate_hresult(self.__dict__["_set_enabled"](arg_enabled.COM_val))

    @property
    def ambient_intensity(self) -> float:
        """Gets or sets the ambient intensity throughout the scene."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_ambient_intensity"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ambient_intensity.setter
    def ambient_intensity(self, ambientIntensity:float) -> None:
        with agmarshall.FLOAT_arg(ambientIntensity) as arg_ambientIntensity:
            agcls.evaluate_hresult(self.__dict__["_set_ambient_intensity"](arg_ambientIntensity.COM_val))

    @property
    def diffuse_intensity(self) -> float:
        """Gets or sets the diffuse intensity from the sun."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_diffuse_intensity"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @diffuse_intensity.setter
    def diffuse_intensity(self, diffuseIntensity:float) -> None:
        with agmarshall.FLOAT_arg(diffuseIntensity) as arg_diffuseIntensity:
            agcls.evaluate_hresult(self.__dict__["_set_diffuse_intensity"](arg_diffuseIntensity.COM_val))

    @property
    def night_lights_intensity(self) -> float:
        """Gets or sets the overall brightness for the night light's image overlay, night overlay."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_night_lights_intensity"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @night_lights_intensity.setter
    def night_lights_intensity(self, nightLightsIntensity:float) -> None:
        with agmarshall.FLOAT_arg(nightLightsIntensity) as arg_nightLightsIntensity:
            agcls.evaluate_hresult(self.__dict__["_set_night_lights_intensity"](arg_nightLightsIntensity.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{683cd020-54fc-48af-b7e4-0dbe06c9bf12}", ILighting)
agcls.AgTypeNameMap["ILighting"] = ILighting

class IPathPrimitiveUpdatePolicy(object):
    """A class that encapsulates the update logic for a path primitive. Derived classes must implement the Update method."""
    _uuid = "{71fe898e-dabb-4501-9c80-dcb1cde9c16b}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_update"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPathPrimitiveUpdatePolicy._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPathPrimitiveUpdatePolicy from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPathPrimitiveUpdatePolicy = agcom.GUID(IPathPrimitiveUpdatePolicy._uuid)
        vtable_offset_local = IPathPrimitiveUpdatePolicy._vtable_offset - 1
        self.__dict__["_update"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitiveUpdatePolicy, vtable_offset_local+1, agcom.PVOID, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPathPrimitiveUpdatePolicy.__dict__ and type(IPathPrimitiveUpdatePolicy.__dict__[attrname]) == property:
            return IPathPrimitiveUpdatePolicy.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPathPrimitiveUpdatePolicy.")
    
    def update(self, pathPrimitive:"IPathPrimitive", date:"IDate") -> None:
        """Updates the pathPrimitive at the specified date."""
        with agmarshall.AgInterface_in_arg(pathPrimitive, IPathPrimitive) as arg_pathPrimitive, \
             agmarshall.AgInterface_in_arg(date, IDate) as arg_date:
            agcls.evaluate_hresult(self.__dict__["_update"](arg_pathPrimitive.COM_val, arg_date.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{71fe898e-dabb-4501-9c80-dcb1cde9c16b}", IPathPrimitiveUpdatePolicy)
agcls.AgTypeNameMap["IPathPrimitiveUpdatePolicy"] = IPathPrimitiveUpdatePolicy

class IProjectedRasterOverlay(object):
    """A globe image overlay which projects a raster onto the terrain or surface of the central body. You can also enable projection onto models by setting projected raster model projection to true for a Scene..."""
    _uuid = "{7cb212ed-4ef5-43c7-bbc3-f2ebd4dfd143}"
    _num_methods = 36
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_raster"] = _raise_uninitialized_error
        self.__dict__["_set_raster"] = _raise_uninitialized_error
        self.__dict__["_get_projection"] = _raise_uninitialized_error
        self.__dict__["_set_projection"] = _raise_uninitialized_error
        self.__dict__["_get_show_shadows"] = _raise_uninitialized_error
        self.__dict__["_set_show_shadows"] = _raise_uninitialized_error
        self.__dict__["_get_show_frustum"] = _raise_uninitialized_error
        self.__dict__["_set_show_frustum"] = _raise_uninitialized_error
        self.__dict__["_get_show_far_plane"] = _raise_uninitialized_error
        self.__dict__["_set_show_far_plane"] = _raise_uninitialized_error
        self.__dict__["_get_color"] = _raise_uninitialized_error
        self.__dict__["_set_color"] = _raise_uninitialized_error
        self.__dict__["_get_frustum_color"] = _raise_uninitialized_error
        self.__dict__["_set_frustum_color"] = _raise_uninitialized_error
        self.__dict__["_get_far_plane_color"] = _raise_uninitialized_error
        self.__dict__["_set_far_plane_color"] = _raise_uninitialized_error
        self.__dict__["_get_shadow_color"] = _raise_uninitialized_error
        self.__dict__["_set_shadow_color"] = _raise_uninitialized_error
        self.__dict__["_get_border_color"] = _raise_uninitialized_error
        self.__dict__["_set_border_color"] = _raise_uninitialized_error
        self.__dict__["_get_border_width"] = _raise_uninitialized_error
        self.__dict__["_set_border_width"] = _raise_uninitialized_error
        self.__dict__["_get_frustum_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_frustum_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_far_plane_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_far_plane_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_shadow_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_shadow_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_border_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_border_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_use_transparent_color"] = _raise_uninitialized_error
        self.__dict__["_set_use_transparent_color"] = _raise_uninitialized_error
        self.__dict__["_get_transparent_color"] = _raise_uninitialized_error
        self.__dict__["_set_transparent_color"] = _raise_uninitialized_error
        self.__dict__["_get_directions"] = _raise_uninitialized_error
        self.__dict__["_get_supported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProjectedRasterOverlay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProjectedRasterOverlay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProjectedRasterOverlay = agcom.GUID(IProjectedRasterOverlay._uuid)
        vtable_offset_local = IProjectedRasterOverlay._vtable_offset - 1
        self.__dict__["_get_raster"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_set_raster"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_get_projection"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_set_projection"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_get_show_shadows"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show_shadows"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_show_frustum"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show_frustum"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_show_far_plane"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show_far_plane"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_color"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+11, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_color"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+12, agcom.OLE_COLOR)
        self.__dict__["_get_frustum_color"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+13, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_frustum_color"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+14, agcom.OLE_COLOR)
        self.__dict__["_get_far_plane_color"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+15, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_far_plane_color"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+16, agcom.OLE_COLOR)
        self.__dict__["_get_shadow_color"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+17, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_shadow_color"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+18, agcom.OLE_COLOR)
        self.__dict__["_get_border_color"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+19, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_border_color"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+20, agcom.OLE_COLOR)
        self.__dict__["_get_border_width"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+21, POINTER(agcom.FLOAT))
        self.__dict__["_set_border_width"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+22, agcom.FLOAT)
        self.__dict__["_get_frustum_translucency"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+23, POINTER(agcom.FLOAT))
        self.__dict__["_set_frustum_translucency"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+24, agcom.FLOAT)
        self.__dict__["_get_far_plane_translucency"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+25, POINTER(agcom.FLOAT))
        self.__dict__["_set_far_plane_translucency"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+26, agcom.FLOAT)
        self.__dict__["_get_shadow_translucency"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+27, POINTER(agcom.FLOAT))
        self.__dict__["_set_shadow_translucency"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+28, agcom.FLOAT)
        self.__dict__["_get_border_translucency"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+29, POINTER(agcom.FLOAT))
        self.__dict__["_set_border_translucency"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+30, agcom.FLOAT)
        self.__dict__["_get_use_transparent_color"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+31, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_transparent_color"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+32, agcom.VARIANT_BOOL)
        self.__dict__["_get_transparent_color"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+33, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_transparent_color"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+34, agcom.OLE_COLOR)
        self.__dict__["_get_directions"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+35, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_supported"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlay, vtable_offset_local+36, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProjectedRasterOverlay.__dict__ and type(IProjectedRasterOverlay.__dict__[attrname]) == property:
            return IProjectedRasterOverlay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProjectedRasterOverlay.")
    
    @property
    def raster(self) -> "IRaster":
        """Gets or sets the raster that is projected."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_raster"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @raster.setter
    def raster(self, raster:"IRaster") -> None:
        with agmarshall.AgInterface_in_arg(raster, IRaster) as arg_raster:
            agcls.evaluate_hresult(self.__dict__["_set_raster"](arg_raster.COM_val))

    @property
    def projection(self) -> "IProjection":
        """Gets or sets the projection that projects the raster."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_projection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @projection.setter
    def projection(self, projection:"IProjection") -> None:
        with agmarshall.AgInterface_in_arg(projection, IProjection) as arg_projection:
            agcls.evaluate_hresult(self.__dict__["_set_projection"](arg_projection.COM_val))

    @property
    def show_shadows(self) -> bool:
        """Gets or sets whether to show shadows or not. When set to true, the raster will only be projected onto parts of the terrain visible from the projection's position. When false, the raster will project onto any terrain inside the projection's view frustum..."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_show_shadows"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @show_shadows.setter
    def show_shadows(self, showShadows:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(showShadows) as arg_showShadows:
            agcls.evaluate_hresult(self.__dict__["_set_show_shadows"](arg_showShadows.COM_val))

    @property
    def show_frustum(self) -> bool:
        """Gets or sets whether to show the frustum of the projection."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_show_frustum"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @show_frustum.setter
    def show_frustum(self, showFrustum:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(showFrustum) as arg_showFrustum:
            agcls.evaluate_hresult(self.__dict__["_set_show_frustum"](arg_showFrustum.COM_val))

    @property
    def show_far_plane(self) -> bool:
        """Gets or sets whether to show the far plane of the projection. If this is set to true, you will see the projected raster even when it does not intersect terrain."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_show_far_plane"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @show_far_plane.setter
    def show_far_plane(self, showFarPlane:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(showFarPlane) as arg_showFarPlane:
            agcls.evaluate_hresult(self.__dict__["_set_show_far_plane"](arg_showFarPlane.COM_val))

    @property
    def color(self) -> agcolor.Color:
        """Gets or sets the color of the projected raster."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @color.setter
    def color(self, color:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(color) as arg_color:
            agcls.evaluate_hresult(self.__dict__["_set_color"](arg_color.COM_val))

    @property
    def frustum_color(self) -> agcolor.Color:
        """Gets or sets the color of the projection's frustum."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_frustum_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @frustum_color.setter
    def frustum_color(self, frustumColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(frustumColor) as arg_frustumColor:
            agcls.evaluate_hresult(self.__dict__["_set_frustum_color"](arg_frustumColor.COM_val))

    @property
    def far_plane_color(self) -> agcolor.Color:
        """Gets or sets the color of the projection's far plane."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_far_plane_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @far_plane_color.setter
    def far_plane_color(self, farPlaneColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(farPlaneColor) as arg_farPlaneColor:
            agcls.evaluate_hresult(self.__dict__["_set_far_plane_color"](arg_farPlaneColor.COM_val))

    @property
    def shadow_color(self) -> agcolor.Color:
        """Gets or sets the color of the projection's shadow."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_shadow_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @shadow_color.setter
    def shadow_color(self, shadowColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(shadowColor) as arg_shadowColor:
            agcls.evaluate_hresult(self.__dict__["_set_shadow_color"](arg_shadowColor.COM_val))

    @property
    def border_color(self) -> agcolor.Color:
        """Gets or sets the color of the projection's border."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_border_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @border_color.setter
    def border_color(self, borderColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(borderColor) as arg_borderColor:
            agcls.evaluate_hresult(self.__dict__["_set_border_color"](arg_borderColor.COM_val))

    @property
    def border_width(self) -> float:
        """Gets or sets the width of the projection's border."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_border_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @border_width.setter
    def border_width(self, borderWidth:float) -> None:
        with agmarshall.FLOAT_arg(borderWidth) as arg_borderWidth:
            agcls.evaluate_hresult(self.__dict__["_set_border_width"](arg_borderWidth.COM_val))

    @property
    def frustum_translucency(self) -> float:
        """Gets or sets the translucency of the projection's frustum."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_frustum_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @frustum_translucency.setter
    def frustum_translucency(self, frustumTranslucency:float) -> None:
        with agmarshall.FLOAT_arg(frustumTranslucency) as arg_frustumTranslucency:
            agcls.evaluate_hresult(self.__dict__["_set_frustum_translucency"](arg_frustumTranslucency.COM_val))

    @property
    def far_plane_translucency(self) -> float:
        """Gets or sets the translucency of the projection's far plane."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_far_plane_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @far_plane_translucency.setter
    def far_plane_translucency(self, farPlaneTranslucency:float) -> None:
        with agmarshall.FLOAT_arg(farPlaneTranslucency) as arg_farPlaneTranslucency:
            agcls.evaluate_hresult(self.__dict__["_set_far_plane_translucency"](arg_farPlaneTranslucency.COM_val))

    @property
    def shadow_translucency(self) -> float:
        """Gets or sets the translucency of the projection's shadow."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_shadow_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @shadow_translucency.setter
    def shadow_translucency(self, shadowTranslucency:float) -> None:
        with agmarshall.FLOAT_arg(shadowTranslucency) as arg_shadowTranslucency:
            agcls.evaluate_hresult(self.__dict__["_set_shadow_translucency"](arg_shadowTranslucency.COM_val))

    @property
    def border_translucency(self) -> float:
        """Gets or sets the translucency of the projection's border."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_border_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @border_translucency.setter
    def border_translucency(self, borderTranslucency:float) -> None:
        with agmarshall.FLOAT_arg(borderTranslucency) as arg_borderTranslucency:
            agcls.evaluate_hresult(self.__dict__["_set_border_translucency"](arg_borderTranslucency.COM_val))

    @property
    def use_transparent_color(self) -> bool:
        """Gets or sets whether transparent color should be used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_transparent_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @use_transparent_color.setter
    def use_transparent_color(self, useTransparentColor:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useTransparentColor) as arg_useTransparentColor:
            agcls.evaluate_hresult(self.__dict__["_set_use_transparent_color"](arg_useTransparentColor.COM_val))

    @property
    def transparent_color(self) -> agcolor.Color:
        """Gets or sets the color that will become transparent."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_transparent_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @transparent_color.setter
    def transparent_color(self, transparentColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(transparentColor) as arg_transparentColor:
            agcls.evaluate_hresult(self.__dict__["_set_transparent_color"](arg_transparentColor.COM_val))

    @property
    def directions(self) -> list:
        """Gets the direction vectors in the central body's fixed reference frame that define the projection's frustum..."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_directions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def supported(self) -> bool:
        """Gets whether or not the video card supports the projected raster overlay."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7cb212ed-4ef5-43c7-bbc3-f2ebd4dfd143}", IProjectedRasterOverlay)
agcls.AgTypeNameMap["IProjectedRasterOverlay"] = IProjectedRasterOverlay

class IProjection(object):
    """A projection represents a simplified camera with a position, orientation, and field of view horizontal and field of view vertical..."""
    _uuid = "{152e3a02-23b0-4dc8-a7e5-9ee19619bcab}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_position"] = _raise_uninitialized_error
        self.__dict__["_set_position"] = _raise_uninitialized_error
        self.__dict__["_get_orientation"] = _raise_uninitialized_error
        self.__dict__["_set_orientation"] = _raise_uninitialized_error
        self.__dict__["_get_field_of_view_horizontal"] = _raise_uninitialized_error
        self.__dict__["_set_field_of_view_horizontal"] = _raise_uninitialized_error
        self.__dict__["_get_field_of_view_vertical"] = _raise_uninitialized_error
        self.__dict__["_set_field_of_view_vertical"] = _raise_uninitialized_error
        self.__dict__["_get_near_plane"] = _raise_uninitialized_error
        self.__dict__["_set_near_plane"] = _raise_uninitialized_error
        self.__dict__["_get_far_plane"] = _raise_uninitialized_error
        self.__dict__["_set_far_plane"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProjection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProjection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProjection = agcom.GUID(IProjection._uuid)
        vtable_offset_local = IProjection._vtable_offset - 1
        self.__dict__["_get_position"] = IAGFUNCTYPE(pUnk, IID_IProjection, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_position"] = IAGFUNCTYPE(pUnk, IID_IProjection, vtable_offset_local+2, agcom.SAFEARRAY)
        self.__dict__["_get_orientation"] = IAGFUNCTYPE(pUnk, IID_IProjection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_set_orientation"] = IAGFUNCTYPE(pUnk, IID_IProjection, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_get_field_of_view_horizontal"] = IAGFUNCTYPE(pUnk, IID_IProjection, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_field_of_view_horizontal"] = IAGFUNCTYPE(pUnk, IID_IProjection, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_field_of_view_vertical"] = IAGFUNCTYPE(pUnk, IID_IProjection, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_field_of_view_vertical"] = IAGFUNCTYPE(pUnk, IID_IProjection, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_near_plane"] = IAGFUNCTYPE(pUnk, IID_IProjection, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_near_plane"] = IAGFUNCTYPE(pUnk, IID_IProjection, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_far_plane"] = IAGFUNCTYPE(pUnk, IID_IProjection, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_far_plane"] = IAGFUNCTYPE(pUnk, IID_IProjection, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProjection.__dict__ and type(IProjection.__dict__[attrname]) == property:
            return IProjection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProjection.")
    
    @property
    def position(self) -> list:
        """Gets or sets the cartesian defining the position of the projection in the central body's fixed reference frame. The array contains the components of the position arranged in the order x, y, z."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @position.setter
    def position(self, position:list) -> None:
        with agmarshall.SAFEARRAY_arg(position) as arg_position:
            agcls.evaluate_hresult(self.__dict__["_set_position"](arg_position.COM_val))

    @property
    def orientation(self) -> "IOrientation":
        """Gets or sets the unit quaternion defining the orientation of the projection in the central body's fixed reference frame."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_orientation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @orientation.setter
    def orientation(self, orientation:"IOrientation") -> None:
        with agmarshall.AgInterface_in_arg(orientation, IOrientation) as arg_orientation:
            agcls.evaluate_hresult(self.__dict__["_set_orientation"](arg_orientation.COM_val))

    @property
    def field_of_view_horizontal(self) -> float:
        """Gets or sets the horizontal field of view associated with the projection."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_field_of_view_horizontal"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @field_of_view_horizontal.setter
    def field_of_view_horizontal(self, fieldOfViewHorizontal:float) -> None:
        with agmarshall.DOUBLE_arg(fieldOfViewHorizontal) as arg_fieldOfViewHorizontal:
            agcls.evaluate_hresult(self.__dict__["_set_field_of_view_horizontal"](arg_fieldOfViewHorizontal.COM_val))

    @property
    def field_of_view_vertical(self) -> float:
        """Gets or sets the vertical field of view associated with the projection."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_field_of_view_vertical"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @field_of_view_vertical.setter
    def field_of_view_vertical(self, fieldOfViewVertical:float) -> None:
        with agmarshall.DOUBLE_arg(fieldOfViewVertical) as arg_fieldOfViewVertical:
            agcls.evaluate_hresult(self.__dict__["_set_field_of_view_vertical"](arg_fieldOfViewVertical.COM_val))

    @property
    def near_plane(self) -> float:
        """Gets or sets the near plane associated with the projection."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_near_plane"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @near_plane.setter
    def near_plane(self, nearPlane:float) -> None:
        with agmarshall.DOUBLE_arg(nearPlane) as arg_nearPlane:
            agcls.evaluate_hresult(self.__dict__["_set_near_plane"](arg_nearPlane.COM_val))

    @property
    def far_plane(self) -> float:
        """Gets or sets the far plane associated with the projection."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_far_plane"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @far_plane.setter
    def far_plane(self, farPlane:float) -> None:
        with agmarshall.DOUBLE_arg(farPlane) as arg_farPlane:
            agcls.evaluate_hresult(self.__dict__["_set_far_plane"](arg_farPlane.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{152e3a02-23b0-4dc8-a7e5-9ee19619bcab}", IProjection)
agcls.AgTypeNameMap["IProjection"] = IProjection

class IProjectionStream(object):
    """A projection that is updated dynamically at the specified update delta. The class can be used to stream projection data to projection clients, like projected raster overlay..."""
    _uuid = "{7af66bcf-c123-47b2-ac63-168bbdedec66}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_update_delta"] = _raise_uninitialized_error
        self.__dict__["_set_update_delta"] = _raise_uninitialized_error
        self.__dict__["_update"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProjectionStream._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProjectionStream from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProjectionStream = agcom.GUID(IProjectionStream._uuid)
        vtable_offset_local = IProjectionStream._vtable_offset - 1
        self.__dict__["_get_update_delta"] = IAGFUNCTYPE(pUnk, IID_IProjectionStream, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_update_delta"] = IAGFUNCTYPE(pUnk, IID_IProjectionStream, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_update"] = IAGFUNCTYPE(pUnk, IID_IProjectionStream, vtable_offset_local+3, agcom.PVOID, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProjectionStream.__dict__ and type(IProjectionStream.__dict__[attrname]) == property:
            return IProjectionStream.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProjectionStream.")
    
    @property
    def update_delta(self) -> float:
        """Gets or sets the update delta of the projection stream in seconds. The update delta defines the interval at which the Update method will be called..."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_update_delta"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @update_delta.setter
    def update_delta(self, updateDelta:float) -> None:
        with agmarshall.DOUBLE_arg(updateDelta) as arg_updateDelta:
            agcls.evaluate_hresult(self.__dict__["_set_update_delta"](arg_updateDelta.COM_val))

    def update(self, time:"IDate", nextTime:"IDate") -> bool:
        """When overridden in a derived class, updates the projection data associated with the projection stream at the specified time. When the Update method is called, the projection stream contains the current projection data..."""
        with agmarshall.AgInterface_in_arg(time, IDate) as arg_time, \
             agmarshall.AgInterface_in_arg(nextTime, IDate) as arg_nextTime, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_update"](arg_time.COM_val, arg_nextTime.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7af66bcf-c123-47b2-ac63-168bbdedec66}", IProjectionStream)
agcls.AgTypeNameMap["IProjectionStream"] = IProjectionStream

class ISceneGlobeOverlaySettings(object):
    """Settings used by globe overlay objects. These settings only affect the scene."""
    _uuid = "{6f2961c3-3fbe-4d5c-849b-d17be044dd71}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_anti_alias_imagery"] = _raise_uninitialized_error
        self.__dict__["_set_anti_alias_imagery"] = _raise_uninitialized_error
        self.__dict__["_get_terrain_mesh_pixel_error"] = _raise_uninitialized_error
        self.__dict__["_set_terrain_mesh_pixel_error"] = _raise_uninitialized_error
        self.__dict__["_get_imagery_pixel_error"] = _raise_uninitialized_error
        self.__dict__["_set_imagery_pixel_error"] = _raise_uninitialized_error
        self.__dict__["_get_projected_raster_model_projection"] = _raise_uninitialized_error
        self.__dict__["_set_projected_raster_model_projection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISceneGlobeOverlaySettings._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISceneGlobeOverlaySettings from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISceneGlobeOverlaySettings = agcom.GUID(ISceneGlobeOverlaySettings._uuid)
        vtable_offset_local = ISceneGlobeOverlaySettings._vtable_offset - 1
        self.__dict__["_get_anti_alias_imagery"] = IAGFUNCTYPE(pUnk, IID_ISceneGlobeOverlaySettings, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_anti_alias_imagery"] = IAGFUNCTYPE(pUnk, IID_ISceneGlobeOverlaySettings, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_terrain_mesh_pixel_error"] = IAGFUNCTYPE(pUnk, IID_ISceneGlobeOverlaySettings, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_terrain_mesh_pixel_error"] = IAGFUNCTYPE(pUnk, IID_ISceneGlobeOverlaySettings, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_imagery_pixel_error"] = IAGFUNCTYPE(pUnk, IID_ISceneGlobeOverlaySettings, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_imagery_pixel_error"] = IAGFUNCTYPE(pUnk, IID_ISceneGlobeOverlaySettings, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_projected_raster_model_projection"] = IAGFUNCTYPE(pUnk, IID_ISceneGlobeOverlaySettings, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_projected_raster_model_projection"] = IAGFUNCTYPE(pUnk, IID_ISceneGlobeOverlaySettings, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISceneGlobeOverlaySettings.__dict__ and type(ISceneGlobeOverlaySettings.__dict__[attrname]) == property:
            return ISceneGlobeOverlaySettings.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISceneGlobeOverlaySettings.")
    
    @property
    def anti_alias_imagery(self) -> bool:
        """Gets or sets a value indicating whether or not imagery is anti-aliased."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_anti_alias_imagery"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @anti_alias_imagery.setter
    def anti_alias_imagery(self, antiAliasImagery:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(antiAliasImagery) as arg_antiAliasImagery:
            agcls.evaluate_hresult(self.__dict__["_set_anti_alias_imagery"](arg_antiAliasImagery.COM_val))

    @property
    def terrain_mesh_pixel_error(self) -> float:
        """Gets or sets the pixel error for terrain meshes. This is the number of pixels that the rendered terrain is different from the actual terrain data. The default is 2.0 pixels."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_terrain_mesh_pixel_error"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @terrain_mesh_pixel_error.setter
    def terrain_mesh_pixel_error(self, terrainMeshPixelError:float) -> None:
        with agmarshall.DOUBLE_arg(terrainMeshPixelError) as arg_terrainMeshPixelError:
            agcls.evaluate_hresult(self.__dict__["_set_terrain_mesh_pixel_error"](arg_terrainMeshPixelError.COM_val))

    @property
    def imagery_pixel_error(self) -> float:
        """Gets or sets the pixel error for imagery. This is the number of pixels that the rendered imagery is different from the actual imagery data. The default is 1.0 pixel."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_imagery_pixel_error"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @imagery_pixel_error.setter
    def imagery_pixel_error(self, imageryPixelError:float) -> None:
        with agmarshall.DOUBLE_arg(imageryPixelError) as arg_imageryPixelError:
            agcls.evaluate_hresult(self.__dict__["_set_imagery_pixel_error"](arg_imageryPixelError.COM_val))

    @property
    def projected_raster_model_projection(self) -> bool:
        """Gets or sets whether projected raster globe overlays will also project onto models."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_projected_raster_model_projection"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @projected_raster_model_projection.setter
    def projected_raster_model_projection(self, projectedRasterModelProjection:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(projectedRasterModelProjection) as arg_projectedRasterModelProjection:
            agcls.evaluate_hresult(self.__dict__["_set_projected_raster_model_projection"](arg_projectedRasterModelProjection.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6f2961c3-3fbe-4d5c-849b-d17be044dd71}", ISceneGlobeOverlaySettings)
agcls.AgTypeNameMap["ISceneGlobeOverlaySettings"] = ISceneGlobeOverlaySettings

class IScreenOverlayCollectionBase(object):
    """The common base class for collections of overlays held by screen overlay and by screen overlay manager."""
    _uuid = "{49ea6365-0b8d-4fc5-ad52-c1d16ac7568d}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_is_read_only"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_contains"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_clear"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScreenOverlayCollectionBase._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScreenOverlayCollectionBase from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScreenOverlayCollectionBase = agcom.GUID(IScreenOverlayCollectionBase._uuid)
        vtable_offset_local = IScreenOverlayCollectionBase._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayCollectionBase, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_get_is_read_only"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayCollectionBase, vtable_offset_local+2, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayCollectionBase, vtable_offset_local+3, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayCollectionBase, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_contains"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayCollectionBase, vtable_offset_local+5, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayCollectionBase, vtable_offset_local+6, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_clear"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayCollectionBase, vtable_offset_local+7, )
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayCollectionBase, vtable_offset_local+8, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScreenOverlayCollectionBase.__dict__ and type(IScreenOverlayCollectionBase.__dict__[attrname]) == property:
            return IScreenOverlayCollectionBase.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScreenOverlayCollectionBase.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IScreenOverlay":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """Gets the number of screen overlays in the collection."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def is_read_only(self) -> bool:
        """Gets a value indicating whether the collection is read-only."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_read_only"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> "IScreenOverlay":
        """Gets the overlay at the specified index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns an enumerator that iterates through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def contains(self, item:"IScreenOverlay") -> bool:
        """Determines whether the collection contains a specific overlay."""
        with agmarshall.AgInterface_in_arg(item, IScreenOverlay) as arg_item, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_contains"](arg_item.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def remove(self, item:"IScreenOverlay") -> bool:
        """Removes the first occurrence of a specific overlay from the collection."""
        with agmarshall.AgInterface_in_arg(item, IScreenOverlay) as arg_item, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_item.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def clear(self) -> None:
        """Removes all overlays from the collection."""
        agcls.evaluate_hresult(self.__dict__["_clear"]())

    def add(self, item:"IScreenOverlay") -> None:
        """Adds an overlay to the collection."""
        with agmarshall.AgInterface_in_arg(item, IScreenOverlay) as arg_item:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_item.COM_val))

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{49ea6365-0b8d-4fc5-ad52-c1d16ac7568d}", IScreenOverlayCollectionBase)
agcls.AgTypeNameMap["IScreenOverlayCollectionBase"] = IScreenOverlayCollectionBase

class ITexture2DFactory(object):
    """A factory for creating texture 2d objects from various sources."""
    _uuid = "{455fd9a8-e787-4459-a613-e3367dce25b8}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_load_from_string_uri"] = _raise_uninitialized_error
        self.__dict__["_from_raster"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITexture2DFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITexture2DFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITexture2DFactory = agcom.GUID(ITexture2DFactory._uuid)
        vtable_offset_local = ITexture2DFactory._vtable_offset - 1
        self.__dict__["_load_from_string_uri"] = IAGFUNCTYPE(pUnk, IID_ITexture2DFactory, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_from_raster"] = IAGFUNCTYPE(pUnk, IID_ITexture2DFactory, vtable_offset_local+2, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITexture2DFactory.__dict__ and type(ITexture2DFactory.__dict__[attrname]) == property:
            return ITexture2DFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITexture2DFactory.")
    
    def load_from_string_uri(self, uri:str) -> "IRendererTexture2D":
        """Creates a new texture from a Uri, which can be a file, HTTP, HTTPS, or FTP source. See raster for a list of supported raster formats."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_load_from_string_uri"](arg_uri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def from_raster(self, raster:"IRaster") -> "IRendererTexture2D":
        """Creates a new texture from a raster."""
        with agmarshall.AgInterface_in_arg(raster, IRaster) as arg_raster, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_from_raster"](arg_raster.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{455fd9a8-e787-4459-a613-e3367dce25b8}", ITexture2DFactory)
agcls.AgTypeNameMap["ITexture2DFactory"] = ITexture2DFactory

class IVisualEffects(object):
    """Controls various post processing effects that can be applied to the scene."""
    _uuid = "{a1b830ed-9742-4903-9773-1edbc40f0deb}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_lens_flare_enabled"] = _raise_uninitialized_error
        self.__dict__["_set_lens_flare_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_vignette_enabled"] = _raise_uninitialized_error
        self.__dict__["_set_vignette_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_vignette_strength"] = _raise_uninitialized_error
        self.__dict__["_set_vignette_strength"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVisualEffects._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVisualEffects from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVisualEffects = agcom.GUID(IVisualEffects._uuid)
        vtable_offset_local = IVisualEffects._vtable_offset - 1
        self.__dict__["_get_lens_flare_enabled"] = IAGFUNCTYPE(pUnk, IID_IVisualEffects, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_lens_flare_enabled"] = IAGFUNCTYPE(pUnk, IID_IVisualEffects, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_vignette_enabled"] = IAGFUNCTYPE(pUnk, IID_IVisualEffects, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_vignette_enabled"] = IAGFUNCTYPE(pUnk, IID_IVisualEffects, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_vignette_strength"] = IAGFUNCTYPE(pUnk, IID_IVisualEffects, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_vignette_strength"] = IAGFUNCTYPE(pUnk, IID_IVisualEffects, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVisualEffects.__dict__ and type(IVisualEffects.__dict__[attrname]) == property:
            return IVisualEffects.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVisualEffects.")
    
    @property
    def lens_flare_enabled(self) -> bool:
        """Gets or sets whether or not the lens flare effect is enabled"""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_lens_flare_enabled"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @lens_flare_enabled.setter
    def lens_flare_enabled(self, lensFlareEnabled:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(lensFlareEnabled) as arg_lensFlareEnabled:
            agcls.evaluate_hresult(self.__dict__["_set_lens_flare_enabled"](arg_lensFlareEnabled.COM_val))

    @property
    def vignette_enabled(self) -> bool:
        """Gets or sets whether or not the vignette effect is enabled. This simulates light being blocked by the lens hood, resulting in a slight darkening at the perimeter of the 3D Window."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_vignette_enabled"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @vignette_enabled.setter
    def vignette_enabled(self, vignetteEnabled:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(vignetteEnabled) as arg_vignetteEnabled:
            agcls.evaluate_hresult(self.__dict__["_set_vignette_enabled"](arg_vignetteEnabled.COM_val))

    @property
    def vignette_strength(self) -> float:
        """Sets the strength of the vignette effect, values between [0.001 and 5.0], with larger values resulting in more pronounced darkening around the perimeter of the 3D window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_vignette_strength"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @vignette_strength.setter
    def vignette_strength(self, vignetteStrength:float) -> None:
        with agmarshall.DOUBLE_arg(vignetteStrength) as arg_vignetteStrength:
            agcls.evaluate_hresult(self.__dict__["_set_vignette_strength"](arg_vignetteStrength.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{a1b830ed-9742-4903-9773-1edbc40f0deb}", IVisualEffects)
agcls.AgTypeNameMap["IVisualEffects"] = IVisualEffects

class IAltitudeDisplayCondition(object):
    """Defines an inclusive altitude interval that determines when an object is rendered based on the camera's altitude relative to a central body."""
    _uuid = "{a6225aa6-608d-4ad8-b5f6-2afdd29b96f9}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_minimum_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_minimum_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_maximum_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_central_body"] = _raise_uninitialized_error
        self.__dict__["_set_central_body"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAltitudeDisplayCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAltitudeDisplayCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAltitudeDisplayCondition = agcom.GUID(IAltitudeDisplayCondition._uuid)
        vtable_offset_local = IAltitudeDisplayCondition._vtable_offset - 1
        self.__dict__["_get_minimum_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeDisplayCondition, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_minimum_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeDisplayCondition, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_maximum_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeDisplayCondition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_maximum_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeDisplayCondition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_central_body"] = IAGFUNCTYPE(pUnk, IID_IAltitudeDisplayCondition, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body"] = IAGFUNCTYPE(pUnk, IID_IAltitudeDisplayCondition, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAltitudeDisplayCondition.__dict__ and type(IAltitudeDisplayCondition.__dict__[attrname]) == property:
            return IAltitudeDisplayCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAltitudeDisplayCondition.")
    
    @property
    def minimum_altitude(self) -> float:
        """Gets or sets the minimum altitude of the inclusive altitude interval. Use Double.MinValue to ignore checking the minimum altitude."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_altitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @minimum_altitude.setter
    def minimum_altitude(self, minimumAltitude:float) -> None:
        with agmarshall.DOUBLE_arg(minimumAltitude) as arg_minimumAltitude:
            agcls.evaluate_hresult(self.__dict__["_set_minimum_altitude"](arg_minimumAltitude.COM_val))

    @property
    def maximum_altitude(self) -> float:
        """Gets or sets the maximum altitude of the inclusive altitude interval. Use Double.MaxValue to ignore checking the maximum altitude."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_altitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @maximum_altitude.setter
    def maximum_altitude(self, maximumAltitude:float) -> None:
        with agmarshall.DOUBLE_arg(maximumAltitude) as arg_maximumAltitude:
            agcls.evaluate_hresult(self.__dict__["_set_maximum_altitude"](arg_maximumAltitude.COM_val))

    @property
    def central_body(self) -> str:
        """Gets or sets the central body to which the altitude is relative."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_set_central_body"](arg_centralBody.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{a6225aa6-608d-4ad8-b5f6-2afdd29b96f9}", IAltitudeDisplayCondition)
agcls.AgTypeNameMap["IAltitudeDisplayCondition"] = IAltitudeDisplayCondition

class IAxesPrimitive(object):
    """Renders an axes in the 3D scene."""
    _uuid = "{8892fb91-4aa2-4663-9307-68a737163045}"
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_lighting"] = _raise_uninitialized_error
        self.__dict__["_set_lighting"] = _raise_uninitialized_error
        self.__dict__["_get_label"] = _raise_uninitialized_error
        self.__dict__["_set_label"] = _raise_uninitialized_error
        self.__dict__["_get_display_label"] = _raise_uninitialized_error
        self.__dict__["_set_display_label"] = _raise_uninitialized_error
        self.__dict__["_get_display_trace"] = _raise_uninitialized_error
        self.__dict__["_set_display_trace"] = _raise_uninitialized_error
        self.__dict__["_get_display_sweep"] = _raise_uninitialized_error
        self.__dict__["_set_display_sweep"] = _raise_uninitialized_error
        self.__dict__["_get_display_lines"] = _raise_uninitialized_error
        self.__dict__["_set_display_lines"] = _raise_uninitialized_error
        self.__dict__["_get_persistence_width"] = _raise_uninitialized_error
        self.__dict__["_set_persistence_width"] = _raise_uninitialized_error
        self.__dict__["_get_fade_persistence"] = _raise_uninitialized_error
        self.__dict__["_set_fade_persistence"] = _raise_uninitialized_error
        self.__dict__["_get_persistence_duration"] = _raise_uninitialized_error
        self.__dict__["_set_persistence_duration"] = _raise_uninitialized_error
        self.__dict__["_get_length"] = _raise_uninitialized_error
        self.__dict__["_set_length"] = _raise_uninitialized_error
        self.__dict__["_get_width"] = _raise_uninitialized_error
        self.__dict__["_set_width"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesPrimitive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesPrimitive from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesPrimitive = agcom.GUID(IAxesPrimitive._uuid)
        vtable_offset_local = IAxesPrimitive._vtable_offset - 1
        self.__dict__["_get_lighting"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_lighting"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_label"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_label"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_display_label"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_label"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_display_trace"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_trace"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_display_sweep"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_sweep"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_display_lines"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_lines"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_get_persistence_width"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_persistence_width"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_fade_persistence"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_fade_persistence"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_get_persistence_duration"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_persistence_duration"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_length"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_length"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_width"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_width"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitive, vtable_offset_local+22, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesPrimitive.__dict__ and type(IAxesPrimitive.__dict__[attrname]) == property:
            return IAxesPrimitive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesPrimitive.")
    
    @property
    def lighting(self) -> bool:
        """Gets or Sets whether the primitive is lit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_lighting"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @lighting.setter
    def lighting(self, lighting:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(lighting) as arg_lighting:
            agcls.evaluate_hresult(self.__dict__["_set_lighting"](arg_lighting.COM_val))

    @property
    def label(self) -> str:
        """Gets or Sets the axes label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_label"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @label.setter
    def label(self, label:str) -> None:
        with agmarshall.BSTR_arg(label) as arg_label:
            agcls.evaluate_hresult(self.__dict__["_set_label"](arg_label.COM_val))

    @property
    def display_label(self) -> bool:
        """Gets or Sets whether the axes' label is displayed."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_label"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_label.setter
    def display_label(self, displayLabel:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displayLabel) as arg_displayLabel:
            agcls.evaluate_hresult(self.__dict__["_set_display_label"](arg_displayLabel.COM_val))

    @property
    def display_trace(self) -> bool:
        """Gets or Sets whether the persistence trace (points) is displayed."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_trace"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_trace.setter
    def display_trace(self, displayTrace:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displayTrace) as arg_displayTrace:
            agcls.evaluate_hresult(self.__dict__["_set_display_trace"](arg_displayTrace.COM_val))

    @property
    def display_sweep(self) -> bool:
        """Gets or Sets whether the persistence sweep (triangles) is displayed."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_sweep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_sweep.setter
    def display_sweep(self, displaySweep:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displaySweep) as arg_displaySweep:
            agcls.evaluate_hresult(self.__dict__["_set_display_sweep"](arg_displaySweep.COM_val))

    @property
    def display_lines(self) -> bool:
        """Gets or Sets whether persistence lines are displayed."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_lines"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_lines.setter
    def display_lines(self, displayLines:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displayLines) as arg_displayLines:
            agcls.evaluate_hresult(self.__dict__["_set_display_lines"](arg_displayLines.COM_val))

    @property
    def persistence_width(self) -> float:
        """Gets or Sets persistence point/line width."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_persistence_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @persistence_width.setter
    def persistence_width(self, persistenceWidth:float) -> None:
        with agmarshall.DOUBLE_arg(persistenceWidth) as arg_persistenceWidth:
            agcls.evaluate_hresult(self.__dict__["_set_persistence_width"](arg_persistenceWidth.COM_val))

    @property
    def fade_persistence(self) -> bool:
        """Gets or Sets whether the persistence path should fade over time."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_fade_persistence"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @fade_persistence.setter
    def fade_persistence(self, fadePersistence:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(fadePersistence) as arg_fadePersistence:
            agcls.evaluate_hresult(self.__dict__["_set_fade_persistence"](arg_fadePersistence.COM_val))

    @property
    def persistence_duration(self) -> float:
        """Gets or Sets the maximum duration of the persistence path."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_persistence_duration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @persistence_duration.setter
    def persistence_duration(self, persistenceDuration:float) -> None:
        with agmarshall.DOUBLE_arg(persistenceDuration) as arg_persistenceDuration:
            agcls.evaluate_hresult(self.__dict__["_set_persistence_duration"](arg_persistenceDuration.COM_val))

    @property
    def length(self) -> float:
        """Gets or Sets the axes' source-to-arrow-tip length."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_length"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @length.setter
    def length(self, length:float) -> None:
        with agmarshall.DOUBLE_arg(length) as arg_length:
            agcls.evaluate_hresult(self.__dict__["_set_length"](arg_length.COM_val))

    @property
    def width(self) -> float:
        """Gets or Sets the width in pixels. As the camera distances changes from this primitive, the geometry will autoscale to maintain this thickness."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @width.setter
    def width(self, width:float) -> None:
        with agmarshall.DOUBLE_arg(width) as arg_width:
            agcls.evaluate_hresult(self.__dict__["_set_width"](arg_width.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8892fb91-4aa2-4663-9307-68a737163045}", IAxesPrimitive)
agcls.AgTypeNameMap["IAxesPrimitive"] = IAxesPrimitive

class ICamera(object):
    """Implemented by the scene camera. Contains operations to manipulate the camera position, view direction and orientation in the scene."""
    _uuid = "{c9a35fc4-8868-4b28-8622-13cfa470c315}"
    _num_methods = 50
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_position"] = _raise_uninitialized_error
        self.__dict__["_set_position"] = _raise_uninitialized_error
        self.__dict__["_get_reference_point"] = _raise_uninitialized_error
        self.__dict__["_set_reference_point"] = _raise_uninitialized_error
        self.__dict__["_get_direction"] = _raise_uninitialized_error
        self.__dict__["_set_direction"] = _raise_uninitialized_error
        self.__dict__["_get_up_vector"] = _raise_uninitialized_error
        self.__dict__["_set_up_vector"] = _raise_uninitialized_error
        self.__dict__["_get_distance"] = _raise_uninitialized_error
        self.__dict__["_set_distance"] = _raise_uninitialized_error
        self.__dict__["_get_axes"] = _raise_uninitialized_error
        self.__dict__["_set_axes"] = _raise_uninitialized_error
        self.__dict__["_get_constrained_up_axis"] = _raise_uninitialized_error
        self.__dict__["_set_constrained_up_axis"] = _raise_uninitialized_error
        self.__dict__["_get_allow_rotation_over_constrained_up_axis"] = _raise_uninitialized_error
        self.__dict__["_set_allow_rotation_over_constrained_up_axis"] = _raise_uninitialized_error
        self.__dict__["_get_lock_view_direction"] = _raise_uninitialized_error
        self.__dict__["_set_lock_view_direction"] = _raise_uninitialized_error
        self.__dict__["_get_field_of_view"] = _raise_uninitialized_error
        self.__dict__["_set_field_of_view"] = _raise_uninitialized_error
        self.__dict__["_get_horizontal_field_of_view"] = _raise_uninitialized_error
        self.__dict__["_get_vertical_field_of_view"] = _raise_uninitialized_error
        self.__dict__["_get_near_plane"] = _raise_uninitialized_error
        self.__dict__["_set_near_plane"] = _raise_uninitialized_error
        self.__dict__["_get_far_plane"] = _raise_uninitialized_error
        self.__dict__["_set_far_plane"] = _raise_uninitialized_error
        self.__dict__["_get_far_near_plane_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_far_near_plane_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_distance_per_radius"] = _raise_uninitialized_error
        self.__dict__["_get_snapshot"] = _raise_uninitialized_error
        self.__dict__["_get_video_recording"] = _raise_uninitialized_error
        self.__dict__["_get_pixel_size_per_distance"] = _raise_uninitialized_error
        self.__dict__["_get_position_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_get_reference_point_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_visibility_test"] = _raise_uninitialized_error
        self.__dict__["_cartographic_to_window"] = _raise_uninitialized_error
        self.__dict__["_try_cartographic_to_window"] = _raise_uninitialized_error
        self.__dict__["_window_to_cartographic"] = _raise_uninitialized_error
        self.__dict__["_try_window_to_cartographic"] = _raise_uninitialized_error
        self.__dict__["_view_central_body"] = _raise_uninitialized_error
        self.__dict__["_view_extent"] = _raise_uninitialized_error
        self.__dict__["_view_rectangular_extent"] = _raise_uninitialized_error
        self.__dict__["_view_with_up_axis"] = _raise_uninitialized_error
        self.__dict__["_view"] = _raise_uninitialized_error
        self.__dict__["_view_direction_with_up_axis"] = _raise_uninitialized_error
        self.__dict__["_view_direction"] = _raise_uninitialized_error
        self.__dict__["_view_offset_with_up_axis"] = _raise_uninitialized_error
        self.__dict__["_view_offset"] = _raise_uninitialized_error
        self.__dict__["_view_offset_direction_with_up_axis"] = _raise_uninitialized_error
        self.__dict__["_view_offset_direction"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICamera._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICamera from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICamera = agcom.GUID(ICamera._uuid)
        vtable_offset_local = ICamera._vtable_offset - 1
        self.__dict__["_get_position"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_position"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+2, agcom.SAFEARRAY)
        self.__dict__["_get_reference_point"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_reference_point"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+4, agcom.SAFEARRAY)
        self.__dict__["_get_direction"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_direction"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+6, agcom.SAFEARRAY)
        self.__dict__["_get_up_vector"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+7, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_up_vector"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+8, agcom.SAFEARRAY)
        self.__dict__["_get_distance"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_distance"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_axes"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_set_axes"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_get_constrained_up_axis"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_constrained_up_axis"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_allow_rotation_over_constrained_up_axis"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_allow_rotation_over_constrained_up_axis"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_get_lock_view_direction"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+17, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_lock_view_direction"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+18, agcom.VARIANT_BOOL)
        self.__dict__["_get_field_of_view"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_field_of_view"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_horizontal_field_of_view"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_get_vertical_field_of_view"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+22, POINTER(agcom.DOUBLE))
        self.__dict__["_get_near_plane"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_near_plane"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_far_plane"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_far_plane"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_far_near_plane_ratio"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_set_far_near_plane_ratio"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_get_distance_per_radius"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_get_snapshot"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+30, POINTER(agcom.PVOID))
        self.__dict__["_get_video_recording"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+31, POINTER(agcom.PVOID))
        self.__dict__["_get_pixel_size_per_distance"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+32, POINTER(agcom.DOUBLE))
        self.__dict__["_get_position_reference_frame"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+33, POINTER(agcom.PVOID))
        self.__dict__["_get_reference_point_reference_frame"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+34, POINTER(agcom.PVOID))
        self.__dict__["_visibility_test"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+35, agcom.PVOID, agcom.PVOID, POINTER(agcom.LONG))
        self.__dict__["_cartographic_to_window"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+36, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_try_cartographic_to_window"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+37, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_window_to_cartographic"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+38, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_try_window_to_cartographic"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+39, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_view_central_body"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+40, agcom.BSTR, agcom.PVOID)
        self.__dict__["_view_extent"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+41, agcom.BSTR, POINTER(agcom.SAFEARRAY))
        self.__dict__["_view_rectangular_extent"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+42, agcom.BSTR, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE)
        self.__dict__["_view_with_up_axis"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+43, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.SAFEARRAY))
        self.__dict__["_view"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+44, agcom.PVOID, agcom.PVOID, agcom.PVOID)
        self.__dict__["_view_direction_with_up_axis"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+45, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.SAFEARRAY))
        self.__dict__["_view_direction"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+46, agcom.PVOID, agcom.PVOID, agcom.PVOID)
        self.__dict__["_view_offset_with_up_axis"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+47, agcom.PVOID, agcom.PVOID, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_view_offset"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+48, agcom.PVOID, agcom.PVOID, POINTER(agcom.SAFEARRAY))
        self.__dict__["_view_offset_direction_with_up_axis"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+49, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.SAFEARRAY))
        self.__dict__["_view_offset_direction"] = IAGFUNCTYPE(pUnk, IID_ICamera, vtable_offset_local+50, agcom.PVOID, agcom.PVOID, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICamera.__dict__ and type(ICamera.__dict__[attrname]) == property:
            return ICamera.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICamera.")
    
    @property
    def position(self) -> list:
        """Gets or sets the position of the camera. The array contains the components of the position arranged in the order x, y, z."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @position.setter
    def position(self, position:list) -> None:
        with agmarshall.SAFEARRAY_arg(position) as arg_position:
            agcls.evaluate_hresult(self.__dict__["_set_position"](arg_position.COM_val))

    @property
    def reference_point(self) -> list:
        """Gets or sets the reference point of the camera. The array contains the components of the reference point arranged in the order x, y, z."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_point"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @reference_point.setter
    def reference_point(self, referencePoint:list) -> None:
        with agmarshall.SAFEARRAY_arg(referencePoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_set_reference_point"](arg_referencePoint.COM_val))

    @property
    def direction(self) -> list:
        """Gets or sets the direction of the camera in axes. The array contains the components of the direction arranged in the order x, y, z."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_direction"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @direction.setter
    def direction(self, direction:list) -> None:
        with agmarshall.SAFEARRAY_arg(direction) as arg_direction:
            agcls.evaluate_hresult(self.__dict__["_set_direction"](arg_direction.COM_val))

    @property
    def up_vector(self) -> list:
        """Gets or sets the up direction of the camera in axes. The array contains the components of the direction arranged in the order x, y, z."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_up_vector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @up_vector.setter
    def up_vector(self, upVector:list) -> None:
        with agmarshall.SAFEARRAY_arg(upVector) as arg_upVector:
            agcls.evaluate_hresult(self.__dict__["_set_up_vector"](arg_upVector.COM_val))

    @property
    def distance(self) -> float:
        """Gets or sets the distance the camera position is from the reference point."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_distance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @distance.setter
    def distance(self, distance:float) -> None:
        with agmarshall.DOUBLE_arg(distance) as arg_distance:
            agcls.evaluate_hresult(self.__dict__["_set_distance"](arg_distance.COM_val))

    @property
    def axes(self) -> "IVectorGeometryToolAxes":
        """Gets or sets camera's axes of rotation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_axes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @axes.setter
    def axes(self, axes:"IVectorGeometryToolAxes") -> None:
        with agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes:
            agcls.evaluate_hresult(self.__dict__["_set_axes"](arg_axes.COM_val))

    @property
    def constrained_up_axis(self) -> "AgEStkGraphicsConstrainedUpAxis":
        """Gets or sets the axis to constrain the up vector to."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsConstrainedUpAxis) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_constrained_up_axis"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @constrained_up_axis.setter
    def constrained_up_axis(self, constrainedUpAxis:"AgEStkGraphicsConstrainedUpAxis") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsConstrainedUpAxis, constrainedUpAxis) as arg_constrainedUpAxis:
            agcls.evaluate_hresult(self.__dict__["_set_constrained_up_axis"](arg_constrainedUpAxis.COM_val))

    @property
    def allow_rotation_over_constrained_up_axis(self) -> bool:
        """Gets or sets whether the camera can rotate over the constrained up axis. For example, if true the camera would be able to flip over the North Pole and view the globe upside down."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_allow_rotation_over_constrained_up_axis"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @allow_rotation_over_constrained_up_axis.setter
    def allow_rotation_over_constrained_up_axis(self, allowRotationOverConstrainedUpAxis:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(allowRotationOverConstrainedUpAxis) as arg_allowRotationOverConstrainedUpAxis:
            agcls.evaluate_hresult(self.__dict__["_set_allow_rotation_over_constrained_up_axis"](arg_allowRotationOverConstrainedUpAxis.COM_val))

    @property
    def lock_view_direction(self) -> bool:
        """Gets or sets whether the camera's direction is locked."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_lock_view_direction"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @lock_view_direction.setter
    def lock_view_direction(self, lockViewDirection:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(lockViewDirection) as arg_lockViewDirection:
            agcls.evaluate_hresult(self.__dict__["_set_lock_view_direction"](arg_lockViewDirection.COM_val))

    @property
    def field_of_view(self) -> float:
        """Gets or sets field of view. The field of view is applied to the larger of the window dimensions. For example, if the window width was 640 and the height was 480, the field of view applies to the horizontal..."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_field_of_view"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @field_of_view.setter
    def field_of_view(self, fieldOfView:float) -> None:
        with agmarshall.DOUBLE_arg(fieldOfView) as arg_fieldOfView:
            agcls.evaluate_hresult(self.__dict__["_set_field_of_view"](arg_fieldOfView.COM_val))

    @property
    def horizontal_field_of_view(self) -> float:
        """Gets the horizontal field of view."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_horizontal_field_of_view"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def vertical_field_of_view(self) -> float:
        """Gets the vertical field of view."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_vertical_field_of_view"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def near_plane(self) -> float:
        """Gets or sets the distance from the camera to the near plane."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_near_plane"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @near_plane.setter
    def near_plane(self, nearPlane:float) -> None:
        with agmarshall.DOUBLE_arg(nearPlane) as arg_nearPlane:
            agcls.evaluate_hresult(self.__dict__["_set_near_plane"](arg_nearPlane.COM_val))

    @property
    def far_plane(self) -> float:
        """Gets or sets the distance from the camera to the far plane."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_far_plane"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @far_plane.setter
    def far_plane(self, farPlane:float) -> None:
        with agmarshall.DOUBLE_arg(farPlane) as arg_farPlane:
            agcls.evaluate_hresult(self.__dict__["_set_far_plane"](arg_farPlane.COM_val))

    @property
    def far_near_plane_ratio(self) -> float:
        """Gets or sets the value that is used to compute subdivisions of the viewing frustum. A large value will be faster but lose z-value precision. A small value will have better precision but perform slower..."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_far_near_plane_ratio"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @far_near_plane_ratio.setter
    def far_near_plane_ratio(self, farNearPlaneRatio:float) -> None:
        with agmarshall.DOUBLE_arg(farNearPlaneRatio) as arg_farNearPlaneRatio:
            agcls.evaluate_hresult(self.__dict__["_set_far_near_plane_ratio"](arg_farNearPlaneRatio.COM_val))

    @property
    def distance_per_radius(self) -> float:
        """Returns the distance that the Camera's Position should be from the ReferencePoint in order to ensure that a sphere with a 1 meter radius centered at the ReferencePoint fits entirely in the view frustum."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_distance_per_radius"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def snapshot(self) -> "ICameraSnapshot":
        """Gets the camera snapshot settings."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_snapshot"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def video_recording(self) -> "ICameraVideoRecording":
        """Gets the camera video recorder."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_video_recording"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def pixel_size_per_distance(self) -> float:
        """Gets the approximate number of meters covered by a pixel that is 1 meter away from the camera. This is commonly multiplied by the distance from the camera to an object to compute the approximate number of meters covered by a pixel of the object."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_pixel_size_per_distance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def position_reference_frame(self) -> "IVectorGeometryToolSystem":
        """Gets the reference frame that the position is returned in. This reference frame is composed of the camera's from point and the axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position_reference_frame"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def reference_point_reference_frame(self) -> "IVectorGeometryToolSystem":
        """Gets the reference frame that the reference point is returned in. This reference frame is composed of the camera's to point and the axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_point_reference_frame"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def visibility_test(self, referenceFrame:"IVectorGeometryToolSystem", sphere:"IBoundingSphere") -> "AgEStkGraphicsVisibility":
        """Gets the visibility of a sphere against the view frustum and any occluding central bodies."""
        with agmarshall.AgInterface_in_arg(referenceFrame, IVectorGeometryToolSystem) as arg_referenceFrame, \
             agmarshall.AgInterface_in_arg(sphere, IBoundingSphere) as arg_sphere, \
             agmarshall.AgEnum_arg(AgEStkGraphicsVisibility) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_visibility_test"](arg_referenceFrame.COM_val, arg_sphere.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def cartographic_to_window(self, centralBody:str, position:list) -> list:
        """Converts a cartographic position to a pixel coordinate relative to the globe control. This method can throw an exception. Returns an array containing the pixel coordinate (in the order x, y) of the cartographic position relative to the globe control..."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(position) as arg_position, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_cartographic_to_window"](arg_centralBody.COM_val, byref(arg_position.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def try_cartographic_to_window(self, centralBody:str, position:list) -> list:
        """Converts a cartographic position to a pixel coordinate relative to the globe control. This method does not throw an exception."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(position) as arg_position, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_try_cartographic_to_window"](arg_centralBody.COM_val, byref(arg_position.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def window_to_cartographic(self, centralBody:str, position:list) -> list:
        """Converts a pixel coordinate relative to the globe control to a cartographic position. For speed, terrain is not considered; if the pixel coordinate does not intersect the ellipsoid, an exception is thrown. Returns the cartographic position..."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(position) as arg_position, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_window_to_cartographic"](arg_centralBody.COM_val, byref(arg_position.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def try_window_to_cartographic(self, centralBody:str, position:list) -> list:
        """Converts a pixel coordinate relative to the globe control to a cartographic position. For speed, terrain is not considered. This method does not throw an exception."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(position) as arg_position, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_try_window_to_cartographic"](arg_centralBody.COM_val, byref(arg_position.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def view_central_body(self, centralBody:str, axes:"IVectorGeometryToolAxes") -> None:
        """Zoom to a central body and use the specified axes for rotation. The reference point is set to the center of the central body and the camera's position is set so the entire central body is visible."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes:
            agcls.evaluate_hresult(self.__dict__["_view_central_body"](arg_centralBody.COM_val, arg_axes.COM_val))

    def view_extent(self, centralBody:str, extent:list) -> None:
        """Zooms to a cartographic extent on the centralBody. The camera will be looking straight down at the extent, with the up vector pointing toward local north. The axes is set to an east-north-up axes at the center of extent."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(extent) as arg_extent:
            agcls.evaluate_hresult(self.__dict__["_view_extent"](arg_centralBody.COM_val, byref(arg_extent.COM_val)))

    def view_rectangular_extent(self, centralBody:str, west:float, south:float, east:float, north:float) -> None:
        """Zooms to a rectangular extent composed of west, south, east, north on the centralBody. The camera will be looking straight down at the extent, with the up vector pointing toward local north..."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.DOUBLE_arg(west) as arg_west, \
             agmarshall.DOUBLE_arg(south) as arg_south, \
             agmarshall.DOUBLE_arg(east) as arg_east, \
             agmarshall.DOUBLE_arg(north) as arg_north:
            agcls.evaluate_hresult(self.__dict__["_view_rectangular_extent"](arg_centralBody.COM_val, arg_west.COM_val, arg_south.COM_val, arg_east.COM_val, arg_north.COM_val))

    def view_with_up_axis(self, axes:"IVectorGeometryToolAxes", cameraPosition:"IVectorGeometryToolPoint", referencePoint:"IVectorGeometryToolPoint", upAxis:list) -> None:
        """Views from a point to a point. Sets the camera's position and the reference point the camera is looking at."""
        with agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_in_arg(cameraPosition, IVectorGeometryToolPoint) as arg_cameraPosition, \
             agmarshall.AgInterface_in_arg(referencePoint, IVectorGeometryToolPoint) as arg_referencePoint, \
             agmarshall.SAFEARRAY_arg(upAxis) as arg_upAxis:
            agcls.evaluate_hresult(self.__dict__["_view_with_up_axis"](arg_axes.COM_val, arg_cameraPosition.COM_val, arg_referencePoint.COM_val, byref(arg_upAxis.COM_val)))

    def view(self, axes:"IVectorGeometryToolAxes", cameraPosition:"IVectorGeometryToolPoint", referencePoint:"IVectorGeometryToolPoint") -> None:
        """Views from a point to a point. Sets the camera's position and the reference point the camera is looking at."""
        with agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_in_arg(cameraPosition, IVectorGeometryToolPoint) as arg_cameraPosition, \
             agmarshall.AgInterface_in_arg(referencePoint, IVectorGeometryToolPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_view"](arg_axes.COM_val, arg_cameraPosition.COM_val, arg_referencePoint.COM_val))

    def view_direction_with_up_axis(self, axes:"IVectorGeometryToolAxes", cameraPosition:"IVectorGeometryToolPoint", direction:"IVectorGeometryToolVector", upAxis:list) -> None:
        """Views from a point to a direction. Sets the camera's position and the direction vector indicating where the camera is looking."""
        with agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_in_arg(cameraPosition, IVectorGeometryToolPoint) as arg_cameraPosition, \
             agmarshall.AgInterface_in_arg(direction, IVectorGeometryToolVector) as arg_direction, \
             agmarshall.SAFEARRAY_arg(upAxis) as arg_upAxis:
            agcls.evaluate_hresult(self.__dict__["_view_direction_with_up_axis"](arg_axes.COM_val, arg_cameraPosition.COM_val, arg_direction.COM_val, byref(arg_upAxis.COM_val)))

    def view_direction(self, axes:"IVectorGeometryToolAxes", cameraPosition:"IVectorGeometryToolPoint", direction:"IVectorGeometryToolVector") -> None:
        """Views from a point to a direction. Sets the camera's position and the direction vector indicating where the camera is looking."""
        with agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_in_arg(cameraPosition, IVectorGeometryToolPoint) as arg_cameraPosition, \
             agmarshall.AgInterface_in_arg(direction, IVectorGeometryToolVector) as arg_direction:
            agcls.evaluate_hresult(self.__dict__["_view_direction"](arg_axes.COM_val, arg_cameraPosition.COM_val, arg_direction.COM_val))

    def view_offset_with_up_axis(self, axes:"IVectorGeometryToolAxes", referencePoint:"IVectorGeometryToolPoint", offset:list, upAxis:list) -> None:
        """Sets the camera's reference point - the point the camera is looking at. The camera's position is the reference point translated by the offset."""
        with agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_in_arg(referencePoint, IVectorGeometryToolPoint) as arg_referencePoint, \
             agmarshall.SAFEARRAY_arg(offset) as arg_offset, \
             agmarshall.SAFEARRAY_arg(upAxis) as arg_upAxis:
            agcls.evaluate_hresult(self.__dict__["_view_offset_with_up_axis"](arg_axes.COM_val, arg_referencePoint.COM_val, byref(arg_offset.COM_val), byref(arg_upAxis.COM_val)))

    def view_offset(self, axes:"IVectorGeometryToolAxes", referencePoint:"IVectorGeometryToolPoint", offset:list) -> None:
        """Sets the camera's reference point - the point the camera is looking at. The camera's position is the reference point translated by the offset."""
        with agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_in_arg(referencePoint, IVectorGeometryToolPoint) as arg_referencePoint, \
             agmarshall.SAFEARRAY_arg(offset) as arg_offset:
            agcls.evaluate_hresult(self.__dict__["_view_offset"](arg_axes.COM_val, arg_referencePoint.COM_val, byref(arg_offset.COM_val)))

    def view_offset_direction_with_up_axis(self, axes:"IVectorGeometryToolAxes", referencePoint:"IVectorGeometryToolPoint", direction:"IVectorGeometryToolVector", upAxis:list) -> None:
        """Sets the camera's reference point - the point the camera is looking at. The camera's position is the reference point translated by the direction vector."""
        with agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_in_arg(referencePoint, IVectorGeometryToolPoint) as arg_referencePoint, \
             agmarshall.AgInterface_in_arg(direction, IVectorGeometryToolVector) as arg_direction, \
             agmarshall.SAFEARRAY_arg(upAxis) as arg_upAxis:
            agcls.evaluate_hresult(self.__dict__["_view_offset_direction_with_up_axis"](arg_axes.COM_val, arg_referencePoint.COM_val, arg_direction.COM_val, byref(arg_upAxis.COM_val)))

    def view_offset_direction(self, axes:"IVectorGeometryToolAxes", referencePoint:"IVectorGeometryToolPoint", direction:"IVectorGeometryToolVector") -> None:
        """Sets the camera's reference point - the point the camera is looking at. The camera's position is the reference point translated by the direction vector."""
        with agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_in_arg(referencePoint, IVectorGeometryToolPoint) as arg_referencePoint, \
             agmarshall.AgInterface_in_arg(direction, IVectorGeometryToolVector) as arg_direction:
            agcls.evaluate_hresult(self.__dict__["_view_offset_direction"](arg_axes.COM_val, arg_referencePoint.COM_val, arg_direction.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{c9a35fc4-8868-4b28-8622-13cfa470c315}", ICamera)
agcls.AgTypeNameMap["ICamera"] = ICamera

class ICentralBodyGraphics(object):
    """The graphical properties associated with a particular central body. Changing the central body graphics will affect how the associated central body is rendered in a scene. For instance, to show or hide the central body, use the show property..."""
    _uuid = "{27f5d32b-5adf-4fc7-a8b8-83ada5ebc0ca}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_color"] = _raise_uninitialized_error
        self.__dict__["_set_color"] = _raise_uninitialized_error
        self.__dict__["_get_specular_color"] = _raise_uninitialized_error
        self.__dict__["_set_specular_color"] = _raise_uninitialized_error
        self.__dict__["_get_shininess"] = _raise_uninitialized_error
        self.__dict__["_set_shininess"] = _raise_uninitialized_error
        self.__dict__["_get_show_imagery"] = _raise_uninitialized_error
        self.__dict__["_set_show_imagery"] = _raise_uninitialized_error
        self.__dict__["_get_show"] = _raise_uninitialized_error
        self.__dict__["_set_show"] = _raise_uninitialized_error
        self.__dict__["_get_show_label"] = _raise_uninitialized_error
        self.__dict__["_set_show_label"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_get_base_overlay"] = _raise_uninitialized_error
        self.__dict__["_set_base_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_night_overlay"] = _raise_uninitialized_error
        self.__dict__["_set_night_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_specular_overlay"] = _raise_uninitialized_error
        self.__dict__["_set_specular_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_terrain"] = _raise_uninitialized_error
        self.__dict__["_get_imagery"] = _raise_uninitialized_error
        self.__dict__["_get_kml"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyGraphics._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyGraphics from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICentralBodyGraphics = agcom.GUID(ICentralBodyGraphics._uuid)
        vtable_offset_local = ICentralBodyGraphics._vtable_offset - 1
        self.__dict__["_get_color"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+1, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_color"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+2, agcom.OLE_COLOR)
        self.__dict__["_get_specular_color"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+3, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_specular_color"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+4, agcom.OLE_COLOR)
        self.__dict__["_get_shininess"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_shininess"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_show_imagery"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show_imagery"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_show"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_show_label"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show_label"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_get_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_base_overlay"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_set_base_overlay"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+16, agcom.PVOID)
        self.__dict__["_get_night_overlay"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_set_night_overlay"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+18, agcom.PVOID)
        self.__dict__["_get_specular_overlay"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+19, POINTER(agcom.PVOID))
        self.__dict__["_set_specular_overlay"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+20, agcom.PVOID)
        self.__dict__["_get_terrain"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+21, POINTER(agcom.PVOID))
        self.__dict__["_get_imagery"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+22, POINTER(agcom.PVOID))
        self.__dict__["_get_kml"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGraphics, vtable_offset_local+23, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyGraphics.__dict__ and type(ICentralBodyGraphics.__dict__[attrname]) == property:
            return ICentralBodyGraphics.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICentralBodyGraphics.")
    
    @property
    def color(self) -> agcolor.Color:
        """Gets or sets the color of the central body in the scene."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @color.setter
    def color(self, color:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(color) as arg_color:
            agcls.evaluate_hresult(self.__dict__["_set_color"](arg_color.COM_val))

    @property
    def specular_color(self) -> agcolor.Color:
        """Gets or sets the specular color of the central body in the scene. The specular color is associated with the specular overlay."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_specular_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @specular_color.setter
    def specular_color(self, specularColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(specularColor) as arg_specularColor:
            agcls.evaluate_hresult(self.__dict__["_set_specular_color"](arg_specularColor.COM_val))

    @property
    def shininess(self) -> float:
        """Gets or sets the shininess of the central body in the scene. The shininess affects the size and brightness of specular reflection associated with the specular overlay."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_shininess"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @shininess.setter
    def shininess(self, shininess:float) -> None:
        with agmarshall.DOUBLE_arg(shininess) as arg_shininess:
            agcls.evaluate_hresult(self.__dict__["_set_shininess"](arg_shininess.COM_val))

    @property
    def show_imagery(self) -> bool:
        """Gets or sets whether the imagery for central body in the scene is shown or hidden."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_show_imagery"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @show_imagery.setter
    def show_imagery(self, showImagery:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(showImagery) as arg_showImagery:
            agcls.evaluate_hresult(self.__dict__["_set_show_imagery"](arg_showImagery.COM_val))

    @property
    def show(self) -> bool:
        """Gets or sets whether the central body is shown or hidden in the scene. This only affects the central body itself, not the primitives that are associated with it."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_show"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @show.setter
    def show(self, show:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(show) as arg_show:
            agcls.evaluate_hresult(self.__dict__["_set_show"](arg_show.COM_val))

    @property
    def show_label(self) -> bool:
        """Gets or sets whether a label with the name of the central body should be rendered in the scene when the camera is at certain distance away from the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_show_label"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @show_label.setter
    def show_label(self, showLabel:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(showLabel) as arg_showLabel:
            agcls.evaluate_hresult(self.__dict__["_set_show_label"](arg_showLabel.COM_val))

    @property
    def altitude_offset(self) -> float:
        """Gets or sets the altitude that all terrain and imagery will be offset from the surface of the central body in the scene."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_offset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @altitude_offset.setter
    def altitude_offset(self, altitudeOffset:float) -> None:
        with agmarshall.DOUBLE_arg(altitudeOffset) as arg_altitudeOffset:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_offset"](arg_altitudeOffset.COM_val))

    @property
    def base_overlay(self) -> "IGlobeImageOverlay":
        """Gets or sets the base globe image overlay associated with the central body in the scene. The base overlay is always rendered before any other imagery..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_base_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @base_overlay.setter
    def base_overlay(self, baseOverlay:"IGlobeImageOverlay") -> None:
        with agmarshall.AgInterface_in_arg(baseOverlay, IGlobeImageOverlay) as arg_baseOverlay:
            agcls.evaluate_hresult(self.__dict__["_set_base_overlay"](arg_baseOverlay.COM_val))

    @property
    def night_overlay(self) -> "IGlobeImageOverlay":
        """Gets or sets the night globe image overlay associated with the central body in the scene. The night overlay is displayed only on parts of the central body that are not in sun light..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_night_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @night_overlay.setter
    def night_overlay(self, nightOverlay:"IGlobeImageOverlay") -> None:
        with agmarshall.AgInterface_in_arg(nightOverlay, IGlobeImageOverlay) as arg_nightOverlay:
            agcls.evaluate_hresult(self.__dict__["_set_night_overlay"](arg_nightOverlay.COM_val))

    @property
    def specular_overlay(self) -> "IGlobeImageOverlay":
        """Gets or sets the specular globe image overlay associated with the central body in the scene. The specular overlay is displayed only in the specular highlight of the central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_specular_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @specular_overlay.setter
    def specular_overlay(self, specularOverlay:"IGlobeImageOverlay") -> None:
        with agmarshall.AgInterface_in_arg(specularOverlay, IGlobeImageOverlay) as arg_specularOverlay:
            agcls.evaluate_hresult(self.__dict__["_set_specular_overlay"](arg_specularOverlay.COM_val))

    @property
    def terrain(self) -> "ITerrainOverlayCollection":
        """Gets the collection of terrain overlay associated with the central body in the scene."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_terrain"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def imagery(self) -> "IImageCollection":
        """Gets the collection of imagery associated with the central body in the scene."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_imagery"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def kml(self) -> "IKmlGraphics":
        """Gets the kml graphics associated with the central body in the scene."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_kml"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{27f5d32b-5adf-4fc7-a8b8-83ada5ebc0ca}", ICentralBodyGraphics)
agcls.AgTypeNameMap["ICentralBodyGraphics"] = ICentralBodyGraphics

class IClouds(object):
    """Load, show and hide clouds in the scene."""
    _uuid = "{0f5265b8-2d96-440a-9b86-522d90bf2bc3}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_show"] = _raise_uninitialized_error
        self.__dict__["_set_show"] = _raise_uninitialized_error
        self.__dict__["_get_clouds_uri"] = _raise_uninitialized_error
        self.__dict__["_set_clouds_uri"] = _raise_uninitialized_error
        self.__dict__["_get_roundness"] = _raise_uninitialized_error
        self.__dict__["_set_roundness"] = _raise_uninitialized_error
        self.__dict__["_get_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_is_valid"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IClouds._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IClouds from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IClouds = agcom.GUID(IClouds._uuid)
        vtable_offset_local = IClouds._vtable_offset - 1
        self.__dict__["_get_show"] = IAGFUNCTYPE(pUnk, IID_IClouds, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show"] = IAGFUNCTYPE(pUnk, IID_IClouds, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_clouds_uri"] = IAGFUNCTYPE(pUnk, IID_IClouds, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_clouds_uri"] = IAGFUNCTYPE(pUnk, IID_IClouds, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_roundness"] = IAGFUNCTYPE(pUnk, IID_IClouds, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_roundness"] = IAGFUNCTYPE(pUnk, IID_IClouds, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_altitude"] = IAGFUNCTYPE(pUnk, IID_IClouds, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude"] = IAGFUNCTYPE(pUnk, IID_IClouds, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_is_valid"] = IAGFUNCTYPE(pUnk, IID_IClouds, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IClouds.__dict__ and type(IClouds.__dict__[attrname]) == property:
            return IClouds.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IClouds.")
    
    @property
    def show(self) -> bool:
        """Gets or sets whether clouds are rendered."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_show"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @show.setter
    def show(self, show:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(show) as arg_show:
            agcls.evaluate_hresult(self.__dict__["_set_show"](arg_show.COM_val))

    @property
    def clouds_uri(self) -> str:
        """The URI of the clouds index file. A cloud index file is an ascii file that contains a time-ordered list of images that display over the globe."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_clouds_uri"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @clouds_uri.setter
    def clouds_uri(self, cloudsUri:str) -> None:
        with agmarshall.BSTR_arg(cloudsUri) as arg_cloudsUri:
            agcls.evaluate_hresult(self.__dict__["_set_clouds_uri"](arg_cloudsUri.COM_val))

    @property
    def roundness(self) -> float:
        """The roundness of the clouds."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_roundness"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @roundness.setter
    def roundness(self, roundness:float) -> None:
        with agmarshall.DOUBLE_arg(roundness) as arg_roundness:
            agcls.evaluate_hresult(self.__dict__["_set_roundness"](arg_roundness.COM_val))

    @property
    def altitude(self) -> float:
        """The altitude of the clouds."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @altitude.setter
    def altitude(self, altitude:float) -> None:
        with agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__["_set_altitude"](arg_altitude.COM_val))

    @property
    def is_valid(self) -> bool:
        """Returns whether or not the clouds file is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_valid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{0f5265b8-2d96-440a-9b86-522d90bf2bc3}", IClouds)
agcls.AgTypeNameMap["IClouds"] = IClouds

class ICompositeDisplayCondition(object):
    """A composite of display conditions combined using a binary logic operation. For example, several time interval display condition objects can be added to a composite..."""
    _uuid = "{afe0e66f-0fc5-46ad-801f-22670cfe99a9}"
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_capacity"] = _raise_uninitialized_error
        self.__dict__["_get_logic_operation"] = _raise_uninitialized_error
        self.__dict__["_set_logic_operation"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_reserve"] = _raise_uninitialized_error
        self.__dict__["_add_with_negate"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_insert_with_negate"] = _raise_uninitialized_error
        self.__dict__["_insert"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_remove_at"] = _raise_uninitialized_error
        self.__dict__["_clear"] = _raise_uninitialized_error
        self.__dict__["_get_negate"] = _raise_uninitialized_error
        self.__dict__["_set_negate"] = _raise_uninitialized_error
        self.__dict__["_get_negate_at"] = _raise_uninitialized_error
        self.__dict__["_set_negate_at"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICompositeDisplayCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICompositeDisplayCondition from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICompositeDisplayCondition = agcom.GUID(ICompositeDisplayCondition._uuid)
        vtable_offset_local = ICompositeDisplayCondition._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_get_capacity"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+2, POINTER(agcom.INT))
        self.__dict__["_get_logic_operation"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_logic_operation"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+5, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_reserve"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+7, agcom.INT)
        self.__dict__["_add_with_negate"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+8, agcom.PVOID, agcom.VARIANT_BOOL)
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+9, agcom.PVOID)
        self.__dict__["_insert_with_negate"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+10, agcom.INT, agcom.PVOID, agcom.VARIANT_BOOL)
        self.__dict__["_insert"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+11, agcom.INT, agcom.PVOID)
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_remove_at"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+13, agcom.INT)
        self.__dict__["_clear"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+14, )
        self.__dict__["_get_negate"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+15, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_negate"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+16, agcom.PVOID, agcom.VARIANT_BOOL)
        self.__dict__["_get_negate_at"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+17, agcom.INT, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_negate_at"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayCondition, vtable_offset_local+18, agcom.INT, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICompositeDisplayCondition.__dict__ and type(ICompositeDisplayCondition.__dict__[attrname]) == property:
            return ICompositeDisplayCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICompositeDisplayCondition.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IDisplayCondition":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """Gets the number of display conditions in the composite."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def capacity(self) -> int:
        """Gets the number of display conditions for which memory has been allocated. This will always be greater or equal to count."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_capacity"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def logic_operation(self) -> "AgEStkGraphicsBinaryLogicOperation":
        """Gets or sets the binary logic operation applied to all display conditions in the composite when the composite is evaluated. To combine logical and and or operations in the same expression, create composites containing composites."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsBinaryLogicOperation) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_logic_operation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @logic_operation.setter
    def logic_operation(self, logicOperation:"AgEStkGraphicsBinaryLogicOperation") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsBinaryLogicOperation, logicOperation) as arg_logicOperation:
            agcls.evaluate_hresult(self.__dict__["_set_logic_operation"](arg_logicOperation.COM_val))

    def item(self, index:int) -> "IDisplayCondition":
        """Returns the condition at the given zero-based index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns an enumerator that iterates through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def reserve(self, count:int) -> None:
        """Requests enough memory for the composite to contain at least count display conditions. count will not be affected but capacity may be."""
        with agmarshall.INT_arg(count) as arg_count:
            agcls.evaluate_hresult(self.__dict__["_reserve"](arg_count.COM_val))

    def add_with_negate(self, displayCondition:"IDisplayCondition", negate:bool) -> None:
        """Adds a display condition to the end of the composite."""
        with agmarshall.AgInterface_in_arg(displayCondition, IDisplayCondition) as arg_displayCondition, \
             agmarshall.VARIANT_BOOL_arg(negate) as arg_negate:
            agcls.evaluate_hresult(self.__dict__["_add_with_negate"](arg_displayCondition.COM_val, arg_negate.COM_val))

    def add(self, displayCondition:"IDisplayCondition") -> None:
        """Adds a display condition to the end of the composite."""
        with agmarshall.AgInterface_in_arg(displayCondition, IDisplayCondition) as arg_displayCondition:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_displayCondition.COM_val))

    def insert_with_negate(self, index:int, displayCondition:"IDisplayCondition", negate:bool) -> None:
        """Inserts a display condition at the given zero-based index, shifting existing display conditions."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_in_arg(displayCondition, IDisplayCondition) as arg_displayCondition, \
             agmarshall.VARIANT_BOOL_arg(negate) as arg_negate:
            agcls.evaluate_hresult(self.__dict__["_insert_with_negate"](arg_index.COM_val, arg_displayCondition.COM_val, arg_negate.COM_val))

    def insert(self, index:int, displayCondition:"IDisplayCondition") -> None:
        """Inserts a display condition at the given zero-based index, shifting existing display conditions."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_in_arg(displayCondition, IDisplayCondition) as arg_displayCondition:
            agcls.evaluate_hresult(self.__dict__["_insert"](arg_index.COM_val, arg_displayCondition.COM_val))

    def remove(self, displayCondition:"IDisplayCondition") -> None:
        """Removes a display condition from the composite."""
        with agmarshall.AgInterface_in_arg(displayCondition, IDisplayCondition) as arg_displayCondition:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_displayCondition.COM_val))

    def remove_at(self, index:int) -> None:
        """Removes the display condition at the given zero-based index, shifting existing display conditions."""
        with agmarshall.INT_arg(index) as arg_index:
            agcls.evaluate_hresult(self.__dict__["_remove_at"](arg_index.COM_val))

    def clear(self) -> None:
        """Removes all display conditions from the composite."""
        agcls.evaluate_hresult(self.__dict__["_clear"]())

    def get_negate(self, displayCondition:"IDisplayCondition") -> bool:
        """Determines if a logical not operation is applied to a display condition in the composite."""
        with agmarshall.AgInterface_in_arg(displayCondition, IDisplayCondition) as arg_displayCondition, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_negate"](arg_displayCondition.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def set_negate(self, displayCondition:"IDisplayCondition", negate:bool) -> None:
        """Sets if a logical not operation is applied to a display condition in the composite when the composite is evaluated."""
        with agmarshall.AgInterface_in_arg(displayCondition, IDisplayCondition) as arg_displayCondition, \
             agmarshall.VARIANT_BOOL_arg(negate) as arg_negate:
            agcls.evaluate_hresult(self.__dict__["_set_negate"](arg_displayCondition.COM_val, arg_negate.COM_val))

    def get_negate_at(self, index:int) -> bool:
        """Determines if a logical not operation is applied to a display condition in the composite."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_negate_at"](arg_index.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def set_negate_at(self, index:int, negate:bool) -> None:
        """Sets if a logical not operation is applied to a display condition in the composite when the composite is evaluated."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.VARIANT_BOOL_arg(negate) as arg_negate:
            agcls.evaluate_hresult(self.__dict__["_set_negate_at"](arg_index.COM_val, arg_negate.COM_val))

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{afe0e66f-0fc5-46ad-801f-22670cfe99a9}", ICompositeDisplayCondition)
agcls.AgTypeNameMap["ICompositeDisplayCondition"] = ICompositeDisplayCondition

class ICompositePrimitive(object):
    """ A primitive that is composed of multiple other primitives. Since composites can contain other composites, they are commonly used to build hierarchies of primitives to efficiently evaluate display conditions..."""
    _uuid = "{c24448a9-4fe7-4905-86e0-70a71346fcf2}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_translucent_primitives_sort_order"] = _raise_uninitialized_error
        self.__dict__["_set_translucent_primitives_sort_order"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_contains"] = _raise_uninitialized_error
        self.__dict__["_clear"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICompositePrimitive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICompositePrimitive from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICompositePrimitive = agcom.GUID(ICompositePrimitive._uuid)
        vtable_offset_local = ICompositePrimitive._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ICompositePrimitive, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_get_translucent_primitives_sort_order"] = IAGFUNCTYPE(pUnk, IID_ICompositePrimitive, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_set_translucent_primitives_sort_order"] = IAGFUNCTYPE(pUnk, IID_ICompositePrimitive, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_ICompositePrimitive, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_ICompositePrimitive, vtable_offset_local+5, agcom.PVOID)
        self.__dict__["_contains"] = IAGFUNCTYPE(pUnk, IID_ICompositePrimitive, vtable_offset_local+6, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_clear"] = IAGFUNCTYPE(pUnk, IID_ICompositePrimitive, vtable_offset_local+7, )
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICompositePrimitive, vtable_offset_local+8, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICompositePrimitive.__dict__ and type(ICompositePrimitive.__dict__[attrname]) == property:
            return ICompositePrimitive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICompositePrimitive.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> typing.Any:
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """Gets the number of primitives in the composite."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def translucent_primitives_sort_order(self) -> "AgEStkGraphicsPrimitivesSortOrder":
        """Gets or sets the sort order for translucent primitives in this composite. This determines a trade-off between rendering speed and quality..."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsPrimitivesSortOrder) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_translucent_primitives_sort_order"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @translucent_primitives_sort_order.setter
    def translucent_primitives_sort_order(self, translucentPrimitivesSortOrder:"AgEStkGraphicsPrimitivesSortOrder") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsPrimitivesSortOrder, translucentPrimitivesSortOrder) as arg_translucentPrimitivesSortOrder:
            agcls.evaluate_hresult(self.__dict__["_set_translucent_primitives_sort_order"](arg_translucentPrimitivesSortOrder.COM_val))

    def add(self, primitive:"IPrimitive") -> None:
        """Adds a primitive to the composite."""
        with agmarshall.AgInterface_in_arg(primitive, IPrimitive) as arg_primitive:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_primitive.COM_val))

    def remove(self, primitive:"IPrimitive") -> None:
        """Removes a primitive from the composite."""
        with agmarshall.AgInterface_in_arg(primitive, IPrimitive) as arg_primitive:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_primitive.COM_val))

    def contains(self, primitive:"IPrimitive") -> bool:
        """Determines whether the composite contains a primitive."""
        with agmarshall.AgInterface_in_arg(primitive, IPrimitive) as arg_primitive, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_contains"](arg_primitive.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def clear(self) -> None:
        """Removes all primitives from the composite."""
        agcls.evaluate_hresult(self.__dict__["_clear"]())

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns an enumerator that iterates through the collection. The order of the primitives is not guaranteed to be the order that the primitives were added."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{c24448a9-4fe7-4905-86e0-70a71346fcf2}", ICompositePrimitive)
agcls.AgTypeNameMap["ICompositePrimitive"] = ICompositePrimitive

class IConstantDisplayCondition(object):
    """A display condition that evaluates to a user-defined value. This is commonly used to hide primitives by assigning to a primitive a display condition that always returns false."""
    _uuid = "{efede07b-4d59-4622-ba51-0281a5108aab}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_display"] = _raise_uninitialized_error
        self.__dict__["_set_display"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConstantDisplayCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConstantDisplayCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConstantDisplayCondition = agcom.GUID(IConstantDisplayCondition._uuid)
        vtable_offset_local = IConstantDisplayCondition._vtable_offset - 1
        self.__dict__["_get_display"] = IAGFUNCTYPE(pUnk, IID_IConstantDisplayCondition, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display"] = IAGFUNCTYPE(pUnk, IID_IConstantDisplayCondition, vtable_offset_local+2, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConstantDisplayCondition.__dict__ and type(IConstantDisplayCondition.__dict__[attrname]) == property:
            return IConstantDisplayCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConstantDisplayCondition.")
    
    @property
    def display(self) -> bool:
        """Gets or sets the value the display condition evaluates to."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display.setter
    def display(self, display:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(display) as arg_display:
            agcls.evaluate_hresult(self.__dict__["_set_display"](arg_display.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{efede07b-4d59-4622-ba51-0281a5108aab}", IConstantDisplayCondition)
agcls.AgTypeNameMap["IConstantDisplayCondition"] = IConstantDisplayCondition

class IDisplayCondition(object):
    """When assigned to objects, such as primitives or globe overlays, display conditions are evaluated to determine if the object should be rendered."""
    _uuid = "{5214ce90-6448-4cc7-bc5c-f06485ec5bb8}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDisplayCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDisplayCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDisplayCondition = agcom.GUID(IDisplayCondition._uuid)
        vtable_offset_local = IDisplayCondition._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDisplayCondition.__dict__ and type(IDisplayCondition.__dict__[attrname]) == property:
            return IDisplayCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDisplayCondition.")
    

agcls.AgClassCatalog.add_catalog_entry("{5214ce90-6448-4cc7-bc5c-f06485ec5bb8}", IDisplayCondition)
agcls.AgTypeNameMap["IDisplayCondition"] = IDisplayCondition

class IDistanceDisplayCondition(object):
    """Defines an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the object."""
    _uuid = "{b1b3130c-bebb-4a64-a5b7-2357384e2b8c}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_minimum_distance"] = _raise_uninitialized_error
        self.__dict__["_set_minimum_distance"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_distance"] = _raise_uninitialized_error
        self.__dict__["_set_maximum_distance"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_distance_squared"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_distance_squared"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDistanceDisplayCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDistanceDisplayCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDistanceDisplayCondition = agcom.GUID(IDistanceDisplayCondition._uuid)
        vtable_offset_local = IDistanceDisplayCondition._vtable_offset - 1
        self.__dict__["_get_minimum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceDisplayCondition, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_minimum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceDisplayCondition, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_maximum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceDisplayCondition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_maximum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceDisplayCondition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_minimum_distance_squared"] = IAGFUNCTYPE(pUnk, IID_IDistanceDisplayCondition, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_get_maximum_distance_squared"] = IAGFUNCTYPE(pUnk, IID_IDistanceDisplayCondition, vtable_offset_local+6, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDistanceDisplayCondition.__dict__ and type(IDistanceDisplayCondition.__dict__[attrname]) == property:
            return IDistanceDisplayCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDistanceDisplayCondition.")
    
    @property
    def minimum_distance(self) -> float:
        """Gets or sets the minimum distance of the inclusive distance interval."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_distance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @minimum_distance.setter
    def minimum_distance(self, minimumDistance:float) -> None:
        with agmarshall.DOUBLE_arg(minimumDistance) as arg_minimumDistance:
            agcls.evaluate_hresult(self.__dict__["_set_minimum_distance"](arg_minimumDistance.COM_val))

    @property
    def maximum_distance(self) -> float:
        """Gets or sets the maximum distance of the inclusive distance interval. Use Double.MaxValue to ignore checking the maximum distance."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_distance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @maximum_distance.setter
    def maximum_distance(self, maximumDistance:float) -> None:
        with agmarshall.DOUBLE_arg(maximumDistance) as arg_maximumDistance:
            agcls.evaluate_hresult(self.__dict__["_set_maximum_distance"](arg_maximumDistance.COM_val))

    @property
    def minimum_distance_squared(self) -> float:
        """Gets the squared minimum distance of the inclusive distance interval."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_distance_squared"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def maximum_distance_squared(self) -> float:
        """Gets the squared maximum distance of the inclusive distance interval."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_distance_squared"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{b1b3130c-bebb-4a64-a5b7-2357384e2b8c}", IDistanceDisplayCondition)
agcls.AgTypeNameMap["IDistanceDisplayCondition"] = IDistanceDisplayCondition

class IDistanceToGlobeOverlayDisplayCondition(object):
    """Defines an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the globe overlay..."""
    _uuid = "{212b00ec-ff3a-4f1b-9fc3-5a900c6536dc}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_globe_overlay"] = _raise_uninitialized_error
        self.__dict__["_set_globe_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_distance"] = _raise_uninitialized_error
        self.__dict__["_set_minimum_distance"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_distance_squared"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_distance"] = _raise_uninitialized_error
        self.__dict__["_set_maximum_distance"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_distance_squared"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDistanceToGlobeOverlayDisplayCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDistanceToGlobeOverlayDisplayCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDistanceToGlobeOverlayDisplayCondition = agcom.GUID(IDistanceToGlobeOverlayDisplayCondition._uuid)
        vtable_offset_local = IDistanceToGlobeOverlayDisplayCondition._vtable_offset - 1
        self.__dict__["_get_globe_overlay"] = IAGFUNCTYPE(pUnk, IID_IDistanceToGlobeOverlayDisplayCondition, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_set_globe_overlay"] = IAGFUNCTYPE(pUnk, IID_IDistanceToGlobeOverlayDisplayCondition, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_get_minimum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceToGlobeOverlayDisplayCondition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_minimum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceToGlobeOverlayDisplayCondition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_minimum_distance_squared"] = IAGFUNCTYPE(pUnk, IID_IDistanceToGlobeOverlayDisplayCondition, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_get_maximum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceToGlobeOverlayDisplayCondition, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_maximum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceToGlobeOverlayDisplayCondition, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_get_maximum_distance_squared"] = IAGFUNCTYPE(pUnk, IID_IDistanceToGlobeOverlayDisplayCondition, vtable_offset_local+8, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDistanceToGlobeOverlayDisplayCondition.__dict__ and type(IDistanceToGlobeOverlayDisplayCondition.__dict__[attrname]) == property:
            return IDistanceToGlobeOverlayDisplayCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDistanceToGlobeOverlayDisplayCondition.")
    
    @property
    def globe_overlay(self) -> "IGlobeOverlay":
        """Gets or sets the globe overlay associated with this instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_globe_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @globe_overlay.setter
    def globe_overlay(self, globeOverlay:"IGlobeOverlay") -> None:
        with agmarshall.AgInterface_in_arg(globeOverlay, IGlobeOverlay) as arg_globeOverlay:
            agcls.evaluate_hresult(self.__dict__["_set_globe_overlay"](arg_globeOverlay.COM_val))

    @property
    def minimum_distance(self) -> float:
        """Gets or sets the minimum distance of the inclusive distance interval."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_distance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @minimum_distance.setter
    def minimum_distance(self, minimumDistance:float) -> None:
        with agmarshall.DOUBLE_arg(minimumDistance) as arg_minimumDistance:
            agcls.evaluate_hresult(self.__dict__["_set_minimum_distance"](arg_minimumDistance.COM_val))

    @property
    def minimum_distance_squared(self) -> float:
        """Gets the squared minimum distance of the inclusive distance interval."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_distance_squared"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def maximum_distance(self) -> float:
        """Gets or sets the maximum distance of the inclusive distance interval. Use Double.MaxValue to ignore checking the maximum distance."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_distance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @maximum_distance.setter
    def maximum_distance(self, maximumDistance:float) -> None:
        with agmarshall.DOUBLE_arg(maximumDistance) as arg_maximumDistance:
            agcls.evaluate_hresult(self.__dict__["_set_maximum_distance"](arg_maximumDistance.COM_val))

    @property
    def maximum_distance_squared(self) -> float:
        """Gets the squared maximum distance of the inclusive distance interval."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_distance_squared"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{212b00ec-ff3a-4f1b-9fc3-5a900c6536dc}", IDistanceToGlobeOverlayDisplayCondition)
agcls.AgTypeNameMap["IDistanceToGlobeOverlayDisplayCondition"] = IDistanceToGlobeOverlayDisplayCondition

class IDistanceToPositionDisplayCondition(object):
    """Defines an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to a position defined in the given reference frame."""
    _uuid = "{0110db74-d567-4804-9bec-d7cce8ed59d0}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_minimum_distance"] = _raise_uninitialized_error
        self.__dict__["_set_minimum_distance"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_distance_squared"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_distance"] = _raise_uninitialized_error
        self.__dict__["_set_maximum_distance"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_distance_squared"] = _raise_uninitialized_error
        self.__dict__["_get_position"] = _raise_uninitialized_error
        self.__dict__["_set_position"] = _raise_uninitialized_error
        self.__dict__["_get_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_set_reference_frame"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDistanceToPositionDisplayCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDistanceToPositionDisplayCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDistanceToPositionDisplayCondition = agcom.GUID(IDistanceToPositionDisplayCondition._uuid)
        vtable_offset_local = IDistanceToPositionDisplayCondition._vtable_offset - 1
        self.__dict__["_get_minimum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPositionDisplayCondition, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_minimum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPositionDisplayCondition, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_minimum_distance_squared"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPositionDisplayCondition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_get_maximum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPositionDisplayCondition, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_maximum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPositionDisplayCondition, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_maximum_distance_squared"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPositionDisplayCondition, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_get_position"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPositionDisplayCondition, vtable_offset_local+7, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_position"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPositionDisplayCondition, vtable_offset_local+8, agcom.SAFEARRAY)
        self.__dict__["_get_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPositionDisplayCondition, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_set_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPositionDisplayCondition, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDistanceToPositionDisplayCondition.__dict__ and type(IDistanceToPositionDisplayCondition.__dict__[attrname]) == property:
            return IDistanceToPositionDisplayCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDistanceToPositionDisplayCondition.")
    
    @property
    def minimum_distance(self) -> float:
        """Gets or sets the minimum distance of the inclusive distance interval."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_distance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @minimum_distance.setter
    def minimum_distance(self, minimumDistance:float) -> None:
        with agmarshall.DOUBLE_arg(minimumDistance) as arg_minimumDistance:
            agcls.evaluate_hresult(self.__dict__["_set_minimum_distance"](arg_minimumDistance.COM_val))

    @property
    def minimum_distance_squared(self) -> float:
        """Gets the squared minimum distance of the inclusive distance interval."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_distance_squared"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def maximum_distance(self) -> float:
        """Gets or sets the maximum distance of the inclusive distance interval. Use Double.MaxValue to ignore checking the maximum distance."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_distance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @maximum_distance.setter
    def maximum_distance(self, maximumDistance:float) -> None:
        with agmarshall.DOUBLE_arg(maximumDistance) as arg_maximumDistance:
            agcls.evaluate_hresult(self.__dict__["_set_maximum_distance"](arg_maximumDistance.COM_val))

    @property
    def maximum_distance_squared(self) -> float:
        """Gets the squared maximum distance of the inclusive distance interval."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_distance_squared"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def position(self) -> list:
        """Gets or sets the position used to compute the distance from the camera. The array contains the components of the position arranged in the order x, y, z."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @position.setter
    def position(self, position:list) -> None:
        with agmarshall.SAFEARRAY_arg(position) as arg_position:
            agcls.evaluate_hresult(self.__dict__["_set_position"](arg_position.COM_val))

    @property
    def reference_frame(self) -> "IVectorGeometryToolSystem":
        """Gets or sets the reference frame that position is defined in."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_frame"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @reference_frame.setter
    def reference_frame(self, referenceFrame:"IVectorGeometryToolSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceFrame, IVectorGeometryToolSystem) as arg_referenceFrame:
            agcls.evaluate_hresult(self.__dict__["_set_reference_frame"](arg_referenceFrame.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0110db74-d567-4804-9bec-d7cce8ed59d0}", IDistanceToPositionDisplayCondition)
agcls.AgTypeNameMap["IDistanceToPositionDisplayCondition"] = IDistanceToPositionDisplayCondition

class IDistanceToPrimitiveDisplayCondition(object):
    """Defines an inclusive distance interval that determines when an object, such as a screen overlay, is rendered based on the distance from the camera to the primitive..."""
    _uuid = "{bf9664c2-e8c4-471b-a071-865f1448a031}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_primitive"] = _raise_uninitialized_error
        self.__dict__["_set_primitive"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_distance"] = _raise_uninitialized_error
        self.__dict__["_set_minimum_distance"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_distance_squared"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_distance"] = _raise_uninitialized_error
        self.__dict__["_set_maximum_distance"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_distance_squared"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDistanceToPrimitiveDisplayCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDistanceToPrimitiveDisplayCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDistanceToPrimitiveDisplayCondition = agcom.GUID(IDistanceToPrimitiveDisplayCondition._uuid)
        vtable_offset_local = IDistanceToPrimitiveDisplayCondition._vtable_offset - 1
        self.__dict__["_get_primitive"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPrimitiveDisplayCondition, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_set_primitive"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPrimitiveDisplayCondition, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_get_minimum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPrimitiveDisplayCondition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_minimum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPrimitiveDisplayCondition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_minimum_distance_squared"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPrimitiveDisplayCondition, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_get_maximum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPrimitiveDisplayCondition, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_maximum_distance"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPrimitiveDisplayCondition, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_get_maximum_distance_squared"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPrimitiveDisplayCondition, vtable_offset_local+8, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDistanceToPrimitiveDisplayCondition.__dict__ and type(IDistanceToPrimitiveDisplayCondition.__dict__[attrname]) == property:
            return IDistanceToPrimitiveDisplayCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDistanceToPrimitiveDisplayCondition.")
    
    @property
    def primitive(self) -> "IPrimitive":
        """Gets or sets the primitive associated with this instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_primitive"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @primitive.setter
    def primitive(self, primitive:"IPrimitive") -> None:
        with agmarshall.AgInterface_in_arg(primitive, IPrimitive) as arg_primitive:
            agcls.evaluate_hresult(self.__dict__["_set_primitive"](arg_primitive.COM_val))

    @property
    def minimum_distance(self) -> float:
        """Gets or sets the minimum distance of the inclusive distance interval."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_distance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @minimum_distance.setter
    def minimum_distance(self, minimumDistance:float) -> None:
        with agmarshall.DOUBLE_arg(minimumDistance) as arg_minimumDistance:
            agcls.evaluate_hresult(self.__dict__["_set_minimum_distance"](arg_minimumDistance.COM_val))

    @property
    def minimum_distance_squared(self) -> float:
        """Gets the squared minimum distance of the inclusive distance interval."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_distance_squared"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def maximum_distance(self) -> float:
        """Gets or sets the maximum distance of the inclusive distance interval. Use Double.MaxValue to ignore checking the maximum distance."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_distance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @maximum_distance.setter
    def maximum_distance(self, maximumDistance:float) -> None:
        with agmarshall.DOUBLE_arg(maximumDistance) as arg_maximumDistance:
            agcls.evaluate_hresult(self.__dict__["_set_maximum_distance"](arg_maximumDistance.COM_val))

    @property
    def maximum_distance_squared(self) -> float:
        """Gets the squared maximum distance of the inclusive distance interval."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_distance_squared"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{bf9664c2-e8c4-471b-a071-865f1448a031}", IDistanceToPrimitiveDisplayCondition)
agcls.AgTypeNameMap["IDistanceToPrimitiveDisplayCondition"] = IDistanceToPrimitiveDisplayCondition

class IDurationPathPrimitiveUpdatePolicy(object):
    """path primitive update policy that removes points from remove location after a given duration."""
    _uuid = "{23d3c9c4-b242-4a5a-89cf-58387bd9f935}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_duration"] = _raise_uninitialized_error
        self.__dict__["_set_duration"] = _raise_uninitialized_error
        self.__dict__["_get_remove_location"] = _raise_uninitialized_error
        self.__dict__["_set_remove_location"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDurationPathPrimitiveUpdatePolicy._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDurationPathPrimitiveUpdatePolicy from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDurationPathPrimitiveUpdatePolicy = agcom.GUID(IDurationPathPrimitiveUpdatePolicy._uuid)
        vtable_offset_local = IDurationPathPrimitiveUpdatePolicy._vtable_offset - 1
        self.__dict__["_get_duration"] = IAGFUNCTYPE(pUnk, IID_IDurationPathPrimitiveUpdatePolicy, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_duration"] = IAGFUNCTYPE(pUnk, IID_IDurationPathPrimitiveUpdatePolicy, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_remove_location"] = IAGFUNCTYPE(pUnk, IID_IDurationPathPrimitiveUpdatePolicy, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_remove_location"] = IAGFUNCTYPE(pUnk, IID_IDurationPathPrimitiveUpdatePolicy, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDurationPathPrimitiveUpdatePolicy.__dict__ and type(IDurationPathPrimitiveUpdatePolicy.__dict__[attrname]) == property:
            return IDurationPathPrimitiveUpdatePolicy.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDurationPathPrimitiveUpdatePolicy.")
    
    @property
    def duration(self) -> float:
        """Gets or sets the maximum duration that a point will lie on the line."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_duration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @duration.setter
    def duration(self, duration:float) -> None:
        with agmarshall.DOUBLE_arg(duration) as arg_duration:
            agcls.evaluate_hresult(self.__dict__["_set_duration"](arg_duration.COM_val))

    @property
    def remove_location(self) -> "AgEStkGraphicsPathPrimitiveRemoveLocation":
        """Gets or sets where the positions on the path are removed from."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsPathPrimitiveRemoveLocation) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_remove_location"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @remove_location.setter
    def remove_location(self, removeLocation:"AgEStkGraphicsPathPrimitiveRemoveLocation") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsPathPrimitiveRemoveLocation, removeLocation) as arg_removeLocation:
            agcls.evaluate_hresult(self.__dict__["_set_remove_location"](arg_removeLocation.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{23d3c9c4-b242-4a5a-89cf-58387bd9f935}", IDurationPathPrimitiveUpdatePolicy)
agcls.AgTypeNameMap["IDurationPathPrimitiveUpdatePolicy"] = IDurationPathPrimitiveUpdatePolicy

class IFrameRate(object):
    """Keeps track of how many times the scenes are rendered per second."""
    _uuid = "{9bbe1077-fcb3-4d73-ae9e-727155e14288}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_frames_per_second"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_number_of_frames"] = _raise_uninitialized_error
        self.__dict__["_set_maximum_number_of_frames"] = _raise_uninitialized_error
        self.__dict__["_reset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IFrameRate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IFrameRate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IFrameRate = agcom.GUID(IFrameRate._uuid)
        vtable_offset_local = IFrameRate._vtable_offset - 1
        self.__dict__["_get_frames_per_second"] = IAGFUNCTYPE(pUnk, IID_IFrameRate, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_get_maximum_number_of_frames"] = IAGFUNCTYPE(pUnk, IID_IFrameRate, vtable_offset_local+2, POINTER(agcom.INT))
        self.__dict__["_set_maximum_number_of_frames"] = IAGFUNCTYPE(pUnk, IID_IFrameRate, vtable_offset_local+3, agcom.INT)
        self.__dict__["_reset"] = IAGFUNCTYPE(pUnk, IID_IFrameRate, vtable_offset_local+4, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFrameRate.__dict__ and type(IFrameRate.__dict__[attrname]) == property:
            return IFrameRate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFrameRate.")
    
    @property
    def frames_per_second(self) -> float:
        """Gets the current frame rate in frames per second."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_frames_per_second"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def maximum_number_of_frames(self) -> int:
        """Gets or sets the maximum number of frames used to determine frame rate. More frames means that the frame rate is averaged over a longer period of time and will fluctuate less than fewer frames would. The minimum value is 2."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_number_of_frames"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @maximum_number_of_frames.setter
    def maximum_number_of_frames(self, maximumNumberOfFrames:int) -> None:
        with agmarshall.INT_arg(maximumNumberOfFrames) as arg_maximumNumberOfFrames:
            agcls.evaluate_hresult(self.__dict__["_set_maximum_number_of_frames"](arg_maximumNumberOfFrames.COM_val))

    def reset(self) -> None:
        """This resets the frame rate counter back to zero. The frame rate computation begins anew."""
        agcls.evaluate_hresult(self.__dict__["_reset"]())


agcls.AgClassCatalog.add_catalog_entry("{9bbe1077-fcb3-4d73-ae9e-727155e14288}", IFrameRate)
agcls.AgTypeNameMap["IFrameRate"] = IFrameRate

class IGlobeImageOverlay(object):
    """A globe overlay that shows an image."""
    _uuid = "{ac17f1dd-17dc-41bd-8429-80f90234b53f}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_use_altitude_based_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_use_altitude_based_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_based_translucency_lower_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_based_translucency_lower_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_based_translucency_upper_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_based_translucency_upper_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_based_translucency_lower_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_based_translucency_lower_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_based_translucency_upper_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_based_translucency_upper_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_more_than_one_image_globe_overlay_supported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGlobeImageOverlay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGlobeImageOverlay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGlobeImageOverlay = agcom.GUID(IGlobeImageOverlay._uuid)
        vtable_offset_local = IGlobeImageOverlay._vtable_offset - 1
        self.__dict__["_get_translucency"] = IAGFUNCTYPE(pUnk, IID_IGlobeImageOverlay, vtable_offset_local+1, POINTER(agcom.FLOAT))
        self.__dict__["_set_translucency"] = IAGFUNCTYPE(pUnk, IID_IGlobeImageOverlay, vtable_offset_local+2, agcom.FLOAT)
        self.__dict__["_get_use_altitude_based_translucency"] = IAGFUNCTYPE(pUnk, IID_IGlobeImageOverlay, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_altitude_based_translucency"] = IAGFUNCTYPE(pUnk, IID_IGlobeImageOverlay, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_altitude_based_translucency_lower_translucency"] = IAGFUNCTYPE(pUnk, IID_IGlobeImageOverlay, vtable_offset_local+5, POINTER(agcom.FLOAT))
        self.__dict__["_set_altitude_based_translucency_lower_translucency"] = IAGFUNCTYPE(pUnk, IID_IGlobeImageOverlay, vtable_offset_local+6, agcom.FLOAT)
        self.__dict__["_get_altitude_based_translucency_upper_translucency"] = IAGFUNCTYPE(pUnk, IID_IGlobeImageOverlay, vtable_offset_local+7, POINTER(agcom.FLOAT))
        self.__dict__["_set_altitude_based_translucency_upper_translucency"] = IAGFUNCTYPE(pUnk, IID_IGlobeImageOverlay, vtable_offset_local+8, agcom.FLOAT)
        self.__dict__["_get_altitude_based_translucency_lower_altitude"] = IAGFUNCTYPE(pUnk, IID_IGlobeImageOverlay, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_based_translucency_lower_altitude"] = IAGFUNCTYPE(pUnk, IID_IGlobeImageOverlay, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_altitude_based_translucency_upper_altitude"] = IAGFUNCTYPE(pUnk, IID_IGlobeImageOverlay, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_based_translucency_upper_altitude"] = IAGFUNCTYPE(pUnk, IID_IGlobeImageOverlay, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_more_than_one_image_globe_overlay_supported"] = IAGFUNCTYPE(pUnk, IID_IGlobeImageOverlay, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGlobeImageOverlay.__dict__ and type(IGlobeImageOverlay.__dict__[attrname]) == property:
            return IGlobeImageOverlay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGlobeImageOverlay.")
    
    @property
    def translucency(self) -> float:
        """Gets or sets the translucency value for the image. The translucency is between 0 and 1, where 0 is fully opaque and 1 is invisible."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @translucency.setter
    def translucency(self, translucency:float) -> None:
        with agmarshall.FLOAT_arg(translucency) as arg_translucency:
            agcls.evaluate_hresult(self.__dict__["_set_translucency"](arg_translucency.COM_val))

    @property
    def use_altitude_based_translucency(self) -> bool:
        """Gets or sets whether to use altitude to determine the translucency value for the image or not. If <see langword='false' />, the translucency value is used..."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_altitude_based_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @use_altitude_based_translucency.setter
    def use_altitude_based_translucency(self, useAltitudeBasedTranslucency:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useAltitudeBasedTranslucency) as arg_useAltitudeBasedTranslucency:
            agcls.evaluate_hresult(self.__dict__["_set_use_altitude_based_translucency"](arg_useAltitudeBasedTranslucency.COM_val))

    @property
    def altitude_based_translucency_lower_translucency(self) -> float:
        """Gets or sets the lower translucency value for the image when use altitude based translucency is set to <see langword='true' />..."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_based_translucency_lower_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @altitude_based_translucency_lower_translucency.setter
    def altitude_based_translucency_lower_translucency(self, altitudeBasedTranslucencyLowerTranslucency:float) -> None:
        with agmarshall.FLOAT_arg(altitudeBasedTranslucencyLowerTranslucency) as arg_altitudeBasedTranslucencyLowerTranslucency:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_based_translucency_lower_translucency"](arg_altitudeBasedTranslucencyLowerTranslucency.COM_val))

    @property
    def altitude_based_translucency_upper_translucency(self) -> float:
        """Gets or sets the upper translucency value for the image when use altitude based translucency is set to <see langword='true' />..."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_based_translucency_upper_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @altitude_based_translucency_upper_translucency.setter
    def altitude_based_translucency_upper_translucency(self, altitudeBasedTranslucencyUpperTranslucency:float) -> None:
        with agmarshall.FLOAT_arg(altitudeBasedTranslucencyUpperTranslucency) as arg_altitudeBasedTranslucencyUpperTranslucency:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_based_translucency_upper_translucency"](arg_altitudeBasedTranslucencyUpperTranslucency.COM_val))

    @property
    def altitude_based_translucency_lower_altitude(self) -> float:
        """Gets or sets the lower altitude bound used to calculate translucency for the image when use altitude based translucency is set to <see langword='true' />..."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_based_translucency_lower_altitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @altitude_based_translucency_lower_altitude.setter
    def altitude_based_translucency_lower_altitude(self, altitudeBasedTranslucencyLowerAltitude:float) -> None:
        with agmarshall.DOUBLE_arg(altitudeBasedTranslucencyLowerAltitude) as arg_altitudeBasedTranslucencyLowerAltitude:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_based_translucency_lower_altitude"](arg_altitudeBasedTranslucencyLowerAltitude.COM_val))

    @property
    def altitude_based_translucency_upper_altitude(self) -> float:
        """Gets or sets the upper altitude bound used to calculate translucency for the image when use altitude based translucency is set to <see langword='true' />..."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_based_translucency_upper_altitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @altitude_based_translucency_upper_altitude.setter
    def altitude_based_translucency_upper_altitude(self, altitudeBasedTranslucencyUpperAltitude:float) -> None:
        with agmarshall.DOUBLE_arg(altitudeBasedTranslucencyUpperAltitude) as arg_altitudeBasedTranslucencyUpperAltitude:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_based_translucency_upper_altitude"](arg_altitudeBasedTranslucencyUpperAltitude.COM_val))

    @property
    def more_than_one_image_globe_overlay_supported(self) -> bool:
        """Gets whether or not the video card allows for more than one image globe overlay globe image overlay to be added."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_more_than_one_image_globe_overlay_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{ac17f1dd-17dc-41bd-8429-80f90234b53f}", IGlobeImageOverlay)
agcls.AgTypeNameMap["IGlobeImageOverlay"] = IGlobeImageOverlay

class IGraphicsFont(object):
    """A font that is suitable for use with the text batch primitive. For best performance, avoid creating duplicate font objects. Instead assign the same font object to several text batch primitives."""
    _uuid = "{36a67d60-3f13-435b-92d8-b6a76ed1a74a}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_size"] = _raise_uninitialized_error
        self.__dict__["_get_bold"] = _raise_uninitialized_error
        self.__dict__["_get_italic"] = _raise_uninitialized_error
        self.__dict__["_get_underline"] = _raise_uninitialized_error
        self.__dict__["_get_strikeout"] = _raise_uninitialized_error
        self.__dict__["_get_outline"] = _raise_uninitialized_error
        self.__dict__["_get_style"] = _raise_uninitialized_error
        self.__dict__["_get_antialias"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGraphicsFont._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGraphicsFont from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGraphicsFont = agcom.GUID(IGraphicsFont._uuid)
        vtable_offset_local = IGraphicsFont._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IGraphicsFont, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_get_size"] = IAGFUNCTYPE(pUnk, IID_IGraphicsFont, vtable_offset_local+2, POINTER(agcom.INT))
        self.__dict__["_get_bold"] = IAGFUNCTYPE(pUnk, IID_IGraphicsFont, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_italic"] = IAGFUNCTYPE(pUnk, IID_IGraphicsFont, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_underline"] = IAGFUNCTYPE(pUnk, IID_IGraphicsFont, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_strikeout"] = IAGFUNCTYPE(pUnk, IID_IGraphicsFont, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_outline"] = IAGFUNCTYPE(pUnk, IID_IGraphicsFont, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_style"] = IAGFUNCTYPE(pUnk, IID_IGraphicsFont, vtable_offset_local+8, POINTER(agcom.LONG))
        self.__dict__["_get_antialias"] = IAGFUNCTYPE(pUnk, IID_IGraphicsFont, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGraphicsFont.__dict__ and type(IGraphicsFont.__dict__[attrname]) == property:
            return IGraphicsFont.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGraphicsFont.")
    
    @property
    def name(self) -> str:
        """Gets the typeface name of the font."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def size(self) -> int:
        """Gets the size of the font."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_size"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def bold(self) -> bool:
        """Gets a value that indicates whether this font is bold."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_bold"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def italic(self) -> bool:
        """Gets a value that indicates whether this font is italic."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_italic"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def underline(self) -> bool:
        """Gets a value that indicates whether this font is underlined."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_underline"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def strikeout(self) -> bool:
        """Gets a value that indicates whether this font has a horizontal line through its characters."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_strikeout"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def outline(self) -> bool:
        """Gets a value that indicates whether this font has an outline around its characters."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def style(self) -> "AgEStkGraphicsFontStyle":
        """Gets the font style enumeration that contains the style for this font. This does not include the outline property."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsFontStyle) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_style"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def antialias(self) -> bool:
        """Gets a value that indicates whether this font is antialiased."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_antialias"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{36a67d60-3f13-435b-92d8-b6a76ed1a74a}", IGraphicsFont)
agcls.AgTypeNameMap["IGraphicsFont"] = IGraphicsFont

class IGreatArcInterpolator(object):
    """The great arc interpolator computes interpolated positions along a great arc. A great arc is the shortest path between two positions on an ellipsoid."""
    _uuid = "{8de070c1-de8f-48ee-96ea-5dc046706d28}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body"] = _raise_uninitialized_error
        self.__dict__["_set_central_body"] = _raise_uninitialized_error
        self.__dict__["_get_granularity"] = _raise_uninitialized_error
        self.__dict__["_set_granularity"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGreatArcInterpolator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGreatArcInterpolator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGreatArcInterpolator = agcom.GUID(IGreatArcInterpolator._uuid)
        vtable_offset_local = IGreatArcInterpolator._vtable_offset - 1
        self.__dict__["_get_central_body"] = IAGFUNCTYPE(pUnk, IID_IGreatArcInterpolator, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body"] = IAGFUNCTYPE(pUnk, IID_IGreatArcInterpolator, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_granularity"] = IAGFUNCTYPE(pUnk, IID_IGreatArcInterpolator, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_granularity"] = IAGFUNCTYPE(pUnk, IID_IGreatArcInterpolator, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGreatArcInterpolator.__dict__ and type(IGreatArcInterpolator.__dict__[attrname]) == property:
            return IGreatArcInterpolator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGreatArcInterpolator.")
    
    @property
    def central_body(self) -> str:
        """Gets or sets the central body used when interpolating with interpolate."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_set_central_body"](arg_centralBody.COM_val))

    @property
    def granularity(self) -> float:
        """Gets or sets the granularity used when interpolating with interpolate. Lower granularities are more precise but create more positions."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_granularity"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @granularity.setter
    def granularity(self, granularity:float) -> None:
        with agmarshall.DOUBLE_arg(granularity) as arg_granularity:
            agcls.evaluate_hresult(self.__dict__["_set_granularity"](arg_granularity.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8de070c1-de8f-48ee-96ea-5dc046706d28}", IGreatArcInterpolator)
agcls.AgTypeNameMap["IGreatArcInterpolator"] = IGreatArcInterpolator

class IImageCollection(object):
    """A collection of globe image overlay objects."""
    _uuid = "{797b7253-9205-47a1-b49b-edf6e06326c0}"
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_is_read_only"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_contains"] = _raise_uninitialized_error
        self.__dict__["_contains_uri_string"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_clear"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_add_async"] = _raise_uninitialized_error
        self.__dict__["_index_of"] = _raise_uninitialized_error
        self.__dict__["_index_of_uri_string"] = _raise_uninitialized_error
        self.__dict__["_add_uri_string"] = _raise_uninitialized_error
        self.__dict__["_add_async_uri_string"] = _raise_uninitialized_error
        self.__dict__["_swap"] = _raise_uninitialized_error
        self.__dict__["_swap_by_index"] = _raise_uninitialized_error
        self.__dict__["_move"] = _raise_uninitialized_error
        self.__dict__["_move_by_index"] = _raise_uninitialized_error
        self.__dict__["_bring_to_front"] = _raise_uninitialized_error
        self.__dict__["_send_to_back"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IImageCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IImageCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IImageCollection = agcom.GUID(IImageCollection._uuid)
        vtable_offset_local = IImageCollection._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_get_is_read_only"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+2, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+3, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_contains"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+5, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_contains_uri_string"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+7, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_clear"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+8, )
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+9, agcom.PVOID)
        self.__dict__["_add_async"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+10, agcom.PVOID)
        self.__dict__["_index_of"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+11, agcom.PVOID, POINTER(agcom.INT))
        self.__dict__["_index_of_uri_string"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+12, agcom.BSTR, POINTER(agcom.INT))
        self.__dict__["_add_uri_string"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+13, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_add_async_uri_string"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+14, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_swap"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+15, agcom.PVOID, agcom.PVOID)
        self.__dict__["_swap_by_index"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+16, agcom.INT, agcom.INT)
        self.__dict__["_move"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+17, agcom.PVOID, agcom.INT)
        self.__dict__["_move_by_index"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+18, agcom.INT, agcom.INT)
        self.__dict__["_bring_to_front"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+19, agcom.PVOID)
        self.__dict__["_send_to_back"] = IAGFUNCTYPE(pUnk, IID_IImageCollection, vtable_offset_local+20, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IImageCollection.__dict__ and type(IImageCollection.__dict__[attrname]) == property:
            return IImageCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IImageCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IGlobeImageOverlay":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    def Subscribe(self) -> IImageCollectionEventHandler:
        """Returns an IImageCollectionEventHandler that is subscribed to handle events associated with this instance of IImageCollection."""
        return IImageCollectionEventHandler(self._pUnk)    
    @property
    def count(self) -> int:
        """Gets the number of globe overlay objects in the collection."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def is_read_only(self) -> bool:
        """Gets whether or not the collection is read only."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_read_only"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> "IGlobeImageOverlay":
        """Gets the globe image overlay at the specified index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Constructs an iterator that can be used to iterate the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def contains(self, imageryOverlay:"IGlobeImageOverlay") -> bool:
        """Checks the presence of a globe image overlay in the collection."""
        with agmarshall.AgInterface_in_arg(imageryOverlay, IGlobeImageOverlay) as arg_imageryOverlay, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_contains"](arg_imageryOverlay.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def contains_uri_string(self, stringUri:str) -> bool:
        """Checks the presence of a globe image overlay with the specified Uri in the collection."""
        with agmarshall.BSTR_arg(stringUri) as arg_stringUri, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_contains_uri_string"](arg_stringUri.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def remove(self, globeOverlay:"IGlobeImageOverlay") -> bool:
        """Removes a globe image overlay from the collection."""
        with agmarshall.AgInterface_in_arg(globeOverlay, IGlobeImageOverlay) as arg_globeOverlay, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_globeOverlay.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def clear(self) -> None:
        """Removes all globe image overlay objects from the collection."""
        agcls.evaluate_hresult(self.__dict__["_clear"]())

    def add(self, imageryOverlay:"IGlobeImageOverlay") -> None:
        """Adds imageryOverlay to the collection."""
        with agmarshall.AgInterface_in_arg(imageryOverlay, IGlobeImageOverlay) as arg_imageryOverlay:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_imageryOverlay.COM_val))

    def add_async(self, imageryOverlay:"IGlobeImageOverlay") -> None:
        """Adds imageryOverlay to the collection asynchronously."""
        with agmarshall.AgInterface_in_arg(imageryOverlay, IGlobeImageOverlay) as arg_imageryOverlay:
            agcls.evaluate_hresult(self.__dict__["_add_async"](arg_imageryOverlay.COM_val))

    def index_of(self, imageryOverlay:"IGlobeImageOverlay") -> int:
        """Gets the index of the specified globe image overlay."""
        with agmarshall.AgInterface_in_arg(imageryOverlay, IGlobeImageOverlay) as arg_imageryOverlay, \
             agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_index_of"](arg_imageryOverlay.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def index_of_uri_string(self, stringUri:str) -> int:
        """Gets the index of the globe image overlay with the specified Uri."""
        with agmarshall.BSTR_arg(stringUri) as arg_stringUri, \
             agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_index_of_uri_string"](arg_stringUri.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def add_uri_string(self, uri:str) -> "IGlobeImageOverlay":
        """Creates a globe overlay from the uri, which represents a uri, and adds it to the collection."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_add_uri_string"](arg_uri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def add_async_uri_string(self, uri:str) -> "IGlobeImageOverlay":
        """Creates a globe image overlay from the uri, which represents a uri, and adds it to the collection asynchronously."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_add_async_uri_string"](arg_uri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def swap(self, imageryOverlay1:"IGlobeImageOverlay", imageryOverlay2:"IGlobeImageOverlay") -> None:
        """Swaps the position of two globe image overlay objects."""
        with agmarshall.AgInterface_in_arg(imageryOverlay1, IGlobeImageOverlay) as arg_imageryOverlay1, \
             agmarshall.AgInterface_in_arg(imageryOverlay2, IGlobeImageOverlay) as arg_imageryOverlay2:
            agcls.evaluate_hresult(self.__dict__["_swap"](arg_imageryOverlay1.COM_val, arg_imageryOverlay2.COM_val))

    def swap_by_index(self, index1:int, index2:int) -> None:
        """Swaps the position of two globe image overlay objects at the specified indices."""
        with agmarshall.INT_arg(index1) as arg_index1, \
             agmarshall.INT_arg(index2) as arg_index2:
            agcls.evaluate_hresult(self.__dict__["_swap_by_index"](arg_index1.COM_val, arg_index2.COM_val))

    def move(self, imageryOverlay:"IGlobeImageOverlay", newPosition:int) -> None:
        """Moves the globe image overlay to the specified position."""
        with agmarshall.AgInterface_in_arg(imageryOverlay, IGlobeImageOverlay) as arg_imageryOverlay, \
             agmarshall.INT_arg(newPosition) as arg_newPosition:
            agcls.evaluate_hresult(self.__dict__["_move"](arg_imageryOverlay.COM_val, arg_newPosition.COM_val))

    def move_by_index(self, index:int, newPosition:int) -> None:
        """Moves the globe image overlay at the specified index to the specified position."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.INT_arg(newPosition) as arg_newPosition:
            agcls.evaluate_hresult(self.__dict__["_move_by_index"](arg_index.COM_val, arg_newPosition.COM_val))

    def bring_to_front(self, imageryOverlay:"IGlobeImageOverlay") -> None:
        """Brings the globe image overlay to the front of the collection so it is rendered first or on the bottom."""
        with agmarshall.AgInterface_in_arg(imageryOverlay, IGlobeImageOverlay) as arg_imageryOverlay:
            agcls.evaluate_hresult(self.__dict__["_bring_to_front"](arg_imageryOverlay.COM_val))

    def send_to_back(self, imageryOverlay:"IGlobeImageOverlay") -> None:
        """Sends the globe image overlay to the back of the collection so it is rendered last or on the top."""
        with agmarshall.AgInterface_in_arg(imageryOverlay, IGlobeImageOverlay) as arg_imageryOverlay:
            agcls.evaluate_hresult(self.__dict__["_send_to_back"](arg_imageryOverlay.COM_val))

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{797b7253-9205-47a1-b49b-edf6e06326c0}", IImageCollection)
agcls.AgTypeNameMap["IImageCollection"] = IImageCollection

class IAlphaFromLuminanceFilter(object):
    """Adds an alpha band to the source raster derived from the luminance of the raster's color bands."""
    _uuid = "{9ee1933e-8f0d-4fca-8386-e03194e483da}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAlphaFromLuminanceFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAlphaFromLuminanceFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAlphaFromLuminanceFilter = agcom.GUID(IAlphaFromLuminanceFilter._uuid)
        vtable_offset_local = IAlphaFromLuminanceFilter._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAlphaFromLuminanceFilter.__dict__ and type(IAlphaFromLuminanceFilter.__dict__[attrname]) == property:
            return IAlphaFromLuminanceFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAlphaFromLuminanceFilter.")
    

agcls.AgClassCatalog.add_catalog_entry("{9ee1933e-8f0d-4fca-8386-e03194e483da}", IAlphaFromLuminanceFilter)
agcls.AgTypeNameMap["IAlphaFromLuminanceFilter"] = IAlphaFromLuminanceFilter

class IAlphaFromPixelFilter(object):
    """Adds an alpha band to the source raster based on the value of its first pixel. All pixels in the source raster that are the same color as the first pixel will be made transparent."""
    _uuid = "{071460a3-f86a-4c28-b2bf-22946db06ac8}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAlphaFromPixelFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAlphaFromPixelFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAlphaFromPixelFilter = agcom.GUID(IAlphaFromPixelFilter._uuid)
        vtable_offset_local = IAlphaFromPixelFilter._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAlphaFromPixelFilter.__dict__ and type(IAlphaFromPixelFilter.__dict__[attrname]) == property:
            return IAlphaFromPixelFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAlphaFromPixelFilter.")
    

agcls.AgClassCatalog.add_catalog_entry("{071460a3-f86a-4c28-b2bf-22946db06ac8}", IAlphaFromPixelFilter)
agcls.AgTypeNameMap["IAlphaFromPixelFilter"] = IAlphaFromPixelFilter

class IAlphaFromRasterFilter(object):
    """Adds an alpha band to the source raster derived from the color bands or alpha of another raster. This filter can be used to apply an alpha mask to the source raster."""
    _uuid = "{77326f5e-c3f3-4660-8df4-6225cfdc0870}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_raster"] = _raise_uninitialized_error
        self.__dict__["_set_raster"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAlphaFromRasterFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAlphaFromRasterFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAlphaFromRasterFilter = agcom.GUID(IAlphaFromRasterFilter._uuid)
        vtable_offset_local = IAlphaFromRasterFilter._vtable_offset - 1
        self.__dict__["_get_raster"] = IAGFUNCTYPE(pUnk, IID_IAlphaFromRasterFilter, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_set_raster"] = IAGFUNCTYPE(pUnk, IID_IAlphaFromRasterFilter, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAlphaFromRasterFilter.__dict__ and type(IAlphaFromRasterFilter.__dict__[attrname]) == property:
            return IAlphaFromRasterFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAlphaFromRasterFilter.")
    
    @property
    def raster(self) -> "IRaster":
        """Gets or sets the raster that the source raster will use to derive an alpha band."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_raster"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @raster.setter
    def raster(self, raster:"IRaster") -> None:
        with agmarshall.AgInterface_in_arg(raster, IRaster) as arg_raster:
            agcls.evaluate_hresult(self.__dict__["_set_raster"](arg_raster.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{77326f5e-c3f3-4660-8df4-6225cfdc0870}", IAlphaFromRasterFilter)
agcls.AgTypeNameMap["IAlphaFromRasterFilter"] = IAlphaFromRasterFilter

class IBandExtractFilter(object):
    """Extracts a band or set of bands from the source raster. The extract format property specifies the bands and the order of the bands that will be extracted."""
    _uuid = "{68723ebb-619a-4d11-bb5a-27200ef0e15c}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_extract_format"] = _raise_uninitialized_error
        self.__dict__["_set_extract_format"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBandExtractFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBandExtractFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBandExtractFilter = agcom.GUID(IBandExtractFilter._uuid)
        vtable_offset_local = IBandExtractFilter._vtable_offset - 1
        self.__dict__["_get_extract_format"] = IAGFUNCTYPE(pUnk, IID_IBandExtractFilter, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_extract_format"] = IAGFUNCTYPE(pUnk, IID_IBandExtractFilter, vtable_offset_local+2, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBandExtractFilter.__dict__ and type(IBandExtractFilter.__dict__[attrname]) == property:
            return IBandExtractFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBandExtractFilter.")
    
    @property
    def extract_format(self) -> "AgEStkGraphicsRasterFormat":
        """Gets or sets the raster format containing the bands and the order of the bands that will be extracted."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsRasterFormat) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_extract_format"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @extract_format.setter
    def extract_format(self, extractFormat:"AgEStkGraphicsRasterFormat") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsRasterFormat, extractFormat) as arg_extractFormat:
            agcls.evaluate_hresult(self.__dict__["_set_extract_format"](arg_extractFormat.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{68723ebb-619a-4d11-bb5a-27200ef0e15c}", IBandExtractFilter)
agcls.AgTypeNameMap["IBandExtractFilter"] = IBandExtractFilter

class IBandOrderFilter(object):
    """Reorders or swizzles the bands of the source raster to match the band order of the raster format specified by the band order property. When maintain raster format is true, the source raster's format is maintained after swizzling."""
    _uuid = "{a4a76805-e8e4-4bb6-878c-dcb0da6d84d3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_band_order"] = _raise_uninitialized_error
        self.__dict__["_set_band_order"] = _raise_uninitialized_error
        self.__dict__["_get_maintain_raster_format"] = _raise_uninitialized_error
        self.__dict__["_set_maintain_raster_format"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBandOrderFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBandOrderFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBandOrderFilter = agcom.GUID(IBandOrderFilter._uuid)
        vtable_offset_local = IBandOrderFilter._vtable_offset - 1
        self.__dict__["_get_band_order"] = IAGFUNCTYPE(pUnk, IID_IBandOrderFilter, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_band_order"] = IAGFUNCTYPE(pUnk, IID_IBandOrderFilter, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_maintain_raster_format"] = IAGFUNCTYPE(pUnk, IID_IBandOrderFilter, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_maintain_raster_format"] = IAGFUNCTYPE(pUnk, IID_IBandOrderFilter, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBandOrderFilter.__dict__ and type(IBandOrderFilter.__dict__[attrname]) == property:
            return IBandOrderFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBandOrderFilter.")
    
    @property
    def band_order(self) -> "AgEStkGraphicsRasterFormat":
        """Gets or sets the raster format indicating the desired order of the bands in the source raster."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsRasterFormat) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_band_order"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @band_order.setter
    def band_order(self, bandOrder:"AgEStkGraphicsRasterFormat") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsRasterFormat, bandOrder) as arg_bandOrder:
            agcls.evaluate_hresult(self.__dict__["_set_band_order"](arg_bandOrder.COM_val))

    @property
    def maintain_raster_format(self) -> bool:
        """Gets or sets a value indicating whether to maintain the source raster's format after the filter is applied. When true, the source raster's format is maintained after swizzling."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maintain_raster_format"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @maintain_raster_format.setter
    def maintain_raster_format(self, maintainRasterFormat:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(maintainRasterFormat) as arg_maintainRasterFormat:
            agcls.evaluate_hresult(self.__dict__["_set_maintain_raster_format"](arg_maintainRasterFormat.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{a4a76805-e8e4-4bb6-878c-dcb0da6d84d3}", IBandOrderFilter)
agcls.AgTypeNameMap["IBandOrderFilter"] = IBandOrderFilter

class IBlurFilter(object):
    """Applies a convolution filter to blur or smooth the source raster. Can be used to reduce noise in the raster."""
    _uuid = "{78e623b1-dc80-478d-acb8-a552fa136ccc}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_method"] = _raise_uninitialized_error
        self.__dict__["_set_method"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBlurFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBlurFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBlurFilter = agcom.GUID(IBlurFilter._uuid)
        vtable_offset_local = IBlurFilter._vtable_offset - 1
        self.__dict__["_get_method"] = IAGFUNCTYPE(pUnk, IID_IBlurFilter, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_method"] = IAGFUNCTYPE(pUnk, IID_IBlurFilter, vtable_offset_local+2, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBlurFilter.__dict__ and type(IBlurFilter.__dict__[attrname]) == property:
            return IBlurFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBlurFilter.")
    
    @property
    def method(self) -> "AgEStkGraphicsBlurMethod":
        """Gets or sets the method used to blur the source raster."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsBlurMethod) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_method"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @method.setter
    def method(self, method:"AgEStkGraphicsBlurMethod") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsBlurMethod, method) as arg_method:
            agcls.evaluate_hresult(self.__dict__["_set_method"](arg_method.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{78e623b1-dc80-478d-acb8-a552fa136ccc}", IBlurFilter)
agcls.AgTypeNameMap["IBlurFilter"] = IBlurFilter

class IBrightnessFilter(object):
    """Adjusts the brightness of the source raster's color bands. The adjustment to brightness is a value between -1 and 1, corresponding to least bright to most bright."""
    _uuid = "{fd8324ea-dbc2-42a5-88ba-c2769fd4a28e}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_adjustment"] = _raise_uninitialized_error
        self.__dict__["_set_adjustment"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBrightnessFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBrightnessFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBrightnessFilter = agcom.GUID(IBrightnessFilter._uuid)
        vtable_offset_local = IBrightnessFilter._vtable_offset - 1
        self.__dict__["_get_adjustment"] = IAGFUNCTYPE(pUnk, IID_IBrightnessFilter, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_adjustment"] = IAGFUNCTYPE(pUnk, IID_IBrightnessFilter, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBrightnessFilter.__dict__ and type(IBrightnessFilter.__dict__[attrname]) == property:
            return IBrightnessFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBrightnessFilter.")
    
    @property
    def adjustment(self) -> float:
        """Gets or sets the brightness adjustment value for the filter. The value must be between -1 and 1, corresponding to least bright to most bright."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_adjustment"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @adjustment.setter
    def adjustment(self, adjustment:float) -> None:
        with agmarshall.DOUBLE_arg(adjustment) as arg_adjustment:
            agcls.evaluate_hresult(self.__dict__["_set_adjustment"](arg_adjustment.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{fd8324ea-dbc2-42a5-88ba-c2769fd4a28e}", IBrightnessFilter)
agcls.AgTypeNameMap["IBrightnessFilter"] = IBrightnessFilter

class IColorToLuminanceFilter(object):
    """Extracts a luminance band derived from the color bands of the source raster."""
    _uuid = "{bc1d198f-705b-452b-8e51-1c600c547594}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IColorToLuminanceFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IColorToLuminanceFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IColorToLuminanceFilter = agcom.GUID(IColorToLuminanceFilter._uuid)
        vtable_offset_local = IColorToLuminanceFilter._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IColorToLuminanceFilter.__dict__ and type(IColorToLuminanceFilter.__dict__[attrname]) == property:
            return IColorToLuminanceFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IColorToLuminanceFilter.")
    

agcls.AgClassCatalog.add_catalog_entry("{bc1d198f-705b-452b-8e51-1c600c547594}", IColorToLuminanceFilter)
agcls.AgTypeNameMap["IColorToLuminanceFilter"] = IColorToLuminanceFilter

class IContrastFilter(object):
    """Adjusts the contrast of the source raster. The adjustment to contrast is a value between -1 and 1, corresponding to least contrast to most contrast."""
    _uuid = "{47ea43c3-5ffd-4935-8569-bb19ee6b0799}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_adjustment"] = _raise_uninitialized_error
        self.__dict__["_set_adjustment"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IContrastFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IContrastFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IContrastFilter = agcom.GUID(IContrastFilter._uuid)
        vtable_offset_local = IContrastFilter._vtable_offset - 1
        self.__dict__["_get_adjustment"] = IAGFUNCTYPE(pUnk, IID_IContrastFilter, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_adjustment"] = IAGFUNCTYPE(pUnk, IID_IContrastFilter, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IContrastFilter.__dict__ and type(IContrastFilter.__dict__[attrname]) == property:
            return IContrastFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IContrastFilter.")
    
    @property
    def adjustment(self) -> float:
        """Gets or sets the contrast adjustment value for the filter. The value must be between -1 and 1, corresponding to least contrast to most contrast."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_adjustment"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @adjustment.setter
    def adjustment(self, adjustment:float) -> None:
        with agmarshall.DOUBLE_arg(adjustment) as arg_adjustment:
            agcls.evaluate_hresult(self.__dict__["_set_adjustment"](arg_adjustment.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{47ea43c3-5ffd-4935-8569-bb19ee6b0799}", IContrastFilter)
agcls.AgTypeNameMap["IContrastFilter"] = IContrastFilter

class IConvolutionFilter(object):
    """Applies convolution to the source raster. Convolution is the modification of a pixel's value based on the values of its surrounding pixels. The kernel is the numerical matrix that is applied to each pixel in this process..."""
    _uuid = "{65e3646d-dfac-40af-b37f-15596ef13292}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_divisor"] = _raise_uninitialized_error
        self.__dict__["_set_divisor"] = _raise_uninitialized_error
        self.__dict__["_get_offset"] = _raise_uninitialized_error
        self.__dict__["_set_offset"] = _raise_uninitialized_error
        self.__dict__["_get_kernel"] = _raise_uninitialized_error
        self.__dict__["_set_kernel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConvolutionFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConvolutionFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConvolutionFilter = agcom.GUID(IConvolutionFilter._uuid)
        vtable_offset_local = IConvolutionFilter._vtable_offset - 1
        self.__dict__["_get_divisor"] = IAGFUNCTYPE(pUnk, IID_IConvolutionFilter, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_divisor"] = IAGFUNCTYPE(pUnk, IID_IConvolutionFilter, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_offset"] = IAGFUNCTYPE(pUnk, IID_IConvolutionFilter, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_offset"] = IAGFUNCTYPE(pUnk, IID_IConvolutionFilter, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_kernel"] = IAGFUNCTYPE(pUnk, IID_IConvolutionFilter, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_kernel"] = IAGFUNCTYPE(pUnk, IID_IConvolutionFilter, vtable_offset_local+6, agcom.SAFEARRAY)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConvolutionFilter.__dict__ and type(IConvolutionFilter.__dict__[attrname]) == property:
            return IConvolutionFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConvolutionFilter.")
    
    @property
    def divisor(self) -> float:
        """Gets or sets the divisor for the result of the convolution kernel operation."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_divisor"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @divisor.setter
    def divisor(self, divisor:float) -> None:
        with agmarshall.DOUBLE_arg(divisor) as arg_divisor:
            agcls.evaluate_hresult(self.__dict__["_set_divisor"](arg_divisor.COM_val))

    @property
    def offset(self) -> float:
        """Gets or sets the offset for the result of the convolution kernel operation. The value is added to the result of the operation."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_offset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @offset.setter
    def offset(self, offset:float) -> None:
        with agmarshall.DOUBLE_arg(offset) as arg_offset:
            agcls.evaluate_hresult(self.__dict__["_set_offset"](arg_offset.COM_val))

    @property
    def kernel(self) -> list:
        """Gets or sets the convolution kernel of the filter. The array contains the 9 elements of the kernel of the convolution matrix..."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_kernel"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @kernel.setter
    def kernel(self, kernel:list) -> None:
        with agmarshall.SAFEARRAY_arg(kernel) as arg_kernel:
            agcls.evaluate_hresult(self.__dict__["_set_kernel"](arg_kernel.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{65e3646d-dfac-40af-b37f-15596ef13292}", IConvolutionFilter)
agcls.AgTypeNameMap["IConvolutionFilter"] = IConvolutionFilter

class IEdgeDetectFilter(object):
    """Applies a convolution filter to detect edges in the source raster."""
    _uuid = "{0919d5b6-9497-4027-9fa2-69afe60c5f02}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_method"] = _raise_uninitialized_error
        self.__dict__["_set_method"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEdgeDetectFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEdgeDetectFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEdgeDetectFilter = agcom.GUID(IEdgeDetectFilter._uuid)
        vtable_offset_local = IEdgeDetectFilter._vtable_offset - 1
        self.__dict__["_get_method"] = IAGFUNCTYPE(pUnk, IID_IEdgeDetectFilter, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_method"] = IAGFUNCTYPE(pUnk, IID_IEdgeDetectFilter, vtable_offset_local+2, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEdgeDetectFilter.__dict__ and type(IEdgeDetectFilter.__dict__[attrname]) == property:
            return IEdgeDetectFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEdgeDetectFilter.")
    
    @property
    def method(self) -> "AgEStkGraphicsEdgeDetectMethod":
        """Gets or sets the method used to detect edges in the source raster."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsEdgeDetectMethod) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_method"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @method.setter
    def method(self, method:"AgEStkGraphicsEdgeDetectMethod") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsEdgeDetectMethod, method) as arg_method:
            agcls.evaluate_hresult(self.__dict__["_set_method"](arg_method.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0919d5b6-9497-4027-9fa2-69afe60c5f02}", IEdgeDetectFilter)
agcls.AgTypeNameMap["IEdgeDetectFilter"] = IEdgeDetectFilter

class IFilteringRasterStream(object):
    """A class decorator for applying a raster filter to each update of a raster stream. Can be used to apply filters to videos and other raster streams as they are updated."""
    _uuid = "{75917a6b-c2f9-4350-879a-248bcc239e6b}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_filter"] = _raise_uninitialized_error
        self.__dict__["_get_stream"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IFilteringRasterStream._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IFilteringRasterStream from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IFilteringRasterStream = agcom.GUID(IFilteringRasterStream._uuid)
        vtable_offset_local = IFilteringRasterStream._vtable_offset - 1
        self.__dict__["_get_filter"] = IAGFUNCTYPE(pUnk, IID_IFilteringRasterStream, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_stream"] = IAGFUNCTYPE(pUnk, IID_IFilteringRasterStream, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFilteringRasterStream.__dict__ and type(IFilteringRasterStream.__dict__[attrname]) == property:
            return IFilteringRasterStream.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFilteringRasterStream.")
    
    @property
    def filter(self) -> "IRasterFilter":
        """Gets the raster filter that will be applied to the raster stream on each update."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def stream(self) -> "IRasterStream":
        """Gets the raster stream that will have the raster filter applied on each update."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_stream"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{75917a6b-c2f9-4350-879a-248bcc239e6b}", IFilteringRasterStream)
agcls.AgTypeNameMap["IFilteringRasterStream"] = IFilteringRasterStream

class IFlipFilter(object):
    """Flips the source raster along the given flip axis."""
    _uuid = "{478edb08-272a-42b6-b486-a81a5bcaf92b}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_flip_axis"] = _raise_uninitialized_error
        self.__dict__["_set_flip_axis"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IFlipFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IFlipFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IFlipFilter = agcom.GUID(IFlipFilter._uuid)
        vtable_offset_local = IFlipFilter._vtable_offset - 1
        self.__dict__["_get_flip_axis"] = IAGFUNCTYPE(pUnk, IID_IFlipFilter, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_flip_axis"] = IAGFUNCTYPE(pUnk, IID_IFlipFilter, vtable_offset_local+2, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFlipFilter.__dict__ and type(IFlipFilter.__dict__[attrname]) == property:
            return IFlipFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFlipFilter.")
    
    @property
    def flip_axis(self) -> "AgEStkGraphicsFlipAxis":
        """Gets or sets the flip axis along which the source raster will be flipped."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsFlipAxis) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_flip_axis"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @flip_axis.setter
    def flip_axis(self, flipAxis:"AgEStkGraphicsFlipAxis") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsFlipAxis, flipAxis) as arg_flipAxis:
            agcls.evaluate_hresult(self.__dict__["_set_flip_axis"](arg_flipAxis.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{478edb08-272a-42b6-b486-a81a5bcaf92b}", IFlipFilter)
agcls.AgTypeNameMap["IFlipFilter"] = IFlipFilter

class IGammaCorrectionFilter(object):
    """Applies gamma correction to the source raster. The gamma is a value between .2 and 5. The default gamma value is 2.2."""
    _uuid = "{c4b3703d-c059-47c7-8b49-11bbedd7975a}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_gamma"] = _raise_uninitialized_error
        self.__dict__["_set_gamma"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGammaCorrectionFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGammaCorrectionFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGammaCorrectionFilter = agcom.GUID(IGammaCorrectionFilter._uuid)
        vtable_offset_local = IGammaCorrectionFilter._vtable_offset - 1
        self.__dict__["_get_gamma"] = IAGFUNCTYPE(pUnk, IID_IGammaCorrectionFilter, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_gamma"] = IAGFUNCTYPE(pUnk, IID_IGammaCorrectionFilter, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGammaCorrectionFilter.__dict__ and type(IGammaCorrectionFilter.__dict__[attrname]) == property:
            return IGammaCorrectionFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGammaCorrectionFilter.")
    
    @property
    def gamma(self) -> float:
        """Gets or sets the gamma value for the filter. The value must be between .2 and 5. The default gamma value is 2.2."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_gamma"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @gamma.setter
    def gamma(self, gamma:float) -> None:
        with agmarshall.DOUBLE_arg(gamma) as arg_gamma:
            agcls.evaluate_hresult(self.__dict__["_set_gamma"](arg_gamma.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{c4b3703d-c059-47c7-8b49-11bbedd7975a}", IGammaCorrectionFilter)
agcls.AgTypeNameMap["IGammaCorrectionFilter"] = IGammaCorrectionFilter

class IGaussianBlurFilter(object):
    """Applies a convolution filter to blur the source raster using the Gaussian function."""
    _uuid = "{b5b0a55e-980a-453f-b7b4-7c7024f92ef4}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGaussianBlurFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGaussianBlurFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGaussianBlurFilter = agcom.GUID(IGaussianBlurFilter._uuid)
        vtable_offset_local = IGaussianBlurFilter._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGaussianBlurFilter.__dict__ and type(IGaussianBlurFilter.__dict__[attrname]) == property:
            return IGaussianBlurFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGaussianBlurFilter.")
    

agcls.AgClassCatalog.add_catalog_entry("{b5b0a55e-980a-453f-b7b4-7c7024f92ef4}", IGaussianBlurFilter)
agcls.AgTypeNameMap["IGaussianBlurFilter"] = IGaussianBlurFilter

class IGradientDetectFilter(object):
    """Applies a convolution filter to detect gradients in the source raster."""
    _uuid = "{5a9e0d4c-4f36-47c8-8f81-ffdfe63cb112}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_method"] = _raise_uninitialized_error
        self.__dict__["_set_method"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGradientDetectFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGradientDetectFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGradientDetectFilter = agcom.GUID(IGradientDetectFilter._uuid)
        vtable_offset_local = IGradientDetectFilter._vtable_offset - 1
        self.__dict__["_get_method"] = IAGFUNCTYPE(pUnk, IID_IGradientDetectFilter, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_method"] = IAGFUNCTYPE(pUnk, IID_IGradientDetectFilter, vtable_offset_local+2, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGradientDetectFilter.__dict__ and type(IGradientDetectFilter.__dict__[attrname]) == property:
            return IGradientDetectFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGradientDetectFilter.")
    
    @property
    def method(self) -> "AgEStkGraphicsGradientDetectMethod":
        """Gets or sets the method used to detect gradients in the source raster."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsGradientDetectMethod) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_method"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @method.setter
    def method(self, method:"AgEStkGraphicsGradientDetectMethod") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsGradientDetectMethod, method) as arg_method:
            agcls.evaluate_hresult(self.__dict__["_set_method"](arg_method.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5a9e0d4c-4f36-47c8-8f81-ffdfe63cb112}", IGradientDetectFilter)
agcls.AgTypeNameMap["IGradientDetectFilter"] = IGradientDetectFilter

class ILevelsFilter(object):
    """Adjusts the band levels of the source raster linearly."""
    _uuid = "{e0d6dad5-cfcb-476a-95fd-2cd486114a68}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_set_level_adjustment"] = _raise_uninitialized_error
        self.__dict__["_clear_adjustments"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ILevelsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ILevelsFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ILevelsFilter = agcom.GUID(ILevelsFilter._uuid)
        vtable_offset_local = ILevelsFilter._vtable_offset - 1
        self.__dict__["_set_level_adjustment"] = IAGFUNCTYPE(pUnk, IID_ILevelsFilter, vtable_offset_local+1, agcom.LONG, agcom.INT)
        self.__dict__["_clear_adjustments"] = IAGFUNCTYPE(pUnk, IID_ILevelsFilter, vtable_offset_local+2, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ILevelsFilter.__dict__ and type(ILevelsFilter.__dict__[attrname]) == property:
            return ILevelsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ILevelsFilter.")
    
    def set_level_adjustment(self, band:"AgEStkGraphicsRasterBand", adjustment:int) -> None:
        """Sets the linear level adjustment value for the given raster band. Both negative and positive values are accepted."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsRasterBand, band) as arg_band, \
             agmarshall.INT_arg(adjustment) as arg_adjustment:
            agcls.evaluate_hresult(self.__dict__["_set_level_adjustment"](arg_band.COM_val, arg_adjustment.COM_val))

    def clear_adjustments(self) -> None:
        """Clears the level adjustment values for all bands."""
        agcls.evaluate_hresult(self.__dict__["_clear_adjustments"]())


agcls.AgClassCatalog.add_catalog_entry("{e0d6dad5-cfcb-476a-95fd-2cd486114a68}", ILevelsFilter)
agcls.AgTypeNameMap["ILevelsFilter"] = ILevelsFilter

class IProjectionRasterStreamPluginActivator(object):
    """The Activator class provides methods to load COM plugins that implement projection and raster streaming. For more information about the projection and raster plugins, see the STK Programming Interface."""
    _uuid = "{0c1e9236-42e6-4539-9003-06e06f906432}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_create_from_display_name"] = _raise_uninitialized_error
        self.__dict__["_get_available_display_names"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProjectionRasterStreamPluginActivator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProjectionRasterStreamPluginActivator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProjectionRasterStreamPluginActivator = agcom.GUID(IProjectionRasterStreamPluginActivator._uuid)
        vtable_offset_local = IProjectionRasterStreamPluginActivator._vtable_offset - 1
        self.__dict__["_create_from_display_name"] = IAGFUNCTYPE(pUnk, IID_IProjectionRasterStreamPluginActivator, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_available_display_names"] = IAGFUNCTYPE(pUnk, IID_IProjectionRasterStreamPluginActivator, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProjectionRasterStreamPluginActivator.__dict__ and type(IProjectionRasterStreamPluginActivator.__dict__[attrname]) == property:
            return IProjectionRasterStreamPluginActivator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProjectionRasterStreamPluginActivator.")
    
    def create_from_display_name(self, displayName:str) -> "IProjectionRasterStreamPluginProxy":
        """Loads a projection/raster COM plugin associated with the specified display name and returns a proxy object that allows accessing the raster and projection streams implemented by the plugin."""
        with agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_create_from_display_name"](arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_available_display_names(self) -> list:
        """Gets a list of available projection/raster plugins' Display Names (Programmatic Identifiers)."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_available_display_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{0c1e9236-42e6-4539-9003-06e06f906432}", IProjectionRasterStreamPluginActivator)
agcls.AgTypeNameMap["IProjectionRasterStreamPluginActivator"] = IProjectionRasterStreamPluginActivator

class IProjectionRasterStreamPluginProxy(object):
    """A proxy class provides access to the raster and projection streams implemented by a plugin. Proxies are instantiated using projection raster stream plugin activator."""
    _uuid = "{5a28d922-9211-4860-81ae-0d98d38ca6d7}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_raster_stream"] = _raise_uninitialized_error
        self.__dict__["_get_projection_stream"] = _raise_uninitialized_error
        self.__dict__["_get_is_raster_stream_supported"] = _raise_uninitialized_error
        self.__dict__["_get_is_projection_stream_supported"] = _raise_uninitialized_error
        self.__dict__["_get_real_plugin_object"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProjectionRasterStreamPluginProxy._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProjectionRasterStreamPluginProxy from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProjectionRasterStreamPluginProxy = agcom.GUID(IProjectionRasterStreamPluginProxy._uuid)
        vtable_offset_local = IProjectionRasterStreamPluginProxy._vtable_offset - 1
        self.__dict__["_get_raster_stream"] = IAGFUNCTYPE(pUnk, IID_IProjectionRasterStreamPluginProxy, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_projection_stream"] = IAGFUNCTYPE(pUnk, IID_IProjectionRasterStreamPluginProxy, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_is_raster_stream_supported"] = IAGFUNCTYPE(pUnk, IID_IProjectionRasterStreamPluginProxy, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_is_projection_stream_supported"] = IAGFUNCTYPE(pUnk, IID_IProjectionRasterStreamPluginProxy, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_real_plugin_object"] = IAGFUNCTYPE(pUnk, IID_IProjectionRasterStreamPluginProxy, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProjectionRasterStreamPluginProxy.__dict__ and type(IProjectionRasterStreamPluginProxy.__dict__[attrname]) == property:
            return IProjectionRasterStreamPluginProxy.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProjectionRasterStreamPluginProxy.")
    
    @property
    def raster_stream(self) -> "IRasterStream":
        """Returns a raster stream."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_raster_stream"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def projection_stream(self) -> "IProjectionStream":
        """Returns a projection stream."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_projection_stream"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def is_raster_stream_supported(self) -> bool:
        """Returns true if the raster streaming is supported."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_raster_stream_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def is_projection_stream_supported(self) -> bool:
        """Returns true if the projection streaming is supported."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_projection_stream_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def real_plugin_object(self) -> typing.Any:
        """Returns a pointer to plugin object's IUnknown interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_real_plugin_object"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5a28d922-9211-4860-81ae-0d98d38ca6d7}", IProjectionRasterStreamPluginProxy)
agcls.AgTypeNameMap["IProjectionRasterStreamPluginProxy"] = IProjectionRasterStreamPluginProxy

class IRaster(object):
    """A raster dataset. A raster consists of one or more bands, or sets of values, which are most commonly associated with colors when the raster represents an image..."""
    _uuid = "{e0113161-7dd5-4411-bca9-6175aad19b4e}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_attributes"] = _raise_uninitialized_error
        self.__dict__["_get_width"] = _raise_uninitialized_error
        self.__dict__["_get_height"] = _raise_uninitialized_error
        self.__dict__["_flip"] = _raise_uninitialized_error
        self.__dict__["_rotate"] = _raise_uninitialized_error
        self.__dict__["_apply"] = _raise_uninitialized_error
        self.__dict__["_apply_in_place"] = _raise_uninitialized_error
        self.__dict__["_extract_band"] = _raise_uninitialized_error
        self.__dict__["_extract_band_from_raster_format"] = _raise_uninitialized_error
        self.__dict__["_copy_from_raster"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRaster._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRaster from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRaster = agcom.GUID(IRaster._uuid)
        vtable_offset_local = IRaster._vtable_offset - 1
        self.__dict__["_get_attributes"] = IAGFUNCTYPE(pUnk, IID_IRaster, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_width"] = IAGFUNCTYPE(pUnk, IID_IRaster, vtable_offset_local+2, POINTER(agcom.INT))
        self.__dict__["_get_height"] = IAGFUNCTYPE(pUnk, IID_IRaster, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_flip"] = IAGFUNCTYPE(pUnk, IID_IRaster, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_rotate"] = IAGFUNCTYPE(pUnk, IID_IRaster, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_apply"] = IAGFUNCTYPE(pUnk, IID_IRaster, vtable_offset_local+6, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_apply_in_place"] = IAGFUNCTYPE(pUnk, IID_IRaster, vtable_offset_local+7, agcom.PVOID)
        self.__dict__["_extract_band"] = IAGFUNCTYPE(pUnk, IID_IRaster, vtable_offset_local+8, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_extract_band_from_raster_format"] = IAGFUNCTYPE(pUnk, IID_IRaster, vtable_offset_local+9, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_copy_from_raster"] = IAGFUNCTYPE(pUnk, IID_IRaster, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRaster.__dict__ and type(IRaster.__dict__[attrname]) == property:
            return IRaster.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRaster.")
    
    @property
    def attributes(self) -> "IRasterAttributes":
        """Gets the raster attributes that define the raster data."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_attributes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def width(self) -> int:
        """Gets the width of the raster in pixels."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def height(self) -> int:
        """Gets the height of the raster in pixels."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_height"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def flip(self, axis:"AgEStkGraphicsFlipAxis") -> None:
        """Flips the raster along the given axis."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsFlipAxis, axis) as arg_axis:
            agcls.evaluate_hresult(self.__dict__["_flip"](arg_axis.COM_val))

    def rotate(self, angle:float) -> None:
        """Rotates the raster by the given angle."""
        with agmarshall.DOUBLE_arg(angle) as arg_angle:
            agcls.evaluate_hresult(self.__dict__["_rotate"](arg_angle.COM_val))

    def apply(self, filter:"IRasterFilter") -> "IRaster":
        """Applies a raster filter to the raster and returns a new raster with the results of the filtering. The current raster is not modified."""
        with agmarshall.AgInterface_in_arg(filter, IRasterFilter) as arg_filter, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_apply"](arg_filter.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def apply_in_place(self, filter:"IRasterFilter") -> None:
        """Applies a raster filter to the raster. The current raster will contain the results of the filtering."""
        with agmarshall.AgInterface_in_arg(filter, IRasterFilter) as arg_filter:
            agcls.evaluate_hresult(self.__dict__["_apply_in_place"](arg_filter.COM_val))

    def extract_band(self, band:"AgEStkGraphicsRasterBand") -> "IRaster":
        """Extracts the band of raster data associated with the given raster band."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsRasterBand, band) as arg_band, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_extract_band"](arg_band.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def extract_band_from_raster_format(self, format:"AgEStkGraphicsRasterFormat") -> "IRaster":
        """Extracts the bands of raster data associated with the given raster format."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsRasterFormat, format) as arg_format, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_extract_band_from_raster_format"](arg_format.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def copy_from_raster(self, raster:"IRaster") -> None:
        """Copies the data associated with the given raster into this raster."""
        with agmarshall.AgInterface_in_arg(raster, IRaster) as arg_raster:
            agcls.evaluate_hresult(self.__dict__["_copy_from_raster"](arg_raster.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{e0113161-7dd5-4411-bca9-6175aad19b4e}", IRaster)
agcls.AgTypeNameMap["IRaster"] = IRaster

class IRasterAttributes(object):
    """The attributes describing a raster dataset. raster attributes define the memory layout of a raster, and includes properties defining the order of each raster band that the raster contains, as specified by the raster format..."""
    _uuid = "{067e0cd7-c1c5-41b7-93a8-f9ae8b67df25}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_format"] = _raise_uninitialized_error
        self.__dict__["_get_type"] = _raise_uninitialized_error
        self.__dict__["_get_orientation"] = _raise_uninitialized_error
        self.__dict__["_get_byte_length"] = _raise_uninitialized_error
        self.__dict__["_get_width"] = _raise_uninitialized_error
        self.__dict__["_get_height"] = _raise_uninitialized_error
        self.__dict__["_get_pixel_aspect_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_row_alignment"] = _raise_uninitialized_error
        self.__dict__["_get_number_of_bands"] = _raise_uninitialized_error
        self.__dict__["_get_row_stride"] = _raise_uninitialized_error
        self.__dict__["_has_band"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRasterAttributes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRasterAttributes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRasterAttributes = agcom.GUID(IRasterAttributes._uuid)
        vtable_offset_local = IRasterAttributes._vtable_offset - 1
        self.__dict__["_get_format"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributes, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_get_type"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributes, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_get_orientation"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributes, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_byte_length"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributes, vtable_offset_local+4, POINTER(agcom.INT))
        self.__dict__["_get_width"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributes, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__["_get_height"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributes, vtable_offset_local+6, POINTER(agcom.INT))
        self.__dict__["_get_pixel_aspect_ratio"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributes, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_get_row_alignment"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributes, vtable_offset_local+8, POINTER(agcom.INT))
        self.__dict__["_get_number_of_bands"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributes, vtable_offset_local+9, POINTER(agcom.INT))
        self.__dict__["_get_row_stride"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributes, vtable_offset_local+10, POINTER(agcom.INT))
        self.__dict__["_has_band"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributes, vtable_offset_local+11, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRasterAttributes.__dict__ and type(IRasterAttributes.__dict__[attrname]) == property:
            return IRasterAttributes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRasterAttributes.")
    
    @property
    def format(self) -> "AgEStkGraphicsRasterFormat":
        """Gets the raster format associated with the attributes."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsRasterFormat) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_format"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def type(self) -> "AgEStkGraphicsRasterType":
        """Gets the raster type associated with the attributes."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsRasterType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_type"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def orientation(self) -> "AgEStkGraphicsRasterOrientation":
        """Gets the raster orientation associated with the attributes."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsRasterOrientation) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_orientation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def byte_length(self) -> int:
        """Gets the size of the raster data in bytes."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_byte_length"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def width(self) -> int:
        """Gets the width of the raster in pixels."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def height(self) -> int:
        """Gets the height of the raster in pixels."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_height"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def pixel_aspect_ratio(self) -> float:
        """Gets the pixel aspect ratio of the raster."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_pixel_aspect_ratio"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def row_alignment(self) -> int:
        """Gets the row alignment of the raster data in bytes."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_row_alignment"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def number_of_bands(self) -> int:
        """Gets the number of bands comprising the raster."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_number_of_bands"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def row_stride(self) -> int:
        """Gets the stride or scan/row width in bytes of the raster data."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_row_stride"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def has_band(self, band:"AgEStkGraphicsRasterBand") -> bool:
        """Gets whether the raster contains the given band."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsRasterBand, band) as arg_band, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_has_band"](arg_band.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{067e0cd7-c1c5-41b7-93a8-f9ae8b67df25}", IRasterAttributes)
agcls.AgTypeNameMap["IRasterAttributes"] = IRasterAttributes

class IRasterFilter(object):
    """A filter for processing raster datasets. RasterFilter is the base class for all raster filters..."""
    _uuid = "{1d21525d-4204-47cc-8457-996e1a6eab7e}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRasterFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRasterFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRasterFilter = agcom.GUID(IRasterFilter._uuid)
        vtable_offset_local = IRasterFilter._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRasterFilter.__dict__ and type(IRasterFilter.__dict__[attrname]) == property:
            return IRasterFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRasterFilter.")
    

agcls.AgClassCatalog.add_catalog_entry("{1d21525d-4204-47cc-8457-996e1a6eab7e}", IRasterFilter)
agcls.AgTypeNameMap["IRasterFilter"] = IRasterFilter

class IRasterStream(object):
    """A raster, the data of which, is updated dynamically at the specified update delta. The class can be used to stream video and other dynamic raster data to textures and other raster clients..."""
    _uuid = "{63f024ca-7113-4841-8d26-7a286458bd7c}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_update_delta"] = _raise_uninitialized_error
        self.__dict__["_set_update_delta"] = _raise_uninitialized_error
        self.__dict__["_update"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRasterStream._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRasterStream from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRasterStream = agcom.GUID(IRasterStream._uuid)
        vtable_offset_local = IRasterStream._vtable_offset - 1
        self.__dict__["_get_update_delta"] = IAGFUNCTYPE(pUnk, IID_IRasterStream, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_update_delta"] = IAGFUNCTYPE(pUnk, IID_IRasterStream, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_update"] = IAGFUNCTYPE(pUnk, IID_IRasterStream, vtable_offset_local+3, agcom.PVOID, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRasterStream.__dict__ and type(IRasterStream.__dict__[attrname]) == property:
            return IRasterStream.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRasterStream.")
    
    @property
    def update_delta(self) -> float:
        """Gets or sets the update delta of the raster stream in seconds. The update delta defines the interval at which the Update method will be called. The default update delta is 0, which will call the Update method every time the scene manager time changes..."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_update_delta"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @update_delta.setter
    def update_delta(self, updateDelta:float) -> None:
        with agmarshall.DOUBLE_arg(updateDelta) as arg_updateDelta:
            agcls.evaluate_hresult(self.__dict__["_set_update_delta"](arg_updateDelta.COM_val))

    def update(self, time:"IDate", nextTime:"IDate") -> bool:
        """When overridden in a derived class, updates the raster data associated with the raster stream at the specified time..."""
        with agmarshall.AgInterface_in_arg(time, IDate) as arg_time, \
             agmarshall.AgInterface_in_arg(nextTime, IDate) as arg_nextTime, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_update"](arg_time.COM_val, arg_nextTime.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{63f024ca-7113-4841-8d26-7a286458bd7c}", IRasterStream)
agcls.AgTypeNameMap["IRasterStream"] = IRasterStream

class IRotateFilter(object):
    """Rotates the source raster clockwise by the specified angle."""
    _uuid = "{4b6dc620-04e1-4956-be55-890fdb25bd40}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_angle"] = _raise_uninitialized_error
        self.__dict__["_set_angle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRotateFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRotateFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRotateFilter = agcom.GUID(IRotateFilter._uuid)
        vtable_offset_local = IRotateFilter._vtable_offset - 1
        self.__dict__["_get_angle"] = IAGFUNCTYPE(pUnk, IID_IRotateFilter, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_angle"] = IAGFUNCTYPE(pUnk, IID_IRotateFilter, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRotateFilter.__dict__ and type(IRotateFilter.__dict__[attrname]) == property:
            return IRotateFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRotateFilter.")
    
    @property
    def angle(self) -> float:
        """Gets or sets the counterclockwise rotation angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_angle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @angle.setter
    def angle(self, angle:float) -> None:
        with agmarshall.DOUBLE_arg(angle) as arg_angle:
            agcls.evaluate_hresult(self.__dict__["_set_angle"](arg_angle.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4b6dc620-04e1-4956-be55-890fdb25bd40}", IRotateFilter)
agcls.AgTypeNameMap["IRotateFilter"] = IRotateFilter

class ISequenceFilter(object):
    """Applies a sequence of filters to the source raster in the order in which they were added. When continue on failure is set to true, subsequent filters will still be applied to the source raster even if one or more filters in the sequence cannot be applied."""
    _uuid = "{72e2b4cb-2be3-418e-b0c8-69f33164e475}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_continue_on_failure"] = _raise_uninitialized_error
        self.__dict__["_set_continue_on_failure"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_clear"] = _raise_uninitialized_error
        self.__dict__["_contains"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISequenceFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISequenceFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISequenceFilter = agcom.GUID(ISequenceFilter._uuid)
        vtable_offset_local = ISequenceFilter._vtable_offset - 1
        self.__dict__["_get_continue_on_failure"] = IAGFUNCTYPE(pUnk, IID_ISequenceFilter, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_continue_on_failure"] = IAGFUNCTYPE(pUnk, IID_ISequenceFilter, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ISequenceFilter, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_ISequenceFilter, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_ISequenceFilter, vtable_offset_local+5, agcom.PVOID)
        self.__dict__["_clear"] = IAGFUNCTYPE(pUnk, IID_ISequenceFilter, vtable_offset_local+6, )
        self.__dict__["_contains"] = IAGFUNCTYPE(pUnk, IID_ISequenceFilter, vtable_offset_local+7, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISequenceFilter.__dict__ and type(ISequenceFilter.__dict__[attrname]) == property:
            return ISequenceFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISequenceFilter.")
    
    @property
    def continue_on_failure(self) -> bool:
        """Gets or sets whether to continue applying filters in the sequence regardless of individual filter failures. When set to true, subsequent filters will still be applied to the source raster even if one or more filters in the sequence cannot be applied."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_continue_on_failure"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @continue_on_failure.setter
    def continue_on_failure(self, continueOnFailure:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(continueOnFailure) as arg_continueOnFailure:
            agcls.evaluate_hresult(self.__dict__["_set_continue_on_failure"](arg_continueOnFailure.COM_val))

    @property
    def count(self) -> int:
        """Gets the number of filters in the collection."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def add(self, filter:"IRasterFilter") -> None:
        """Adds a filter to the sequence."""
        with agmarshall.AgInterface_in_arg(filter, IRasterFilter) as arg_filter:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_filter.COM_val))

    def remove(self, filter:"IRasterFilter") -> None:
        """Removes a filter from the sequence."""
        with agmarshall.AgInterface_in_arg(filter, IRasterFilter) as arg_filter:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_filter.COM_val))

    def clear(self) -> None:
        """Clears all filters from the sequence."""
        agcls.evaluate_hresult(self.__dict__["_clear"]())

    def contains(self, filter:"IRasterFilter") -> bool:
        """Returns true if the sequence contains the filter."""
        with agmarshall.AgInterface_in_arg(filter, IRasterFilter) as arg_filter, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_contains"](arg_filter.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{72e2b4cb-2be3-418e-b0c8-69f33164e475}", ISequenceFilter)
agcls.AgTypeNameMap["ISequenceFilter"] = ISequenceFilter

class ISharpenFilter(object):
    """Applies a convolution filter to increase the sharpness of the source raster."""
    _uuid = "{927e244d-ace0-4387-8e3e-6f14bfe230eb}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_method"] = _raise_uninitialized_error
        self.__dict__["_set_method"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISharpenFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISharpenFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISharpenFilter = agcom.GUID(ISharpenFilter._uuid)
        vtable_offset_local = ISharpenFilter._vtable_offset - 1
        self.__dict__["_get_method"] = IAGFUNCTYPE(pUnk, IID_ISharpenFilter, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_method"] = IAGFUNCTYPE(pUnk, IID_ISharpenFilter, vtable_offset_local+2, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISharpenFilter.__dict__ and type(ISharpenFilter.__dict__[attrname]) == property:
            return ISharpenFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISharpenFilter.")
    
    @property
    def method(self) -> "AgEStkGraphicsSharpenMethod":
        """Gets or sets the method used to sharpen the source raster."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSharpenMethod) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_method"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @method.setter
    def method(self, method:"AgEStkGraphicsSharpenMethod") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsSharpenMethod, method) as arg_method:
            agcls.evaluate_hresult(self.__dict__["_set_method"](arg_method.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{927e244d-ace0-4387-8e3e-6f14bfe230eb}", ISharpenFilter)
agcls.AgTypeNameMap["ISharpenFilter"] = ISharpenFilter

class IVideoStream(object):
    """A raster stream that streams from a video. The video can be read from a file, or streamed from an HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""
    _uuid = "{95fcc91e-a95a-48c4-a34f-9ed67f8e4f4a}"
    _num_methods = 35
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_uri"] = _raise_uninitialized_error
        self.__dict__["_get_playback"] = _raise_uninitialized_error
        self.__dict__["_set_playback"] = _raise_uninitialized_error
        self.__dict__["_get_frame_rate"] = _raise_uninitialized_error
        self.__dict__["_set_frame_rate"] = _raise_uninitialized_error
        self.__dict__["_get_interval_start_time"] = _raise_uninitialized_error
        self.__dict__["_set_interval_start_time"] = _raise_uninitialized_error
        self.__dict__["_get_interval_end_time"] = _raise_uninitialized_error
        self.__dict__["_set_interval_end_time"] = _raise_uninitialized_error
        self.__dict__["_get_start_time"] = _raise_uninitialized_error
        self.__dict__["_set_start_time"] = _raise_uninitialized_error
        self.__dict__["_get_end_time"] = _raise_uninitialized_error
        self.__dict__["_set_end_time"] = _raise_uninitialized_error
        self.__dict__["_get_start_frame"] = _raise_uninitialized_error
        self.__dict__["_set_start_frame"] = _raise_uninitialized_error
        self.__dict__["_get_end_frame"] = _raise_uninitialized_error
        self.__dict__["_set_end_frame"] = _raise_uninitialized_error
        self.__dict__["_get_loop"] = _raise_uninitialized_error
        self.__dict__["_set_loop"] = _raise_uninitialized_error
        self.__dict__["_get_is_playing"] = _raise_uninitialized_error
        self.__dict__["_get_packet_acquirement_yield_time"] = _raise_uninitialized_error
        self.__dict__["_set_packet_acquirement_yield_time"] = _raise_uninitialized_error
        self.__dict__["_get_packet_buffer_limit"] = _raise_uninitialized_error
        self.__dict__["_set_packet_buffer_limit"] = _raise_uninitialized_error
        self.__dict__["_get_allow_frame_drop"] = _raise_uninitialized_error
        self.__dict__["_set_allow_frame_drop"] = _raise_uninitialized_error
        self.__dict__["_get_enable_audio"] = _raise_uninitialized_error
        self.__dict__["_set_enable_audio"] = _raise_uninitialized_error
        self.__dict__["_reinitialize_with_string_uri"] = _raise_uninitialized_error
        self.__dict__["_play"] = _raise_uninitialized_error
        self.__dict__["_pause"] = _raise_uninitialized_error
        self.__dict__["_stop"] = _raise_uninitialized_error
        self.__dict__["_reset"] = _raise_uninitialized_error
        self.__dict__["_close"] = _raise_uninitialized_error
        self.__dict__["_get_audio_uri"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVideoStream._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVideoStream from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVideoStream = agcom.GUID(IVideoStream._uuid)
        vtable_offset_local = IVideoStream._vtable_offset - 1
        self.__dict__["_get_uri"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_get_playback"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_set_playback"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_get_frame_rate"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_frame_rate"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_interval_start_time"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_set_interval_start_time"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+7, agcom.PVOID)
        self.__dict__["_get_interval_end_time"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_set_interval_end_time"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+9, agcom.PVOID)
        self.__dict__["_get_start_time"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_start_time"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_end_time"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_end_time"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_start_frame"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+14, POINTER(agcom.INT))
        self.__dict__["_set_start_frame"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+15, agcom.INT)
        self.__dict__["_get_end_frame"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+16, POINTER(agcom.INT))
        self.__dict__["_set_end_frame"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+17, agcom.INT)
        self.__dict__["_get_loop"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_loop"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+19, agcom.VARIANT_BOOL)
        self.__dict__["_get_is_playing"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+20, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_packet_acquirement_yield_time"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+21, POINTER(agcom.INT))
        self.__dict__["_set_packet_acquirement_yield_time"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+22, agcom.INT)
        self.__dict__["_get_packet_buffer_limit"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+23, POINTER(agcom.INT))
        self.__dict__["_set_packet_buffer_limit"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+24, agcom.INT)
        self.__dict__["_get_allow_frame_drop"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+25, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_allow_frame_drop"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+26, agcom.VARIANT_BOOL)
        self.__dict__["_get_enable_audio"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+27, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_audio"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+28, agcom.VARIANT_BOOL)
        self.__dict__["_reinitialize_with_string_uri"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+29, agcom.BSTR)
        self.__dict__["_play"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+30, )
        self.__dict__["_pause"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+31, )
        self.__dict__["_stop"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+32, )
        self.__dict__["_reset"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+33, )
        self.__dict__["_close"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+34, )
        self.__dict__["_get_audio_uri"] = IAGFUNCTYPE(pUnk, IID_IVideoStream, vtable_offset_local+35, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVideoStream.__dict__ and type(IVideoStream.__dict__[attrname]) == property:
            return IVideoStream.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVideoStream.")
    
    @property
    def uri(self) -> str:
        """Gets the uri of the video."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_uri"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def playback(self) -> "AgEStkGraphicsVideoPlayback":
        """Gets or sets the video playback mode of the video."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsVideoPlayback) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_playback"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @playback.setter
    def playback(self, playback:"AgEStkGraphicsVideoPlayback") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsVideoPlayback, playback) as arg_playback:
            agcls.evaluate_hresult(self.__dict__["_set_playback"](arg_playback.COM_val))

    @property
    def frame_rate(self) -> float:
        """Gets or sets the frame rate of the video when the playback property is set to real time. If this property is not set, the internal framerate of the video is used."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_frame_rate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @frame_rate.setter
    def frame_rate(self, frameRate:float) -> None:
        with agmarshall.DOUBLE_arg(frameRate) as arg_frameRate:
            agcls.evaluate_hresult(self.__dict__["_set_frame_rate"](arg_frameRate.COM_val))

    @property
    def interval_start_time(self) -> "IDate":
        """Gets or sets the scene manager time at which the video will begin playing when the playback property is set to time interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_interval_start_time"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @interval_start_time.setter
    def interval_start_time(self, intervalStartTime:"IDate") -> None:
        with agmarshall.AgInterface_in_arg(intervalStartTime, IDate) as arg_intervalStartTime:
            agcls.evaluate_hresult(self.__dict__["_set_interval_start_time"](arg_intervalStartTime.COM_val))

    @property
    def interval_end_time(self) -> "IDate":
        """Gets or sets the scene manager time at which the video will stop playing when the playback property is set to time interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_interval_end_time"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @interval_end_time.setter
    def interval_end_time(self, intervalEndTime:"IDate") -> None:
        with agmarshall.AgInterface_in_arg(intervalEndTime, IDate) as arg_intervalEndTime:
            agcls.evaluate_hresult(self.__dict__["_set_interval_end_time"](arg_intervalEndTime.COM_val))

    @property
    def start_time(self) -> float:
        """Gets or sets the start time of the video in seconds. Changing the start time property also changes the start frame property to the frame in the video that corresponds to the specified time."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_start_time"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @start_time.setter
    def start_time(self, startTime:float) -> None:
        with agmarshall.DOUBLE_arg(startTime) as arg_startTime:
            agcls.evaluate_hresult(self.__dict__["_set_start_time"](arg_startTime.COM_val))

    @property
    def end_time(self) -> float:
        """Gets or sets the end time of the video in seconds. Changing the end time property also changes the end frame property to the frame in the video that corresponds to the specified time."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_end_time"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @end_time.setter
    def end_time(self, endTime:float) -> None:
        with agmarshall.DOUBLE_arg(endTime) as arg_endTime:
            agcls.evaluate_hresult(self.__dict__["_set_end_time"](arg_endTime.COM_val))

    @property
    def start_frame(self) -> int:
        """Gets or sets the start frame of the video. Changing the start frame property also changes the start time property to the time in the video that corresponds to the specified frame."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_start_frame"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @start_frame.setter
    def start_frame(self, startFrame:int) -> None:
        with agmarshall.INT_arg(startFrame) as arg_startFrame:
            agcls.evaluate_hresult(self.__dict__["_set_start_frame"](arg_startFrame.COM_val))

    @property
    def end_frame(self) -> int:
        """Gets or sets the end frame of the video. Changing the end frame property also changes the end time property to the time in the video that corresponds to the specified frame."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_end_frame"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @end_frame.setter
    def end_frame(self, endFrame:int) -> None:
        with agmarshall.INT_arg(endFrame) as arg_endFrame:
            agcls.evaluate_hresult(self.__dict__["_set_end_frame"](arg_endFrame.COM_val))

    @property
    def loop(self) -> bool:
        """Gets or sets whether the video will loop when it reaches its last frame when the playback property is set to real time."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_loop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @loop.setter
    def loop(self, loop:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(loop) as arg_loop:
            agcls.evaluate_hresult(self.__dict__["_set_loop"](arg_loop.COM_val))

    @property
    def is_playing(self) -> bool:
        """Gets whether or not the video is playing. Use the play, pause, stop, and Reset methods to control the playback of the video when the playback property is set to real time."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_playing"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def packet_acquirement_yield_time(self) -> int:
        """Gets or sets the thread processing yield time for asynchronous streaming of video over common protocols like udp. Setting a high value may increase performance, but may cause frames or packets to drop, effecting visual quality..."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_packet_acquirement_yield_time"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @packet_acquirement_yield_time.setter
    def packet_acquirement_yield_time(self, packetAcquirementYieldTime:int) -> None:
        with agmarshall.INT_arg(packetAcquirementYieldTime) as arg_packetAcquirementYieldTime:
            agcls.evaluate_hresult(self.__dict__["_set_packet_acquirement_yield_time"](arg_packetAcquirementYieldTime.COM_val))

    @property
    def packet_buffer_limit(self) -> int:
        """Gets or sets a value indicating the buffering limit for packets when processing a video stream..."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_packet_buffer_limit"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @packet_buffer_limit.setter
    def packet_buffer_limit(self, packetBufferLimit:int) -> None:
        with agmarshall.INT_arg(packetBufferLimit) as arg_packetBufferLimit:
            agcls.evaluate_hresult(self.__dict__["_set_packet_buffer_limit"](arg_packetBufferLimit.COM_val))

    @property
    def allow_frame_drop(self) -> bool:
        """Gets or sets a value indicating if frames should be dropped if video processing can not keep up with a video stream. If this is set to false, the video quality may degrade when the processing load is too high..."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_allow_frame_drop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @allow_frame_drop.setter
    def allow_frame_drop(self, allowFrameDrop:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(allowFrameDrop) as arg_allowFrameDrop:
            agcls.evaluate_hresult(self.__dict__["_set_allow_frame_drop"](arg_allowFrameDrop.COM_val))

    @property
    def enable_audio(self) -> bool:
        """Gets or sets a value indicating if the encoded audio stream should be synchronized to video playback If this is set to false, the audio stream will be disabled..."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_audio"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @enable_audio.setter
    def enable_audio(self, enableAudio:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(enableAudio) as arg_enableAudio:
            agcls.evaluate_hresult(self.__dict__["_set_enable_audio"](arg_enableAudio.COM_val))

    def reinitialize_with_string_uri(self, uri:str) -> None:
        """Reinitializes the video stream from a Uri, which can be a file, HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""
        with agmarshall.BSTR_arg(uri) as arg_uri:
            agcls.evaluate_hresult(self.__dict__["_reinitialize_with_string_uri"](arg_uri.COM_val))

    def play(self) -> None:
        """Begins playing the video when the playback property is set to real time."""
        agcls.evaluate_hresult(self.__dict__["_play"]())

    def pause(self) -> None:
        """Pauses the video when the playback property is set to real time."""
        agcls.evaluate_hresult(self.__dict__["_pause"]())

    def stop(self) -> None:
        """Stops the video when the playback property is set to real time. Stopping the video will seek to the first frame and pause playback. Use the Play method to begin playing the video again."""
        agcls.evaluate_hresult(self.__dict__["_stop"]())

    def reset(self) -> None:
        """Seeks the video to its first frame and begins playing the video when the playback property is set to real time."""
        agcls.evaluate_hresult(self.__dict__["_reset"]())

    def close(self) -> None:
        """Closes the video stream and any associated resources."""
        agcls.evaluate_hresult(self.__dict__["_close"]())

    @property
    def audio_uri(self) -> str:
        """Gets the uri of the audio."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_audio_uri"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{95fcc91e-a95a-48c4-a34f-9ed67f8e4f4a}", IVideoStream)
agcls.AgTypeNameMap["IVideoStream"] = IVideoStream

class IKmlContainer(object):
    """A KmlContainer contains a collection of children kml features."""
    _uuid = "{32147ba1-8610-4270-9365-b8966730dd6f}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_children"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IKmlContainer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IKmlContainer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IKmlContainer = agcom.GUID(IKmlContainer._uuid)
        vtable_offset_local = IKmlContainer._vtable_offset - 1
        self.__dict__["_get_children"] = IAGFUNCTYPE(pUnk, IID_IKmlContainer, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IKmlContainer.__dict__ and type(IKmlContainer.__dict__[attrname]) == property:
            return IKmlContainer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IKmlContainer.")
    
    @property
    def children(self) -> "IKmlFeatureCollection":
        """The collection of kml features that are children of this container."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_children"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{32147ba1-8610-4270-9365-b8966730dd6f}", IKmlContainer)
agcls.AgTypeNameMap["IKmlContainer"] = IKmlContainer

class IKmlDocument(object):
    """A KML document."""
    _uuid = "{2e284efe-3dda-4fac-91ab-7b8c84eb3ad2}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_uri"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IKmlDocument._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IKmlDocument from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IKmlDocument = agcom.GUID(IKmlDocument._uuid)
        vtable_offset_local = IKmlDocument._vtable_offset - 1
        self.__dict__["_get_uri"] = IAGFUNCTYPE(pUnk, IID_IKmlDocument, vtable_offset_local+1, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IKmlDocument.__dict__ and type(IKmlDocument.__dict__[attrname]) == property:
            return IKmlDocument.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IKmlDocument.")
    
    @property
    def uri(self) -> str:
        """Gets the uri of the document."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_uri"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2e284efe-3dda-4fac-91ab-7b8c84eb3ad2}", IKmlDocument)
agcls.AgTypeNameMap["IKmlDocument"] = IKmlDocument

class IKmlFeature(object):
    """A KML feature."""
    _uuid = "{bc7646ca-da52-4a62-8ef4-838382f21a08}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_is_loaded"] = _raise_uninitialized_error
        self.__dict__["_get_display"] = _raise_uninitialized_error
        self.__dict__["_set_display"] = _raise_uninitialized_error
        self.__dict__["_get_content"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_description"] = _raise_uninitialized_error
        self.__dict__["_get_snippet"] = _raise_uninitialized_error
        self.__dict__["_get_bounding_sphere"] = _raise_uninitialized_error
        self.__dict__["_fly_to"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IKmlFeature._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IKmlFeature from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IKmlFeature = agcom.GUID(IKmlFeature._uuid)
        vtable_offset_local = IKmlFeature._vtable_offset - 1
        self.__dict__["_get_is_loaded"] = IAGFUNCTYPE(pUnk, IID_IKmlFeature, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_display"] = IAGFUNCTYPE(pUnk, IID_IKmlFeature, vtable_offset_local+2, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display"] = IAGFUNCTYPE(pUnk, IID_IKmlFeature, vtable_offset_local+3, agcom.VARIANT_BOOL)
        self.__dict__["_get_content"] = IAGFUNCTYPE(pUnk, IID_IKmlFeature, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IKmlFeature, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_get_description"] = IAGFUNCTYPE(pUnk, IID_IKmlFeature, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_get_snippet"] = IAGFUNCTYPE(pUnk, IID_IKmlFeature, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_get_bounding_sphere"] = IAGFUNCTYPE(pUnk, IID_IKmlFeature, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_fly_to"] = IAGFUNCTYPE(pUnk, IID_IKmlFeature, vtable_offset_local+9, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IKmlFeature.__dict__ and type(IKmlFeature.__dict__[attrname]) == property:
            return IKmlFeature.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IKmlFeature.")
    
    @property
    def is_loaded(self) -> bool:
        """Gets whether the document associated with this feature is loaded."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_loaded"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def display(self) -> bool:
        """Gets or sets whether this feature will be displayed in the Scene."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display.setter
    def display(self, display:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(display) as arg_display:
            agcls.evaluate_hresult(self.__dict__["_set_display"](arg_display.COM_val))

    @property
    def content(self) -> str:
        """Gets the content associated with this feature."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_content"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def name(self) -> str:
        """Gets the name of this feature."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def description(self) -> str:
        """Gets the description associated with this feature."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_description"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def snippet(self) -> str:
        """Gets the snippet associated with this feature."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_snippet"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def bounding_sphere(self) -> "IBoundingSphere":
        """The bounding sphere encompassing the area associated with this feature."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_bounding_sphere"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def fly_to(self) -> None:
        """Moves the camera to the area encompassing this feature."""
        agcls.evaluate_hresult(self.__dict__["_fly_to"]())


agcls.AgClassCatalog.add_catalog_entry("{bc7646ca-da52-4a62-8ef4-838382f21a08}", IKmlFeature)
agcls.AgTypeNameMap["IKmlFeature"] = IKmlFeature

class IKmlFolder(object):
    """A KML folder."""
    _uuid = "{28b2dfb1-4f4c-4697-a0f9-076ebd92eb1f}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IKmlFolder._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IKmlFolder from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IKmlFolder = agcom.GUID(IKmlFolder._uuid)
        vtable_offset_local = IKmlFolder._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IKmlFolder.__dict__ and type(IKmlFolder.__dict__[attrname]) == property:
            return IKmlFolder.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IKmlFolder.")
    

agcls.AgClassCatalog.add_catalog_entry("{28b2dfb1-4f4c-4697-a0f9-076ebd92eb1f}", IKmlFolder)
agcls.AgTypeNameMap["IKmlFolder"] = IKmlFolder

class IKmlGraphics(object):
    """Provides loading and unloading of kml documents for a particular central body."""
    _uuid = "{056eb708-4504-4d62-b4d8-3ca00b0b91fa}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_documents"] = _raise_uninitialized_error
        self.__dict__["_load_document"] = _raise_uninitialized_error
        self.__dict__["_load_document_string"] = _raise_uninitialized_error
        self.__dict__["_load"] = _raise_uninitialized_error
        self.__dict__["_load_document_async"] = _raise_uninitialized_error
        self.__dict__["_load_document_async_string"] = _raise_uninitialized_error
        self.__dict__["_load_async"] = _raise_uninitialized_error
        self.__dict__["_unload"] = _raise_uninitialized_error
        self.__dict__["_unload_all"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IKmlGraphics._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IKmlGraphics from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IKmlGraphics = agcom.GUID(IKmlGraphics._uuid)
        vtable_offset_local = IKmlGraphics._vtable_offset - 1
        self.__dict__["_get_documents"] = IAGFUNCTYPE(pUnk, IID_IKmlGraphics, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_load_document"] = IAGFUNCTYPE(pUnk, IID_IKmlGraphics, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_load_document_string"] = IAGFUNCTYPE(pUnk, IID_IKmlGraphics, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_load"] = IAGFUNCTYPE(pUnk, IID_IKmlGraphics, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_load_document_async"] = IAGFUNCTYPE(pUnk, IID_IKmlGraphics, vtable_offset_local+5, agcom.BSTR)
        self.__dict__["_load_document_async_string"] = IAGFUNCTYPE(pUnk, IID_IKmlGraphics, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_load_async"] = IAGFUNCTYPE(pUnk, IID_IKmlGraphics, vtable_offset_local+7, agcom.BSTR)
        self.__dict__["_unload"] = IAGFUNCTYPE(pUnk, IID_IKmlGraphics, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_unload_all"] = IAGFUNCTYPE(pUnk, IID_IKmlGraphics, vtable_offset_local+9, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IKmlGraphics.__dict__ and type(IKmlGraphics.__dict__[attrname]) == property:
            return IKmlGraphics.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IKmlGraphics.")
    def Subscribe(self) -> IKmlGraphicsEventHandler:
        """Returns an IKmlGraphicsEventHandler that is subscribed to handle events associated with this instance of IKmlGraphics."""
        return IKmlGraphicsEventHandler(self._pUnk)    
    @property
    def documents(self) -> "IKmlDocumentCollection":
        """The collection of kml documents that are currently loaded."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_documents"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def load_document(self, kmlUri:str) -> "IKmlDocument":
        """Loads a kml document from a uri."""
        with agmarshall.BSTR_arg(kmlUri) as arg_kmlUri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_load_document"](arg_kmlUri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def load_document_string(self, kmlUri:str) -> "IKmlDocument":
        """Loads a kml document from a Uri."""
        with agmarshall.BSTR_arg(kmlUri) as arg_kmlUri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_load_document_string"](arg_kmlUri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def load(self, kmlDocument:str) -> "IKmlDocument":
        """Loads a kml document from a string containing the document."""
        with agmarshall.BSTR_arg(kmlDocument) as arg_kmlDocument, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_load"](arg_kmlDocument.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def load_document_async(self, kmlUri:str) -> None:
        """Loads a kml document asynchronously from a uri. The document loaded event is raised when the document is loaded."""
        with agmarshall.BSTR_arg(kmlUri) as arg_kmlUri:
            agcls.evaluate_hresult(self.__dict__["_load_document_async"](arg_kmlUri.COM_val))

    def load_document_async_string(self, kmlUri:str) -> None:
        """Loads a kml document asynchronously from a Uri. The document loaded event is raised when the document is loaded."""
        with agmarshall.BSTR_arg(kmlUri) as arg_kmlUri:
            agcls.evaluate_hresult(self.__dict__["_load_document_async_string"](arg_kmlUri.COM_val))

    def load_async(self, kmlDocument:str) -> None:
        """Loads a kml document asynchronously from a string containing the document. The document loaded event is raised when the document is loaded."""
        with agmarshall.BSTR_arg(kmlDocument) as arg_kmlDocument:
            agcls.evaluate_hresult(self.__dict__["_load_async"](arg_kmlDocument.COM_val))

    def unload(self, kmlDocument:"IKmlDocument") -> None:
        """Unloads a kml document. All associated visual features will be removed from the Scene. Once a KmlDocument is unloaded, it is no longer valid and will throw when accessing properties or methods."""
        with agmarshall.AgInterface_in_arg(kmlDocument, IKmlDocument) as arg_kmlDocument:
            agcls.evaluate_hresult(self.__dict__["_unload"](arg_kmlDocument.COM_val))

    def unload_all(self) -> None:
        """Unloads all kml documents associated with this central body. All associated visual features will be removed from the Scene. Once a KmlDocument is unloaded, it is no longer valid and will throw when accessing properties or methods."""
        agcls.evaluate_hresult(self.__dict__["_unload_all"]())


agcls.AgClassCatalog.add_catalog_entry("{056eb708-4504-4d62-b4d8-3ca00b0b91fa}", IKmlGraphics)
agcls.AgTypeNameMap["IKmlGraphics"] = IKmlGraphics

class IKmlNetworkLink(object):
    """A KML network link."""
    _uuid = "{0b66ea82-dd0d-444f-b097-dda9427e1b87}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_uri"] = _raise_uninitialized_error
        self.__dict__["_get_refresh_mode"] = _raise_uninitialized_error
        self.__dict__["_set_refresh_mode"] = _raise_uninitialized_error
        self.__dict__["_get_refresh_interval"] = _raise_uninitialized_error
        self.__dict__["_set_refresh_interval"] = _raise_uninitialized_error
        self.__dict__["_get_view_refresh_mode"] = _raise_uninitialized_error
        self.__dict__["_set_view_refresh_mode"] = _raise_uninitialized_error
        self.__dict__["_get_view_refresh_time"] = _raise_uninitialized_error
        self.__dict__["_set_view_refresh_time"] = _raise_uninitialized_error
        self.__dict__["_get_view_bound_scale"] = _raise_uninitialized_error
        self.__dict__["_set_view_bound_scale"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_refresh_period"] = _raise_uninitialized_error
        self.__dict__["_get_cookie"] = _raise_uninitialized_error
        self.__dict__["_get_message"] = _raise_uninitialized_error
        self.__dict__["_get_link_snippet"] = _raise_uninitialized_error
        self.__dict__["_get_expires"] = _raise_uninitialized_error
        self.__dict__["_refresh"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IKmlNetworkLink._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IKmlNetworkLink from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IKmlNetworkLink = agcom.GUID(IKmlNetworkLink._uuid)
        vtable_offset_local = IKmlNetworkLink._vtable_offset - 1
        self.__dict__["_get_uri"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_get_refresh_mode"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_set_refresh_mode"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_get_refresh_interval"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_refresh_interval"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_view_refresh_mode"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_set_view_refresh_mode"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_get_view_refresh_time"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_view_refresh_time"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_get_view_bound_scale"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_view_bound_scale"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_minimum_refresh_period"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_get_cookie"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+13, POINTER(agcom.BSTR))
        self.__dict__["_get_message"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+14, POINTER(agcom.BSTR))
        self.__dict__["_get_link_snippet"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+15, POINTER(agcom.BSTR))
        self.__dict__["_get_expires"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+16, POINTER(agcom.BSTR))
        self.__dict__["_refresh"] = IAGFUNCTYPE(pUnk, IID_IKmlNetworkLink, vtable_offset_local+17, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IKmlNetworkLink.__dict__ and type(IKmlNetworkLink.__dict__[attrname]) == property:
            return IKmlNetworkLink.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IKmlNetworkLink.")
    
    @property
    def uri(self) -> str:
        """Gets the uri of the network link."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_uri"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def refresh_mode(self) -> "AgEStkGraphicsKmlNetworkLinkRefreshMode":
        """Gets or sets the refresh mode of the network link. The refresh mode specifies a time-based refresh policy for this link."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsKmlNetworkLinkRefreshMode) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_refresh_mode"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @refresh_mode.setter
    def refresh_mode(self, refreshMode:"AgEStkGraphicsKmlNetworkLinkRefreshMode") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsKmlNetworkLinkRefreshMode, refreshMode) as arg_refreshMode:
            agcls.evaluate_hresult(self.__dict__["_set_refresh_mode"](arg_refreshMode.COM_val))

    @property
    def refresh_interval(self) -> float:
        """Gets or sets the interval duration at which this network link will refresh, when refresh mode is set to on interval."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_refresh_interval"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @refresh_interval.setter
    def refresh_interval(self, refreshInterval:float) -> None:
        with agmarshall.DOUBLE_arg(refreshInterval) as arg_refreshInterval:
            agcls.evaluate_hresult(self.__dict__["_set_refresh_interval"](arg_refreshInterval.COM_val))

    @property
    def view_refresh_mode(self) -> "AgEStkGraphicsKmlNetworkLinkViewRefreshMode":
        """Gets or sets the view refresh mode of the network link. The view refresh mode specifies the refresh policy for the when the camera's view changes."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsKmlNetworkLinkViewRefreshMode) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_view_refresh_mode"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @view_refresh_mode.setter
    def view_refresh_mode(self, viewRefreshMode:"AgEStkGraphicsKmlNetworkLinkViewRefreshMode") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsKmlNetworkLinkViewRefreshMode, viewRefreshMode) as arg_viewRefreshMode:
            agcls.evaluate_hresult(self.__dict__["_set_view_refresh_mode"](arg_viewRefreshMode.COM_val))

    @property
    def view_refresh_time(self) -> float:
        """Gets or sets the duration after camera view movement stops that this network link will refresh, when view refresh mode is set to on stop."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_view_refresh_time"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @view_refresh_time.setter
    def view_refresh_time(self, viewRefreshTime:float) -> None:
        with agmarshall.DOUBLE_arg(viewRefreshTime) as arg_viewRefreshTime:
            agcls.evaluate_hresult(self.__dict__["_set_view_refresh_time"](arg_viewRefreshTime.COM_val))

    @property
    def view_bound_scale(self) -> float:
        """Gets or sets the value that scales the bounding box defining the view associated with this network link. A value less than 1.0 specifies to use less than the full view (screen). A value greater than 1..."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_view_bound_scale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @view_bound_scale.setter
    def view_bound_scale(self, viewBoundScale:float) -> None:
        with agmarshall.DOUBLE_arg(viewBoundScale) as arg_viewBoundScale:
            agcls.evaluate_hresult(self.__dict__["_set_view_bound_scale"](arg_viewBoundScale.COM_val))

    @property
    def minimum_refresh_period(self) -> float:
        """Gets the duration that is the minimum allowed time between refreshes of this network link."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_refresh_period"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def cookie(self) -> str:
        """Gets the cookie string associated with this network link."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_cookie"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def message(self) -> str:
        """Gets the message string associated with this network link."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_message"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def link_snippet(self) -> str:
        """Gets the link snippet associated with this network link."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_link_snippet"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def expires(self) -> str:
        """Gets the string specifying the date/time this network should expire and be refreshed."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_expires"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def refresh(self) -> None:
        """Refreshes the network link."""
        agcls.evaluate_hresult(self.__dict__["_refresh"]())


agcls.AgClassCatalog.add_catalog_entry("{0b66ea82-dd0d-444f-b097-dda9427e1b87}", IKmlNetworkLink)
agcls.AgTypeNameMap["IKmlNetworkLink"] = IKmlNetworkLink

class IMarkerBatchPrimitive(object):
    """ Renders one or more markers in the 3D scene. Markers are 2D images that always face the viewer which can be sized in pixels or meters. Markers are also referred to as sprites or billboards..."""
    _uuid = "{235878c1-62d9-4ce6-85ff-9d82aff701e9}"
    _num_methods = 54
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_size_source"] = _raise_uninitialized_error
        self.__dict__["_get_sort_order"] = _raise_uninitialized_error
        self.__dict__["_get_set_hint"] = _raise_uninitialized_error
        self.__dict__["_get_rendering_method"] = _raise_uninitialized_error
        self.__dict__["_get_render_pass"] = _raise_uninitialized_error
        self.__dict__["_set_render_pass"] = _raise_uninitialized_error
        self.__dict__["_get_bounding_sphere_scale"] = _raise_uninitialized_error
        self.__dict__["_set_bounding_sphere_scale"] = _raise_uninitialized_error
        self.__dict__["_get_distance_display_condition_per_marker"] = _raise_uninitialized_error
        self.__dict__["_set_distance_display_condition_per_marker"] = _raise_uninitialized_error
        self.__dict__["_get_texture"] = _raise_uninitialized_error
        self.__dict__["_set_texture"] = _raise_uninitialized_error
        self.__dict__["_get_size_unit"] = _raise_uninitialized_error
        self.__dict__["_set_size_unit"] = _raise_uninitialized_error
        self.__dict__["_get_size"] = _raise_uninitialized_error
        self.__dict__["_set_size"] = _raise_uninitialized_error
        self.__dict__["_get_origin"] = _raise_uninitialized_error
        self.__dict__["_set_origin"] = _raise_uninitialized_error
        self.__dict__["_get_pixel_offset"] = _raise_uninitialized_error
        self.__dict__["_set_pixel_offset"] = _raise_uninitialized_error
        self.__dict__["_get_eye_offset"] = _raise_uninitialized_error
        self.__dict__["_set_eye_offset"] = _raise_uninitialized_error
        self.__dict__["_get_rotation"] = _raise_uninitialized_error
        self.__dict__["_set_rotation"] = _raise_uninitialized_error
        self.__dict__["_get_texture_coordinate"] = _raise_uninitialized_error
        self.__dict__["_set_texture_coordinate"] = _raise_uninitialized_error
        self.__dict__["_get_wireframe"] = _raise_uninitialized_error
        self.__dict__["_set_wireframe"] = _raise_uninitialized_error
        self.__dict__["_get_per_item_picking_enabled"] = _raise_uninitialized_error
        self.__dict__["_set_per_item_picking_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_texture_filter"] = _raise_uninitialized_error
        self.__dict__["_set_texture_filter"] = _raise_uninitialized_error
        self.__dict__["_set"] = _raise_uninitialized_error
        self.__dict__["_set_with_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_set_with_optional_parameters_and_render_pass_hint"] = _raise_uninitialized_error
        self.__dict__["_set_cartographic"] = _raise_uninitialized_error
        self.__dict__["_set_cartographic_with_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_set_cartographic_with_optional_parameters_and_render_pass_hint"] = _raise_uninitialized_error
        self.__dict__["_set_partial"] = _raise_uninitialized_error
        self.__dict__["_set_partial_with_indices_order"] = _raise_uninitialized_error
        self.__dict__["_set_partial_with_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_set_partial_with_optional_parameters_indices_order_and_render_pass"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic_with_indices_order"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic_with_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass"] = _raise_uninitialized_error
        self.__dict__["_supported"] = _raise_uninitialized_error
        self.__dict__["_get_clamp_to_pixel"] = _raise_uninitialized_error
        self.__dict__["_set_clamp_to_pixel"] = _raise_uninitialized_error
        self.__dict__["_get_central_body_clipped"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_clipped"] = _raise_uninitialized_error
        self.__dict__["_align_to_screen"] = _raise_uninitialized_error
        self.__dict__["_align_to_north"] = _raise_uninitialized_error
        self.__dict__["_align_to_axis"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMarkerBatchPrimitive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMarkerBatchPrimitive from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMarkerBatchPrimitive = agcom.GUID(IMarkerBatchPrimitive._uuid)
        vtable_offset_local = IMarkerBatchPrimitive._vtable_offset - 1
        self.__dict__["_get_size_source"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_get_sort_order"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_get_set_hint"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_rendering_method"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_get_render_pass"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_render_pass"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_bounding_sphere_scale"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_bounding_sphere_scale"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_distance_display_condition_per_marker"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_set_distance_display_condition_per_marker"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+10, agcom.PVOID)
        self.__dict__["_get_texture"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_set_texture"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_get_size_unit"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_size_unit"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_size"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+15, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_size"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+16, agcom.SAFEARRAY)
        self.__dict__["_get_origin"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set_origin"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_get_pixel_offset"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+19, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_pixel_offset"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+20, agcom.SAFEARRAY)
        self.__dict__["_get_eye_offset"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+21, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_eye_offset"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+22, agcom.SAFEARRAY)
        self.__dict__["_get_rotation"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_rotation"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_texture_coordinate"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+25, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_texture_coordinate"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+26, agcom.SAFEARRAY)
        self.__dict__["_get_wireframe"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+27, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_wireframe"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+28, agcom.VARIANT_BOOL)
        self.__dict__["_get_per_item_picking_enabled"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+29, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_per_item_picking_enabled"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+30, agcom.VARIANT_BOOL)
        self.__dict__["_get_texture_filter"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+31, POINTER(agcom.PVOID))
        self.__dict__["_set_texture_filter"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+32, agcom.PVOID)
        self.__dict__["_set"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+33, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_with_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+34, POINTER(agcom.SAFEARRAY), agcom.PVOID)
        self.__dict__["_set_with_optional_parameters_and_render_pass_hint"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+35, POINTER(agcom.SAFEARRAY), agcom.PVOID, agcom.LONG)
        self.__dict__["_set_cartographic"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+36, agcom.BSTR, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_cartographic_with_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+37, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.PVOID)
        self.__dict__["_set_cartographic_with_optional_parameters_and_render_pass_hint"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+38, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.PVOID, agcom.LONG)
        self.__dict__["_set_partial"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+39, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_with_indices_order"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+40, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG)
        self.__dict__["_set_partial_with_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+41, POINTER(agcom.SAFEARRAY), agcom.PVOID, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_with_optional_parameters_indices_order_and_render_pass"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+42, POINTER(agcom.SAFEARRAY), agcom.PVOID, POINTER(agcom.SAFEARRAY), agcom.LONG, agcom.LONG)
        self.__dict__["_set_partial_cartographic"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+43, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_cartographic_with_indices_order"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+44, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG)
        self.__dict__["_set_partial_cartographic_with_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+45, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.PVOID, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+46, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.PVOID, POINTER(agcom.SAFEARRAY), agcom.LONG, agcom.LONG)
        self.__dict__["_supported"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+47, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_clamp_to_pixel"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+48, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_clamp_to_pixel"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+49, agcom.VARIANT_BOOL)
        self.__dict__["_get_central_body_clipped"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+50, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_central_body_clipped"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+51, agcom.VARIANT_BOOL)
        self.__dict__["_align_to_screen"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+52, )
        self.__dict__["_align_to_north"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+53, agcom.BSTR)
        self.__dict__["_align_to_axis"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitive, vtable_offset_local+54, agcom.BSTR, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMarkerBatchPrimitive.__dict__ and type(IMarkerBatchPrimitive.__dict__[attrname]) == property:
            return IMarkerBatchPrimitive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMarkerBatchPrimitive.")
    
    @property
    def size_source(self) -> "AgEStkGraphicsMarkerBatchSizeSource":
        """Gets the source used for the size of markers in the batch."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchSizeSource) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_size_source"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def sort_order(self) -> "AgEStkGraphicsMarkerBatchSortOrder":
        """Gets the order in which markers in the marker batch are sorted before rendering."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchSortOrder) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_sort_order"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def set_hint(self) -> "AgEStkGraphicsSetHint":
        """Gets the primitive's set hint. See the Set Hint Performance Overview for selecting an appropriate value to construct the primitive with."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSetHint) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_set_hint"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def rendering_method(self) -> "AgEStkGraphicsMarkerBatchRenderingMethod":
        """Gets the rendering method used to render the marker batch."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchRenderingMethod) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_rendering_method"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def render_pass(self) -> "AgEStkGraphicsMarkerBatchRenderPass":
        """Gets or sets the pass during which the marker batch is rendered."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchRenderPass) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_render_pass"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @render_pass.setter
    def render_pass(self, renderPass:"AgEStkGraphicsMarkerBatchRenderPass") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchRenderPass, renderPass) as arg_renderPass:
            agcls.evaluate_hresult(self.__dict__["_set_render_pass"](arg_renderPass.COM_val))

    @property
    def bounding_sphere_scale(self) -> float:
        """Gets or sets the scale applied to the radius of this primitive's bounding sphere."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_bounding_sphere_scale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @bounding_sphere_scale.setter
    def bounding_sphere_scale(self, boundingSphereScale:float) -> None:
        with agmarshall.DOUBLE_arg(boundingSphereScale) as arg_boundingSphereScale:
            agcls.evaluate_hresult(self.__dict__["_set_bounding_sphere_scale"](arg_boundingSphereScale.COM_val))

    @property
    def distance_display_condition_per_marker(self) -> "IDistanceDisplayCondition":
        """Gets or sets a distance display condition that is evaluated per marker in the marker batch during rendering. This is different than display condition, which is evaluated once for the entire marker batch..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_distance_display_condition_per_marker"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @distance_display_condition_per_marker.setter
    def distance_display_condition_per_marker(self, distanceDisplayConditionPerMarker:"IDistanceDisplayCondition") -> None:
        with agmarshall.AgInterface_in_arg(distanceDisplayConditionPerMarker, IDistanceDisplayCondition) as arg_distanceDisplayConditionPerMarker:
            agcls.evaluate_hresult(self.__dict__["_set_distance_display_condition_per_marker"](arg_distanceDisplayConditionPerMarker.COM_val))

    @property
    def texture(self) -> "IRendererTexture2D":
        """Gets or sets the per-batch texture, which is applied to each marker in the batch."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_texture"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @texture.setter
    def texture(self, texture:"IRendererTexture2D") -> None:
        with agmarshall.AgInterface_in_arg(texture, IRendererTexture2D) as arg_texture:
            agcls.evaluate_hresult(self.__dict__["_set_texture"](arg_texture.COM_val))

    @property
    def size_unit(self) -> "AgEStkGraphicsMarkerBatchUnit":
        """Gets or sets the unit that each marker's size is defined in."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchUnit) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_size_unit"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @size_unit.setter
    def size_unit(self, sizeUnit:"AgEStkGraphicsMarkerBatchUnit") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchUnit, sizeUnit) as arg_sizeUnit:
            agcls.evaluate_hresult(self.__dict__["_set_size_unit"](arg_sizeUnit.COM_val))

    @property
    def size(self) -> list:
        """Gets or sets the per-batch size, which is applied to each marker in the batch. The array contains one width followed by one height."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_size"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @size.setter
    def size(self, size:list) -> None:
        with agmarshall.SAFEARRAY_arg(size) as arg_size:
            agcls.evaluate_hresult(self.__dict__["_set_size"](arg_size.COM_val))

    @property
    def origin(self) -> "AgEStkGraphicsOrigin":
        """Gets or sets the per-batch origin, which is applied to each marker in the batch."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsOrigin) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_origin"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @origin.setter
    def origin(self, origin:"AgEStkGraphicsOrigin") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsOrigin, origin) as arg_origin:
            agcls.evaluate_hresult(self.__dict__["_set_origin"](arg_origin.COM_val))

    @property
    def pixel_offset(self) -> list:
        """Gets or sets the per-batch pixel offset, which is applied to each marker in the batch. The array contains one x pixel offset followed by one y pixel offset."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_pixel_offset"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @pixel_offset.setter
    def pixel_offset(self, pixelOffset:list) -> None:
        with agmarshall.SAFEARRAY_arg(pixelOffset) as arg_pixelOffset:
            agcls.evaluate_hresult(self.__dict__["_set_pixel_offset"](arg_pixelOffset.COM_val))

    @property
    def eye_offset(self) -> list:
        """Gets or sets the per-batch eye offset, which is applied to each marker in the batch. The array contains the components of the eye offset in the order x, y, z."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_eye_offset"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @eye_offset.setter
    def eye_offset(self, eyeOffset:list) -> None:
        with agmarshall.SAFEARRAY_arg(eyeOffset) as arg_eyeOffset:
            agcls.evaluate_hresult(self.__dict__["_set_eye_offset"](arg_eyeOffset.COM_val))

    @property
    def rotation(self) -> float:
        """Gets or sets the per-batch rotation angle which is applied to each marker in the batch."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_rotation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @rotation.setter
    def rotation(self, rotation:float) -> None:
        with agmarshall.DOUBLE_arg(rotation) as arg_rotation:
            agcls.evaluate_hresult(self.__dict__["_set_rotation"](arg_rotation.COM_val))

    @property
    def texture_coordinate(self) -> list:
        """Gets or sets the per-batch texture coordinate, which is applied to each marker in the batch. The array contains the texture coordinates arranged in the order s, t, p, q."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_texture_coordinate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @texture_coordinate.setter
    def texture_coordinate(self, textureCoordinate:list) -> None:
        with agmarshall.SAFEARRAY_arg(textureCoordinate) as arg_textureCoordinate:
            agcls.evaluate_hresult(self.__dict__["_set_texture_coordinate"](arg_textureCoordinate.COM_val))

    @property
    def wireframe(self) -> bool:
        """Gets or sets whether the primitive is rendered in wireframe. This is useful for debugging."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_wireframe"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @wireframe.setter
    def wireframe(self, wireframe:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(wireframe) as arg_wireframe:
            agcls.evaluate_hresult(self.__dict__["_set_wireframe"](arg_wireframe.COM_val))

    @property
    def per_item_picking_enabled(self) -> bool:
        """Gets or sets whether individual marker indices will be included in the pick results returned from the scene's Pick method. Each marker index that is picked will be returned as a batch primitive index."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_per_item_picking_enabled"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @per_item_picking_enabled.setter
    def per_item_picking_enabled(self, perItemPickingEnabled:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(perItemPickingEnabled) as arg_perItemPickingEnabled:
            agcls.evaluate_hresult(self.__dict__["_set_per_item_picking_enabled"](arg_perItemPickingEnabled.COM_val))

    @property
    def texture_filter(self) -> "ITextureFilter2D":
        """Gets or sets the filter used for per-marker or per-batch textures."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_texture_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @texture_filter.setter
    def texture_filter(self, textureFilter:"ITextureFilter2D") -> None:
        with agmarshall.AgInterface_in_arg(textureFilter, ITextureFilter2D) as arg_textureFilter:
            agcls.evaluate_hresult(self.__dict__["_set_texture_filter"](arg_textureFilter.COM_val))

    def set(self, positions:list) -> None:
        """Defines the positions of markers in a marker batch. The markers are rendered in the primitive's reference frame."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions:
            agcls.evaluate_hresult(self.__dict__["_set"](byref(arg_positions.COM_val)))

    def set_with_optional_parameters(self, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters") -> None:
        """Defines the positions and optional per-marker parameters of markers in a marker batch. The markers are rendered in the primitive's reference frame."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.AgInterface_in_arg(optionalParameters, IMarkerBatchPrimitiveOptionalParameters) as arg_optionalParameters:
            agcls.evaluate_hresult(self.__dict__["_set_with_optional_parameters"](byref(arg_positions.COM_val), arg_optionalParameters.COM_val))

    def set_with_optional_parameters_and_render_pass_hint(self, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters", renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """Defines the positions and optional per-marker parameters of markers in a marker batch. The markers are rendered in the primitive's reference frame. renderPassHint is provided for efficiency."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.AgInterface_in_arg(optionalParameters, IMarkerBatchPrimitiveOptionalParameters) as arg_optionalParameters, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_with_optional_parameters_and_render_pass_hint"](byref(arg_positions.COM_val), arg_optionalParameters.COM_val, arg_renderPassHint.COM_val))

    def set_cartographic(self, centralBody:str, positions:list) -> None:
        """For convenience. Defines the positions of markers in a marker batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions:
            agcls.evaluate_hresult(self.__dict__["_set_cartographic"](arg_centralBody.COM_val, byref(arg_positions.COM_val)))

    def set_cartographic_with_optional_parameters(self, centralBody:str, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters") -> None:
        """For convenience. Defines the positions and optional per-marker parameters of markers in a marker batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.AgInterface_in_arg(optionalParameters, IMarkerBatchPrimitiveOptionalParameters) as arg_optionalParameters:
            agcls.evaluate_hresult(self.__dict__["_set_cartographic_with_optional_parameters"](arg_centralBody.COM_val, byref(arg_positions.COM_val), arg_optionalParameters.COM_val))

    def set_cartographic_with_optional_parameters_and_render_pass_hint(self, centralBody:str, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters", renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """For convenience. Defines the positions and optional per-marker parameters of markers in a marker batch using cartographic positions. renderPassHint is provided for efficiency..."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.AgInterface_in_arg(optionalParameters, IMarkerBatchPrimitiveOptionalParameters) as arg_optionalParameters, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_cartographic_with_optional_parameters_and_render_pass_hint"](arg_centralBody.COM_val, byref(arg_positions.COM_val), arg_optionalParameters.COM_val, arg_renderPassHint.COM_val))

    def set_partial(self, positions:list, indices:list) -> None:
        """Updates a subset of marker positions in a marker batch."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial"](byref(arg_positions.COM_val), byref(arg_indices.COM_val)))

    def set_partial_with_indices_order(self, positions:list, indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint") -> None:
        """Updates a subset of marker positions in a marker batch."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_with_indices_order"](byref(arg_positions.COM_val), byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val))

    def set_partial_with_optional_parameters(self, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters", indices:list) -> None:
        """Updates a subset of marker positions and/or per-marker parameters in a marker batch."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.AgInterface_in_arg(optionalParameters, IMarkerBatchPrimitiveOptionalParameters) as arg_optionalParameters, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial_with_optional_parameters"](byref(arg_positions.COM_val), arg_optionalParameters.COM_val, byref(arg_indices.COM_val)))

    def set_partial_with_optional_parameters_indices_order_and_render_pass(self, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters", indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint", renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """Updates a subset of marker positions and/or per-marker parameters in a marker batch."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.AgInterface_in_arg(optionalParameters, IMarkerBatchPrimitiveOptionalParameters) as arg_optionalParameters, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_with_optional_parameters_indices_order_and_render_pass"](byref(arg_positions.COM_val), arg_optionalParameters.COM_val, byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val, arg_renderPassHint.COM_val))

    def set_partial_cartographic(self, centralBody:str, positions:list, indices:list) -> None:
        """For convenience. Updates a subset of positions in a marker batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_indices.COM_val)))

    def set_partial_cartographic_with_indices_order(self, centralBody:str, positions:list, indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint") -> None:
        """For convenience. Updates a subset of positions in a marker batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic_with_indices_order"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val))

    def set_partial_cartographic_with_optional_parameters(self, centralBody:str, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters", indices:list) -> None:
        """For convenience. Updates a subset of positions and/or optional per-marker parameters of markers in a marker batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.AgInterface_in_arg(optionalParameters, IMarkerBatchPrimitiveOptionalParameters) as arg_optionalParameters, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic_with_optional_parameters"](arg_centralBody.COM_val, byref(arg_positions.COM_val), arg_optionalParameters.COM_val, byref(arg_indices.COM_val)))

    def set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass(self, centralBody:str, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters", indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint", renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """For convenience. Updates a subset of positions and/or optional per-marker parameters of markers in a marker batch using cartographic positions. renderPassHint is provided for efficiency..."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.AgInterface_in_arg(optionalParameters, IMarkerBatchPrimitiveOptionalParameters) as arg_optionalParameters, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass"](arg_centralBody.COM_val, byref(arg_positions.COM_val), arg_optionalParameters.COM_val, byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val, arg_renderPassHint.COM_val))

    def supported(self, renderingMethod:"AgEStkGraphicsMarkerBatchRenderingMethod") -> bool:
        """Determines whether or not the video card supports the marker batch primitive with the given renderingMethod."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchRenderingMethod, renderingMethod) as arg_renderingMethod, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_supported"](arg_renderingMethod.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def clamp_to_pixel(self) -> bool:
        """Gets or sets whether the screen space position of each marker is clamped to a pixel."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_clamp_to_pixel"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @clamp_to_pixel.setter
    def clamp_to_pixel(self, clampToPixel:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(clampToPixel) as arg_clampToPixel:
            agcls.evaluate_hresult(self.__dict__["_set_clamp_to_pixel"](arg_clampToPixel.COM_val))

    @property
    def central_body_clipped(self) -> bool:
        """Gets or sets whether the markers are clipped by the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_clipped"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @central_body_clipped.setter
    def central_body_clipped(self, centralBodyClipped:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(centralBodyClipped) as arg_centralBodyClipped:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_clipped"](arg_centralBodyClipped.COM_val))

    def align_to_screen(self) -> None:
        """Sets the up vector of the markers to always be aligned to the up vector of the camera. This is the default alignment."""
        agcls.evaluate_hresult(self.__dict__["_align_to_screen"]())

    def align_to_north(self, centralBody:str) -> None:
        """Sets the up vector of the markers to point towards the north axis of centralBody. It will be aligned with the tangent vector of the surface that points north."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_align_to_north"](arg_centralBody.COM_val))

    def align_to_axis(self, centralBody:str, axis:list) -> None:
        """Sets the up vector of the markers to point towards the axis of centralBody. It will be aligned with the tangent vector of the surface that points towards the axis..."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(axis) as arg_axis:
            agcls.evaluate_hresult(self.__dict__["_align_to_axis"](arg_centralBody.COM_val, byref(arg_axis.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{235878c1-62d9-4ce6-85ff-9d82aff701e9}", IMarkerBatchPrimitive)
agcls.AgTypeNameMap["IMarkerBatchPrimitive"] = IMarkerBatchPrimitive

class IMarkerBatchPrimitiveOptionalParameters(object):
    """Optional per-marker parameters for marker batch primitive that overrides the marker batch's per-batch parameters..."""
    _uuid = "{7303b63e-a1b7-445e-90e0-508a6937de86}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_set_textures"] = _raise_uninitialized_error
        self.__dict__["_set_sizes"] = _raise_uninitialized_error
        self.__dict__["_set_colors"] = _raise_uninitialized_error
        self.__dict__["_set_origins"] = _raise_uninitialized_error
        self.__dict__["_set_pixel_offsets"] = _raise_uninitialized_error
        self.__dict__["_set_eye_offsets"] = _raise_uninitialized_error
        self.__dict__["_set_rotations"] = _raise_uninitialized_error
        self.__dict__["_set_texture_coordinates"] = _raise_uninitialized_error
        self.__dict__["_set_time_interval_display_conditions"] = _raise_uninitialized_error
        self.__dict__["_set_displays"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMarkerBatchPrimitiveOptionalParameters._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMarkerBatchPrimitiveOptionalParameters from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMarkerBatchPrimitiveOptionalParameters = agcom.GUID(IMarkerBatchPrimitiveOptionalParameters._uuid)
        vtable_offset_local = IMarkerBatchPrimitiveOptionalParameters._vtable_offset - 1
        self.__dict__["_set_textures"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveOptionalParameters, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_sizes"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveOptionalParameters, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_colors"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveOptionalParameters, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_origins"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveOptionalParameters, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_pixel_offsets"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveOptionalParameters, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_eye_offsets"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveOptionalParameters, vtable_offset_local+6, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_rotations"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveOptionalParameters, vtable_offset_local+7, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_texture_coordinates"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveOptionalParameters, vtable_offset_local+8, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_time_interval_display_conditions"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveOptionalParameters, vtable_offset_local+9, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_displays"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveOptionalParameters, vtable_offset_local+10, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMarkerBatchPrimitiveOptionalParameters.__dict__ and type(IMarkerBatchPrimitiveOptionalParameters.__dict__[attrname]) == property:
            return IMarkerBatchPrimitiveOptionalParameters.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMarkerBatchPrimitiveOptionalParameters.")
    
    def set_textures(self, textures:list) -> None:
        """Defines a collection of textures, one for each marker in the batch."""
        with agmarshall.SAFEARRAY_arg(textures) as arg_textures:
            agcls.evaluate_hresult(self.__dict__["_set_textures"](byref(arg_textures.COM_val)))

    def set_sizes(self, sizes:list) -> None:
        """Defines a collection of sizes, one for each marker in the batch."""
        with agmarshall.SAFEARRAY_arg(sizes) as arg_sizes:
            agcls.evaluate_hresult(self.__dict__["_set_sizes"](byref(arg_sizes.COM_val)))

    def set_colors(self, colors:list) -> None:
        """Defines a collection of colors, one for each marker in the batch."""
        with agmarshall.SAFEARRAY_arg(colors) as arg_colors:
            agcls.evaluate_hresult(self.__dict__["_set_colors"](byref(arg_colors.COM_val)))

    def set_origins(self, origins:list) -> None:
        """Defines a collection of origins, one for each marker in the batch."""
        with agmarshall.SAFEARRAY_arg(origins) as arg_origins:
            agcls.evaluate_hresult(self.__dict__["_set_origins"](byref(arg_origins.COM_val)))

    def set_pixel_offsets(self, pixelOffsets:list) -> None:
        """Defines a collection of pixel offsets, one for each marker in the batch."""
        with agmarshall.SAFEARRAY_arg(pixelOffsets) as arg_pixelOffsets:
            agcls.evaluate_hresult(self.__dict__["_set_pixel_offsets"](byref(arg_pixelOffsets.COM_val)))

    def set_eye_offsets(self, eyeOffsets:list) -> None:
        """Defines a collection of eye offsets, one for each marker in the batch."""
        with agmarshall.SAFEARRAY_arg(eyeOffsets) as arg_eyeOffsets:
            agcls.evaluate_hresult(self.__dict__["_set_eye_offsets"](byref(arg_eyeOffsets.COM_val)))

    def set_rotations(self, rotationAngles:list) -> None:
        """Defines a collection of rotation angles, one for each marker in the batch."""
        with agmarshall.SAFEARRAY_arg(rotationAngles) as arg_rotationAngles:
            agcls.evaluate_hresult(self.__dict__["_set_rotations"](byref(arg_rotationAngles.COM_val)))

    def set_texture_coordinates(self, textureCoordinates:list) -> None:
        """Defines a collection of texture coordinates, one for each marker in the batch."""
        with agmarshall.SAFEARRAY_arg(textureCoordinates) as arg_textureCoordinates:
            agcls.evaluate_hresult(self.__dict__["_set_texture_coordinates"](byref(arg_textureCoordinates.COM_val)))

    def set_time_interval_display_conditions(self, timeIntervals:list) -> None:
        """Defines a collection of time interval display conditions, one for each marker in the batch."""
        with agmarshall.SAFEARRAY_arg(timeIntervals) as arg_timeIntervals:
            agcls.evaluate_hresult(self.__dict__["_set_time_interval_display_conditions"](byref(arg_timeIntervals.COM_val)))

    def set_displays(self, displays:list) -> None:
        """Defines a collection of boolean display flags, one for each marker in the batch."""
        with agmarshall.SAFEARRAY_arg(displays) as arg_displays:
            agcls.evaluate_hresult(self.__dict__["_set_displays"](byref(arg_displays.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{7303b63e-a1b7-445e-90e0-508a6937de86}", IMarkerBatchPrimitiveOptionalParameters)
agcls.AgTypeNameMap["IMarkerBatchPrimitiveOptionalParameters"] = IMarkerBatchPrimitiveOptionalParameters

class IMaximumCountPathPrimitiveUpdatePolicy(object):
    """path primitive update policy that removes points from remove location when the number of points in the path exceeds maximum count."""
    _uuid = "{fcacfb20-3ffb-46c4-9e07-495b1446c52b}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_maximum_count"] = _raise_uninitialized_error
        self.__dict__["_set_maximum_count"] = _raise_uninitialized_error
        self.__dict__["_get_remove_location"] = _raise_uninitialized_error
        self.__dict__["_set_remove_location"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMaximumCountPathPrimitiveUpdatePolicy._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMaximumCountPathPrimitiveUpdatePolicy from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMaximumCountPathPrimitiveUpdatePolicy = agcom.GUID(IMaximumCountPathPrimitiveUpdatePolicy._uuid)
        vtable_offset_local = IMaximumCountPathPrimitiveUpdatePolicy._vtable_offset - 1
        self.__dict__["_get_maximum_count"] = IAGFUNCTYPE(pUnk, IID_IMaximumCountPathPrimitiveUpdatePolicy, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_set_maximum_count"] = IAGFUNCTYPE(pUnk, IID_IMaximumCountPathPrimitiveUpdatePolicy, vtable_offset_local+2, agcom.INT)
        self.__dict__["_get_remove_location"] = IAGFUNCTYPE(pUnk, IID_IMaximumCountPathPrimitiveUpdatePolicy, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_remove_location"] = IAGFUNCTYPE(pUnk, IID_IMaximumCountPathPrimitiveUpdatePolicy, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMaximumCountPathPrimitiveUpdatePolicy.__dict__ and type(IMaximumCountPathPrimitiveUpdatePolicy.__dict__[attrname]) == property:
            return IMaximumCountPathPrimitiveUpdatePolicy.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMaximumCountPathPrimitiveUpdatePolicy.")
    
    @property
    def maximum_count(self) -> int:
        """Gets or sets the maximum number of points in the path."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @maximum_count.setter
    def maximum_count(self, maximumCount:int) -> None:
        with agmarshall.INT_arg(maximumCount) as arg_maximumCount:
            agcls.evaluate_hresult(self.__dict__["_set_maximum_count"](arg_maximumCount.COM_val))

    @property
    def remove_location(self) -> "AgEStkGraphicsPathPrimitiveRemoveLocation":
        """Gets or sets where the positions on the path are removed from."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsPathPrimitiveRemoveLocation) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_remove_location"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @remove_location.setter
    def remove_location(self, removeLocation:"AgEStkGraphicsPathPrimitiveRemoveLocation") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsPathPrimitiveRemoveLocation, removeLocation) as arg_removeLocation:
            agcls.evaluate_hresult(self.__dict__["_set_remove_location"](arg_removeLocation.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{fcacfb20-3ffb-46c4-9e07-495b1446c52b}", IMaximumCountPathPrimitiveUpdatePolicy)
agcls.AgTypeNameMap["IMaximumCountPathPrimitiveUpdatePolicy"] = IMaximumCountPathPrimitiveUpdatePolicy

class IModelArticulation(object):
    """A model articulation identifies geometry on the model and is a collection of transformations that can be applied to that geometry."""
    _uuid = "{4554a375-123b-4a39-b727-3e9131879196}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_string"] = _raise_uninitialized_error
        self.__dict__["_get_by_name"] = _raise_uninitialized_error
        self.__dict__["_contains"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IModelArticulation._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IModelArticulation from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IModelArticulation = agcom.GUID(IModelArticulation._uuid)
        vtable_offset_local = IModelArticulation._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IModelArticulation, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IModelArticulation, vtable_offset_local+2, POINTER(agcom.INT))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IModelArticulation, vtable_offset_local+3, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_string"] = IAGFUNCTYPE(pUnk, IID_IModelArticulation, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_by_name"] = IAGFUNCTYPE(pUnk, IID_IModelArticulation, vtable_offset_local+5, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_contains"] = IAGFUNCTYPE(pUnk, IID_IModelArticulation, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IModelArticulation, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IModelArticulation.__dict__ and type(IModelArticulation.__dict__[attrname]) == property:
            return IModelArticulation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IModelArticulation.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IModelTransformation":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def name(self) -> str:
        """Gets the name of the articulation."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def count(self) -> int:
        """Gets the number of transformations in the collection."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> "IModelTransformation":
        """Gets the transformation at the given index. The index is zero-based."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_item_by_string(self, name:str) -> "IModelTransformation":
        """Gets a transformation by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_string"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_by_name(self, name:str) -> "IModelTransformation":
        """Gets a transformation by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_by_name"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def contains(self, name:str) -> bool:
        """Returns true if the collection contains the transformation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns the enumerator for this collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{4554a375-123b-4a39-b727-3e9131879196}", IModelArticulation)
agcls.AgTypeNameMap["IModelArticulation"] = IModelArticulation

class IModelArticulationCollection(object):
    """A collection containing a model primitive's available articulations. A model articulation identifies geometry on the model and is a collection of transformations that can be applied to that geometry."""
    _uuid = "{cf6e3054-4d92-42f8-ac4d-e43bfd93d23d}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_string"] = _raise_uninitialized_error
        self.__dict__["_get_by_name"] = _raise_uninitialized_error
        self.__dict__["_contains"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IModelArticulationCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IModelArticulationCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IModelArticulationCollection = agcom.GUID(IModelArticulationCollection._uuid)
        vtable_offset_local = IModelArticulationCollection._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IModelArticulationCollection, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IModelArticulationCollection, vtable_offset_local+2, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_string"] = IAGFUNCTYPE(pUnk, IID_IModelArticulationCollection, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_by_name"] = IAGFUNCTYPE(pUnk, IID_IModelArticulationCollection, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_contains"] = IAGFUNCTYPE(pUnk, IID_IModelArticulationCollection, vtable_offset_local+5, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IModelArticulationCollection, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IModelArticulationCollection.__dict__ and type(IModelArticulationCollection.__dict__[attrname]) == property:
            return IModelArticulationCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IModelArticulationCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IModelArticulation":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """Gets the number of articulations in the collection."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> "IModelArticulation":
        """Gets the articulation at the given index. The index is zero-based."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_item_by_string(self, name:str) -> "IModelArticulation":
        """Gets an articulation by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_string"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_by_name(self, name:str) -> "IModelArticulation":
        """Gets an articulation by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_by_name"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def contains(self, name:str) -> bool:
        """Returns true if the collection contains the articulation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns the enumerator for this collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{cf6e3054-4d92-42f8-ac4d-e43bfd93d23d}", IModelArticulationCollection)
agcls.AgTypeNameMap["IModelArticulationCollection"] = IModelArticulationCollection

class IModelPrimitive(object):
    """The model primitive loads and renders `COLLADA <https://www.khronos.org/collada/>`_ (DAE) and AGI `MDL <https://support.agi.com/3d-models>`_ (MDL) models."""
    _uuid = "{67a2ad57-e9b2-4dc9-b509-62cbebc405ca}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_uri_as_string"] = _raise_uninitialized_error
        self.__dict__["_get_scale"] = _raise_uninitialized_error
        self.__dict__["_set_scale"] = _raise_uninitialized_error
        self.__dict__["_get_position"] = _raise_uninitialized_error
        self.__dict__["_set_position"] = _raise_uninitialized_error
        self.__dict__["_get_orientation"] = _raise_uninitialized_error
        self.__dict__["_set_orientation"] = _raise_uninitialized_error
        self.__dict__["_get_articulations"] = _raise_uninitialized_error
        self.__dict__["_load_with_string_uri"] = _raise_uninitialized_error
        self.__dict__["_load_with_string_uri_and_up_axis"] = _raise_uninitialized_error
        self.__dict__["_set_position_cartographic"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IModelPrimitive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IModelPrimitive from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IModelPrimitive = agcom.GUID(IModelPrimitive._uuid)
        vtable_offset_local = IModelPrimitive._vtable_offset - 1
        self.__dict__["_get_uri_as_string"] = IAGFUNCTYPE(pUnk, IID_IModelPrimitive, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_get_scale"] = IAGFUNCTYPE(pUnk, IID_IModelPrimitive, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_set_scale"] = IAGFUNCTYPE(pUnk, IID_IModelPrimitive, vtable_offset_local+3, agcom.DOUBLE)
        self.__dict__["_get_position"] = IAGFUNCTYPE(pUnk, IID_IModelPrimitive, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_position"] = IAGFUNCTYPE(pUnk, IID_IModelPrimitive, vtable_offset_local+5, agcom.SAFEARRAY)
        self.__dict__["_get_orientation"] = IAGFUNCTYPE(pUnk, IID_IModelPrimitive, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_set_orientation"] = IAGFUNCTYPE(pUnk, IID_IModelPrimitive, vtable_offset_local+7, agcom.PVOID)
        self.__dict__["_get_articulations"] = IAGFUNCTYPE(pUnk, IID_IModelPrimitive, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_load_with_string_uri"] = IAGFUNCTYPE(pUnk, IID_IModelPrimitive, vtable_offset_local+9, agcom.BSTR)
        self.__dict__["_load_with_string_uri_and_up_axis"] = IAGFUNCTYPE(pUnk, IID_IModelPrimitive, vtable_offset_local+10, agcom.BSTR, agcom.LONG)
        self.__dict__["_set_position_cartographic"] = IAGFUNCTYPE(pUnk, IID_IModelPrimitive, vtable_offset_local+11, agcom.BSTR, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IModelPrimitive.__dict__ and type(IModelPrimitive.__dict__[attrname]) == property:
            return IModelPrimitive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IModelPrimitive.")
    
    @property
    def uri_as_string(self) -> str:
        """Gets the URI of the file used to load the file."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_uri_as_string"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def scale(self) -> float:
        """Gets or sets the linear scale used to increase or decrease the size of the rendered model."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @scale.setter
    def scale(self, scale:float) -> None:
        with agmarshall.DOUBLE_arg(scale) as arg_scale:
            agcls.evaluate_hresult(self.__dict__["_set_scale"](arg_scale.COM_val))

    @property
    def position(self) -> list:
        """Gets or sets the position of the model. The position is defined in the model's reference frame. The array contains the components of the position in the order x, y, z."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @position.setter
    def position(self, position:list) -> None:
        with agmarshall.SAFEARRAY_arg(position) as arg_position:
            agcls.evaluate_hresult(self.__dict__["_set_position"](arg_position.COM_val))

    @property
    def orientation(self) -> "IOrientation":
        """Gets or sets the model's orientation. The quaternion is a rotation from the model's local axes to the axes of the model's reference frame."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_orientation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @orientation.setter
    def orientation(self, orientation:"IOrientation") -> None:
        with agmarshall.AgInterface_in_arg(orientation, IOrientation) as arg_orientation:
            agcls.evaluate_hresult(self.__dict__["_set_orientation"](arg_orientation.COM_val))

    @property
    def articulations(self) -> "IModelArticulationCollection":
        """Gets the model's articulations. Articulations identify geometry and contain transformations for manipulating that geometry."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_articulations"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def load_with_string_uri(self, uri:str) -> None:
        """For convenience. Loads a `COLLADA <https://www.khronos.org/collada/>`_ (DAE) or AGI `MDL <https://support.agi.com/3d-models>`_ (MDL) model using a file path."""
        with agmarshall.BSTR_arg(uri) as arg_uri:
            agcls.evaluate_hresult(self.__dict__["_load_with_string_uri"](arg_uri.COM_val))

    def load_with_string_uri_and_up_axis(self, uri:str, upAxis:"AgEStkGraphicsModelUpAxis") -> None:
        """For convenience. Loads a `COLLADA <https://www.khronos.org/collada/>`_ (DAE) or AGI `MDL <https://support.agi.com/3d-models>`_ (MDL) model using a file path."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.AgEnum_arg(AgEStkGraphicsModelUpAxis, upAxis) as arg_upAxis:
            agcls.evaluate_hresult(self.__dict__["_load_with_string_uri_and_up_axis"](arg_uri.COM_val, arg_upAxis.COM_val))

    def set_position_cartographic(self, centralBody:str, position:list) -> None:
        """For convenience. Sets the cartographic position of the model. This also sets position."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(position) as arg_position:
            agcls.evaluate_hresult(self.__dict__["_set_position_cartographic"](arg_centralBody.COM_val, byref(arg_position.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{67a2ad57-e9b2-4dc9-b509-62cbebc405ca}", IModelPrimitive)
agcls.AgTypeNameMap["IModelPrimitive"] = IModelPrimitive

class IModelTransformation(object):
    """A model transformation defines a transformation that is applied to geometry on a model primitive. That geometry is identified by the model articulation which contains the transformation..."""
    _uuid = "{c58f7fc4-2f63-494d-a461-2c385a53b9a2}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_current_value"] = _raise_uninitialized_error
        self.__dict__["_set_current_value"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_value"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_value"] = _raise_uninitialized_error
        self.__dict__["_get_default_value"] = _raise_uninitialized_error
        self.__dict__["_get_range"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IModelTransformation._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IModelTransformation from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IModelTransformation = agcom.GUID(IModelTransformation._uuid)
        vtable_offset_local = IModelTransformation._vtable_offset - 1
        self.__dict__["_get_current_value"] = IAGFUNCTYPE(pUnk, IID_IModelTransformation, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_current_value"] = IAGFUNCTYPE(pUnk, IID_IModelTransformation, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_minimum_value"] = IAGFUNCTYPE(pUnk, IID_IModelTransformation, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_get_maximum_value"] = IAGFUNCTYPE(pUnk, IID_IModelTransformation, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_get_default_value"] = IAGFUNCTYPE(pUnk, IID_IModelTransformation, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_get_range"] = IAGFUNCTYPE(pUnk, IID_IModelTransformation, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IModelTransformation, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_get_type"] = IAGFUNCTYPE(pUnk, IID_IModelTransformation, vtable_offset_local+8, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IModelTransformation.__dict__ and type(IModelTransformation.__dict__[attrname]) == property:
            return IModelTransformation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IModelTransformation.")
    
    @property
    def current_value(self) -> float:
        """Gets or sets the current value of the transformation. The current value of the transformation will be reflected in the geometry of the model primitive that it is associated with."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_current_value"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @current_value.setter
    def current_value(self, currentValue:float) -> None:
        with agmarshall.DOUBLE_arg(currentValue) as arg_currentValue:
            agcls.evaluate_hresult(self.__dict__["_set_current_value"](arg_currentValue.COM_val))

    @property
    def minimum_value(self) -> float:
        """Gets the minimum value of the transformation."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_value"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def maximum_value(self) -> float:
        """Gets the maximum value of the transformation."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_value"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def default_value(self) -> float:
        """Gets the default value of the transformation. The current value property of the transformation will have this value when the model primitive is initialized."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_default_value"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def range(self) -> float:
        """Gets the value range of the transformation. Equivalent to the difference of the maximum value and minimum value properties."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_range"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def name(self) -> str:
        """Gets the name of the transformation."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def type(self) -> "AgEStkGraphicsModelTransformationType":
        """Gets the model transformation type associated with the transformation."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsModelTransformationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_type"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{c58f7fc4-2f63-494d-a461-2c385a53b9a2}", IModelTransformation)
agcls.AgTypeNameMap["IModelTransformation"] = IModelTransformation

class IOverlay(object):
    """A visible element drawn in screen space. Overlays are useful for floating logos, heads up displays, and integrating user interfaces into the 3D window."""
    _uuid = "{b7007235-5a52-450b-83af-1e8080d3b0be}"
    _num_methods = 76
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_position"] = _raise_uninitialized_error
        self.__dict__["_set_position"] = _raise_uninitialized_error
        self.__dict__["_get_pinning_position"] = _raise_uninitialized_error
        self.__dict__["_set_pinning_position"] = _raise_uninitialized_error
        self.__dict__["_get_x"] = _raise_uninitialized_error
        self.__dict__["_set_x"] = _raise_uninitialized_error
        self.__dict__["_get_x_unit"] = _raise_uninitialized_error
        self.__dict__["_set_x_unit"] = _raise_uninitialized_error
        self.__dict__["_get_y"] = _raise_uninitialized_error
        self.__dict__["_set_y"] = _raise_uninitialized_error
        self.__dict__["_get_y_unit"] = _raise_uninitialized_error
        self.__dict__["_set_y_unit"] = _raise_uninitialized_error
        self.__dict__["_get_size"] = _raise_uninitialized_error
        self.__dict__["_set_size"] = _raise_uninitialized_error
        self.__dict__["_get_width"] = _raise_uninitialized_error
        self.__dict__["_set_width"] = _raise_uninitialized_error
        self.__dict__["_get_width_unit"] = _raise_uninitialized_error
        self.__dict__["_set_width_unit"] = _raise_uninitialized_error
        self.__dict__["_get_height"] = _raise_uninitialized_error
        self.__dict__["_set_height"] = _raise_uninitialized_error
        self.__dict__["_get_height_unit"] = _raise_uninitialized_error
        self.__dict__["_set_height_unit"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_size"] = _raise_uninitialized_error
        self.__dict__["_set_minimum_size"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_size"] = _raise_uninitialized_error
        self.__dict__["_set_maximum_size"] = _raise_uninitialized_error
        self.__dict__["_get_bounds"] = _raise_uninitialized_error
        self.__dict__["_get_border_color"] = _raise_uninitialized_error
        self.__dict__["_set_border_color"] = _raise_uninitialized_error
        self.__dict__["_get_border_size"] = _raise_uninitialized_error
        self.__dict__["_set_border_size"] = _raise_uninitialized_error
        self.__dict__["_get_border_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_border_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_translation_x"] = _raise_uninitialized_error
        self.__dict__["_set_translation_x"] = _raise_uninitialized_error
        self.__dict__["_get_translation_y"] = _raise_uninitialized_error
        self.__dict__["_set_translation_y"] = _raise_uninitialized_error
        self.__dict__["_get_rotation_angle"] = _raise_uninitialized_error
        self.__dict__["_set_rotation_angle"] = _raise_uninitialized_error
        self.__dict__["_get_rotation_point"] = _raise_uninitialized_error
        self.__dict__["_set_rotation_point"] = _raise_uninitialized_error
        self.__dict__["_get_scale"] = _raise_uninitialized_error
        self.__dict__["_set_scale"] = _raise_uninitialized_error
        self.__dict__["_get_flip_x"] = _raise_uninitialized_error
        self.__dict__["_set_flip_x"] = _raise_uninitialized_error
        self.__dict__["_get_flip_y"] = _raise_uninitialized_error
        self.__dict__["_set_flip_y"] = _raise_uninitialized_error
        self.__dict__["_get_origin"] = _raise_uninitialized_error
        self.__dict__["_set_origin"] = _raise_uninitialized_error
        self.__dict__["_get_pinning_origin"] = _raise_uninitialized_error
        self.__dict__["_set_pinning_origin"] = _raise_uninitialized_error
        self.__dict__["_get_parent"] = _raise_uninitialized_error
        self.__dict__["_get_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_color"] = _raise_uninitialized_error
        self.__dict__["_set_color"] = _raise_uninitialized_error
        self.__dict__["_get_picking_enabled"] = _raise_uninitialized_error
        self.__dict__["_set_picking_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_clip_to_parent"] = _raise_uninitialized_error
        self.__dict__["_set_clip_to_parent"] = _raise_uninitialized_error
        self.__dict__["_get_display"] = _raise_uninitialized_error
        self.__dict__["_set_display"] = _raise_uninitialized_error
        self.__dict__["_get_control_position"] = _raise_uninitialized_error
        self.__dict__["_get_control_size"] = _raise_uninitialized_error
        self.__dict__["_get_control_bounds"] = _raise_uninitialized_error
        self.__dict__["_get_display_condition"] = _raise_uninitialized_error
        self.__dict__["_set_display_condition"] = _raise_uninitialized_error
        self.__dict__["_get_overlays"] = _raise_uninitialized_error
        self.__dict__["_get_padding"] = _raise_uninitialized_error
        self.__dict__["_set_padding"] = _raise_uninitialized_error
        self.__dict__["_bring_to_front"] = _raise_uninitialized_error
        self.__dict__["_send_to_back"] = _raise_uninitialized_error
        self.__dict__["_overlay_to_control"] = _raise_uninitialized_error
        self.__dict__["_control_to_overlay"] = _raise_uninitialized_error
        self.__dict__["_get_tag"] = _raise_uninitialized_error
        self.__dict__["_set_tag"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IOverlay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IOverlay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IOverlay = agcom.GUID(IOverlay._uuid)
        vtable_offset_local = IOverlay._vtable_offset - 1
        self.__dict__["_get_position"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_position"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+2, agcom.SAFEARRAY)
        self.__dict__["_get_pinning_position"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_pinning_position"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+4, agcom.SAFEARRAY)
        self.__dict__["_get_x"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_x"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_x_unit"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_x_unit"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_y"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_y"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_y_unit"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_y_unit"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_size"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+13, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_size"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+14, agcom.SAFEARRAY)
        self.__dict__["_get_width"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_width"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_width_unit"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set_width_unit"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_get_height"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_height"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_height_unit"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_height_unit"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_minimum_size"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+23, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_minimum_size"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+24, agcom.SAFEARRAY)
        self.__dict__["_get_maximum_size"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+25, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_maximum_size"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+26, agcom.SAFEARRAY)
        self.__dict__["_get_bounds"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+27, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_border_color"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+28, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_border_color"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+29, agcom.OLE_COLOR)
        self.__dict__["_get_border_size"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+30, POINTER(agcom.INT))
        self.__dict__["_set_border_size"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+31, agcom.INT)
        self.__dict__["_get_border_translucency"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+32, POINTER(agcom.FLOAT))
        self.__dict__["_set_border_translucency"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+33, agcom.FLOAT)
        self.__dict__["_get_translation_x"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+34, POINTER(agcom.DOUBLE))
        self.__dict__["_set_translation_x"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+35, agcom.DOUBLE)
        self.__dict__["_get_translation_y"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+36, POINTER(agcom.DOUBLE))
        self.__dict__["_set_translation_y"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+37, agcom.DOUBLE)
        self.__dict__["_get_rotation_angle"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+38, POINTER(agcom.DOUBLE))
        self.__dict__["_set_rotation_angle"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+39, agcom.DOUBLE)
        self.__dict__["_get_rotation_point"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+40, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_rotation_point"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+41, agcom.SAFEARRAY)
        self.__dict__["_get_scale"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+42, POINTER(agcom.DOUBLE))
        self.__dict__["_set_scale"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+43, agcom.DOUBLE)
        self.__dict__["_get_flip_x"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+44, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_flip_x"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+45, agcom.VARIANT_BOOL)
        self.__dict__["_get_flip_y"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+46, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_flip_y"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+47, agcom.VARIANT_BOOL)
        self.__dict__["_get_origin"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+48, POINTER(agcom.LONG))
        self.__dict__["_set_origin"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+49, agcom.LONG)
        self.__dict__["_get_pinning_origin"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+50, POINTER(agcom.LONG))
        self.__dict__["_set_pinning_origin"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+51, agcom.LONG)
        self.__dict__["_get_parent"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+52, POINTER(agcom.PVOID))
        self.__dict__["_get_translucency"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+53, POINTER(agcom.FLOAT))
        self.__dict__["_set_translucency"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+54, agcom.FLOAT)
        self.__dict__["_get_color"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+55, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_color"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+56, agcom.OLE_COLOR)
        self.__dict__["_get_picking_enabled"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+57, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_picking_enabled"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+58, agcom.VARIANT_BOOL)
        self.__dict__["_get_clip_to_parent"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+59, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_clip_to_parent"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+60, agcom.VARIANT_BOOL)
        self.__dict__["_get_display"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+61, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+62, agcom.VARIANT_BOOL)
        self.__dict__["_get_control_position"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+63, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_control_size"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+64, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_control_bounds"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+65, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_display_condition"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+66, POINTER(agcom.PVOID))
        self.__dict__["_set_display_condition"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+67, agcom.PVOID)
        self.__dict__["_get_overlays"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+68, POINTER(agcom.PVOID))
        self.__dict__["_get_padding"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+69, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_padding"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+70, agcom.SAFEARRAY)
        self.__dict__["_bring_to_front"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+71, )
        self.__dict__["_send_to_back"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+72, )
        self.__dict__["_overlay_to_control"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+73, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.SAFEARRAY))
        self.__dict__["_control_to_overlay"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+74, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_tag"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+75, POINTER(agcom.VARIANT))
        self.__dict__["_set_tag"] = IAGFUNCTYPE(pUnk, IID_IOverlay, vtable_offset_local+76, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IOverlay.__dict__ and type(IOverlay.__dict__[attrname]) == property:
            return IOverlay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IOverlay.")
    
    @property
    def position(self) -> list:
        """Gets or sets the position of the overlay relative to its parent. The array represents the position of the overlay and has a size of 4. The elements are in the order x position, y position, x screen overlay unit, y screen overlay unit."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @position.setter
    def position(self, position:list) -> None:
        with agmarshall.SAFEARRAY_arg(position) as arg_position:
            agcls.evaluate_hresult(self.__dict__["_set_position"](arg_position.COM_val))

    @property
    def pinning_position(self) -> list:
        """Gets or sets the pinning position of the overlay, relative to the overlay, which determines the point on the overlay that corresponds to the position property. The array represents the pinning position of the overlay and has a size of 4..."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_pinning_position"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @pinning_position.setter
    def pinning_position(self, pinningPosition:list) -> None:
        with agmarshall.SAFEARRAY_arg(pinningPosition) as arg_pinningPosition:
            agcls.evaluate_hresult(self.__dict__["_set_pinning_position"](arg_pinningPosition.COM_val))

    @property
    def x(self) -> float:
        """Gets or sets the X position of the overlay relative to its parent. The unit in which the position is defined is specified by the x unit property. The position is measured horizontally from the origin, which is, by default, the lower-left corner."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_x"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @x.setter
    def x(self, x:float) -> None:
        with agmarshall.DOUBLE_arg(x) as arg_x:
            agcls.evaluate_hresult(self.__dict__["_set_x"](arg_x.COM_val))

    @property
    def x_unit(self) -> "AgEStkGraphicsScreenOverlayUnit":
        """Gets or sets the unit of the x property."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsScreenOverlayUnit) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_x_unit"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @x_unit.setter
    def x_unit(self, xUnit:"AgEStkGraphicsScreenOverlayUnit") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsScreenOverlayUnit, xUnit) as arg_xUnit:
            agcls.evaluate_hresult(self.__dict__["_set_x_unit"](arg_xUnit.COM_val))

    @property
    def y(self) -> float:
        """Gets or sets the Y position of the overlay relative to its parent. The unit in which the position is defined is specified by the y unit property. The position is measured vertically from the origin, which is, by default, the lower-left corner."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_y"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @y.setter
    def y(self, y:float) -> None:
        with agmarshall.DOUBLE_arg(y) as arg_y:
            agcls.evaluate_hresult(self.__dict__["_set_y"](arg_y.COM_val))

    @property
    def y_unit(self) -> "AgEStkGraphicsScreenOverlayUnit":
        """Gets or sets the unit of the y property."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsScreenOverlayUnit) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_y_unit"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @y_unit.setter
    def y_unit(self, yUnit:"AgEStkGraphicsScreenOverlayUnit") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsScreenOverlayUnit, yUnit) as arg_yUnit:
            agcls.evaluate_hresult(self.__dict__["_set_y_unit"](arg_yUnit.COM_val))

    @property
    def size(self) -> list:
        """Gets or sets the size of the overlay. The array elements represent the size of the overlay in the order width, height, width screen overlay unit, height screen overlay unit."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_size"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @size.setter
    def size(self, size:list) -> None:
        with agmarshall.SAFEARRAY_arg(size) as arg_size:
            agcls.evaluate_hresult(self.__dict__["_set_size"](arg_size.COM_val))

    @property
    def width(self) -> float:
        """Gets or sets the width of the overlay. The unit in which the width is defined is specified by the width unit property."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @width.setter
    def width(self, width:float) -> None:
        with agmarshall.DOUBLE_arg(width) as arg_width:
            agcls.evaluate_hresult(self.__dict__["_set_width"](arg_width.COM_val))

    @property
    def width_unit(self) -> "AgEStkGraphicsScreenOverlayUnit":
        """Gets or sets the unit of the width property."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsScreenOverlayUnit) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_width_unit"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @width_unit.setter
    def width_unit(self, widthUnit:"AgEStkGraphicsScreenOverlayUnit") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsScreenOverlayUnit, widthUnit) as arg_widthUnit:
            agcls.evaluate_hresult(self.__dict__["_set_width_unit"](arg_widthUnit.COM_val))

    @property
    def height(self) -> float:
        """Gets or sets the height of the overlay. The unit in which the height is defined is specified by the height unit property."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_height"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @height.setter
    def height(self, height:float) -> None:
        with agmarshall.DOUBLE_arg(height) as arg_height:
            agcls.evaluate_hresult(self.__dict__["_set_height"](arg_height.COM_val))

    @property
    def height_unit(self) -> "AgEStkGraphicsScreenOverlayUnit":
        """Gets or sets the unit of the height property."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsScreenOverlayUnit) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_height_unit"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @height_unit.setter
    def height_unit(self, heightUnit:"AgEStkGraphicsScreenOverlayUnit") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsScreenOverlayUnit, heightUnit) as arg_heightUnit:
            agcls.evaluate_hresult(self.__dict__["_set_height_unit"](arg_heightUnit.COM_val))

    @property
    def minimum_size(self) -> list:
        """Gets or sets the minimum size of the overlay. The overlay will never be smaller than this size, even if the overlay's size is specified as a percentage of its parent and its parent is very small..."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_size"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @minimum_size.setter
    def minimum_size(self, minimumSize:list) -> None:
        with agmarshall.SAFEARRAY_arg(minimumSize) as arg_minimumSize:
            agcls.evaluate_hresult(self.__dict__["_set_minimum_size"](arg_minimumSize.COM_val))

    @property
    def maximum_size(self) -> list:
        """Gets or sets the maximum size of the overlay. The overlay will never be larger than this size, even if the overlay's size is specified as a percentage of its parent and its parent is very large..."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_size"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @maximum_size.setter
    def maximum_size(self, maximumSize:list) -> None:
        with agmarshall.SAFEARRAY_arg(maximumSize) as arg_maximumSize:
            agcls.evaluate_hresult(self.__dict__["_set_maximum_size"](arg_maximumSize.COM_val))

    @property
    def bounds(self) -> list:
        """Gets the bounds of the overlay relative to its parent. The array contains the properties defining the bounds in the order left x location, top y location, width, height."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_bounds"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def border_color(self) -> agcolor.Color:
        """Gets or sets the overlay's border color. By default, the border color is white. However, also by default, the overlay has a border size of 0.0 so the border is not displayed."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_border_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @border_color.setter
    def border_color(self, borderColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(borderColor) as arg_borderColor:
            agcls.evaluate_hresult(self.__dict__["_set_border_color"](arg_borderColor.COM_val))

    @property
    def border_size(self) -> int:
        """Gets or sets the size of the overlay's border. By default, this is 0.0 so the border is not displayed."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_border_size"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @border_size.setter
    def border_size(self, borderSize:int) -> None:
        with agmarshall.INT_arg(borderSize) as arg_borderSize:
            agcls.evaluate_hresult(self.__dict__["_set_border_size"](arg_borderSize.COM_val))

    @property
    def border_translucency(self) -> float:
        """Gets or sets the translucency of the overlay border. Translucency is a value between 0.0 and 1.0, where 0.0 is completely opaque and 1.0 is completely transparent."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_border_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @border_translucency.setter
    def border_translucency(self, borderTranslucency:float) -> None:
        with agmarshall.FLOAT_arg(borderTranslucency) as arg_borderTranslucency:
            agcls.evaluate_hresult(self.__dict__["_set_border_translucency"](arg_borderTranslucency.COM_val))

    @property
    def translation_x(self) -> float:
        """Gets or sets the value with which the overlay will be translated from the X value of the position property."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_translation_x"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @translation_x.setter
    def translation_x(self, translationX:float) -> None:
        with agmarshall.DOUBLE_arg(translationX) as arg_translationX:
            agcls.evaluate_hresult(self.__dict__["_set_translation_x"](arg_translationX.COM_val))

    @property
    def translation_y(self) -> float:
        """Gets or sets the value with which the overlay will be translated from the Y value of the position property."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_translation_y"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @translation_y.setter
    def translation_y(self, translationY:float) -> None:
        with agmarshall.DOUBLE_arg(translationY) as arg_translationY:
            agcls.evaluate_hresult(self.__dict__["_set_translation_y"](arg_translationY.COM_val))

    @property
    def rotation_angle(self) -> float:
        """Gets or sets the counter-clockwise rotation of the overlay. The overlay is rotated around the point specified by the rotation point property."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_rotation_angle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @rotation_angle.setter
    def rotation_angle(self, rotationAngle:float) -> None:
        with agmarshall.DOUBLE_arg(rotationAngle) as arg_rotationAngle:
            agcls.evaluate_hresult(self.__dict__["_set_rotation_angle"](arg_rotationAngle.COM_val))

    @property
    def rotation_point(self) -> list:
        """Gets or sets the point that the overlay is rotated around when the rotation angle property has a value other than 0.0. The array contains seven elements defining the properties of the rotation point..."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_rotation_point"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @rotation_point.setter
    def rotation_point(self, rotationPoint:list) -> None:
        with agmarshall.SAFEARRAY_arg(rotationPoint) as arg_rotationPoint:
            agcls.evaluate_hresult(self.__dict__["_set_rotation_point"](arg_rotationPoint.COM_val))

    @property
    def scale(self) -> float:
        """Gets or sets the fractional value used to scale the overlay's size property. A value greater than 1.0 will make the overlay larger while a value less than 1.0 will make it smaller."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @scale.setter
    def scale(self, scale:float) -> None:
        with agmarshall.DOUBLE_arg(scale) as arg_scale:
            agcls.evaluate_hresult(self.__dict__["_set_scale"](arg_scale.COM_val))

    @property
    def flip_x(self) -> bool:
        """Gets or sets whether the overlay will be flipped along its X axis."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_flip_x"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @flip_x.setter
    def flip_x(self, flipX:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(flipX) as arg_flipX:
            agcls.evaluate_hresult(self.__dict__["_set_flip_x"](arg_flipX.COM_val))

    @property
    def flip_y(self) -> bool:
        """Gets or sets whether the overlay will be flipped along its Y axis."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_flip_y"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @flip_y.setter
    def flip_y(self, flipY:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(flipY) as arg_flipY:
            agcls.evaluate_hresult(self.__dict__["_set_flip_y"](arg_flipY.COM_val))

    @property
    def origin(self) -> "AgEStkGraphicsScreenOverlayOrigin":
        """Gets or sets the origin from which the overlay's position is defined. By default, the value of this property is bottom left..."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsScreenOverlayOrigin) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_origin"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @origin.setter
    def origin(self, origin:"AgEStkGraphicsScreenOverlayOrigin") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsScreenOverlayOrigin, origin) as arg_origin:
            agcls.evaluate_hresult(self.__dict__["_set_origin"](arg_origin.COM_val))

    @property
    def pinning_origin(self) -> "AgEStkGraphicsScreenOverlayPinningOrigin":
        """Gets or sets the origin of the pinning position property, relative to the overlay..."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsScreenOverlayPinningOrigin) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_pinning_origin"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @pinning_origin.setter
    def pinning_origin(self, pinningOrigin:"AgEStkGraphicsScreenOverlayPinningOrigin") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsScreenOverlayPinningOrigin, pinningOrigin) as arg_pinningOrigin:
            agcls.evaluate_hresult(self.__dict__["_set_pinning_origin"](arg_pinningOrigin.COM_val))

    @property
    def parent(self) -> "IScreenOverlayContainer":
        """Gets the overlay's parent. This may be another overlay if this overlay was added to that overlay's overlays collection. Or, it may be the screen overlay manager if this overlay was added to the scene manager'sscreen overlays collection."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def translucency(self) -> float:
        """Gets or sets the overlay's translucency. Translucency is a value between 0.0 and 1.0, where 0.0 is completely opaque and 1.0 is completely transparent."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @translucency.setter
    def translucency(self, translucency:float) -> None:
        with agmarshall.FLOAT_arg(translucency) as arg_translucency:
            agcls.evaluate_hresult(self.__dict__["_set_translucency"](arg_translucency.COM_val))

    @property
    def color(self) -> agcolor.Color:
        """Gets or sets the overlay's color. By default, the overlay is white."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @color.setter
    def color(self, color:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(color) as arg_color:
            agcls.evaluate_hresult(self.__dict__["_set_color"](arg_color.COM_val))

    @property
    def picking_enabled(self) -> bool:
        """Gets or sets a value indicating whether or not picking on the overlay is enabled. If picking is disabled, this overlay will never show up in the result of PickScreenOverlay, even if it occupies the specified pick position."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_picking_enabled"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @picking_enabled.setter
    def picking_enabled(self, pickingEnabled:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(pickingEnabled) as arg_pickingEnabled:
            agcls.evaluate_hresult(self.__dict__["_set_picking_enabled"](arg_pickingEnabled.COM_val))

    @property
    def clip_to_parent(self) -> bool:
        """Gets or sets a value indicating whether or not the overlay will be clipped by the bounds of its parent. If this property is <see langword='false' />, part of this overlay may be visible outside of its parent's bounds."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_clip_to_parent"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @clip_to_parent.setter
    def clip_to_parent(self, clipToParent:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(clipToParent) as arg_clipToParent:
            agcls.evaluate_hresult(self.__dict__["_set_clip_to_parent"](arg_clipToParent.COM_val))

    @property
    def display(self) -> bool:
        """Gets or sets if this overlay and the collection of overlays that are contained within this overlay should be rendered."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display.setter
    def display(self, display:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(display) as arg_display:
            agcls.evaluate_hresult(self.__dict__["_set_display"](arg_display.COM_val))

    @property
    def control_position(self) -> list:
        """Gets the position of the overlay in coordinates relative to the overall globe control. The array represents the position of the overlay and has a size of 4. The elements are in the order x position, y position, x screen overlay unit, y screen overlay unit."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_position"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def control_size(self) -> list:
        """Gets the size of the overlay in coordinates relative to the overall globe control. The elements are in the order width, height, width screen overlay unit, height screen overlay unit."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_size"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def control_bounds(self) -> list:
        """Gets the bounds of the overlay in coordinates relative to the overall globe control. The array contains the properties defining the bounds in the order left x location, top y location, width, height."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_bounds"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def display_condition(self) -> "IDisplayCondition":
        """Gets or sets the display condition that determines if the overlay should be rendered. Both this and display must evaluate to true for the overlay to be rendered."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_condition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @display_condition.setter
    def display_condition(self, displayCondition:"IDisplayCondition") -> None:
        with agmarshall.AgInterface_in_arg(displayCondition, IDisplayCondition) as arg_displayCondition:
            agcls.evaluate_hresult(self.__dict__["_set_display_condition"](arg_displayCondition.COM_val))

    @property
    def overlays(self) -> "IScreenOverlayCollection":
        """Gets the collection of overlays that are contained within this overlay."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_overlays"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def padding(self) -> list:
        """Gets or sets the padding surrounding the overlays that are contained within this overlay. The array contains the components of the padding arranged in the order left, top, right, bottom."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_padding"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @padding.setter
    def padding(self, padding:list) -> None:
        with agmarshall.SAFEARRAY_arg(padding) as arg_padding:
            agcls.evaluate_hresult(self.__dict__["_set_padding"](arg_padding.COM_val))

    def bring_to_front(self) -> None:
        """Brings the overlay to the front of the z-order, so it is on top of all other overlays with the same parent"""
        agcls.evaluate_hresult(self.__dict__["_bring_to_front"]())

    def send_to_back(self) -> None:
        """Sends the overlay to the back of the z-order, so it is underneath all other overlays with the same parent"""
        agcls.evaluate_hresult(self.__dict__["_send_to_back"]())

    def overlay_to_control(self, x:float, y:float) -> list:
        """Transforms a given position, specified relative to the overlay, into coordinates relative to the overall globe control..."""
        with agmarshall.DOUBLE_arg(x) as arg_x, \
             agmarshall.DOUBLE_arg(y) as arg_y, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_overlay_to_control"](arg_x.COM_val, arg_y.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def control_to_overlay(self, x:float, y:float) -> list:
        """Transforms a given position, specified relative to the overall globe control, into coordinates relative to this overlay..."""
        with agmarshall.DOUBLE_arg(x) as arg_x, \
             agmarshall.DOUBLE_arg(y) as arg_y, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_control_to_overlay"](arg_x.COM_val, arg_y.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def tag(self) -> typing.Any:
        """Gets or sets custom value associated with this primitive."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_tag"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @tag.setter
    def tag(self, tag:typing.Any) -> None:
        with agmarshall.VARIANT_arg(tag) as arg_tag:
            agcls.evaluate_hresult(self.__dict__["_set_tag"](arg_tag.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{b7007235-5a52-450b-83af-1e8080d3b0be}", IOverlay)
agcls.AgTypeNameMap["IOverlay"] = IOverlay

class IPathPrimitive(object):
    """Renders a line to the 3D scene. Similar to the polyline primitive; however, the PathPrimitive was designed for the efficient addition/removal of points to/from the front or back of the line."""
    _uuid = "{264ef2e0-ae0d-412d-9d89-f5f17f095a52}"
    _num_methods = 31
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_capacity"] = _raise_uninitialized_error
        self.__dict__["_get_update_policy"] = _raise_uninitialized_error
        self.__dict__["_set_update_policy"] = _raise_uninitialized_error
        self.__dict__["_get_polyline_type"] = _raise_uninitialized_error
        self.__dict__["_set_polyline_type"] = _raise_uninitialized_error
        self.__dict__["_get_width"] = _raise_uninitialized_error
        self.__dict__["_set_width"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_width_supported"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_width_supported"] = _raise_uninitialized_error
        self.__dict__["_get_display_outline"] = _raise_uninitialized_error
        self.__dict__["_set_display_outline"] = _raise_uninitialized_error
        self.__dict__["_get_outline_width"] = _raise_uninitialized_error
        self.__dict__["_set_outline_width"] = _raise_uninitialized_error
        self.__dict__["_get_per_item_picking_enabled"] = _raise_uninitialized_error
        self.__dict__["_set_per_item_picking_enabled"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_add_front"] = _raise_uninitialized_error
        self.__dict__["_add_range_to_front"] = _raise_uninitialized_error
        self.__dict__["_add_back"] = _raise_uninitialized_error
        self.__dict__["_add_range_to_back"] = _raise_uninitialized_error
        self.__dict__["_remove_front"] = _raise_uninitialized_error
        self.__dict__["_remove_all_before"] = _raise_uninitialized_error
        self.__dict__["_remove_back"] = _raise_uninitialized_error
        self.__dict__["_remove_all_after"] = _raise_uninitialized_error
        self.__dict__["_front"] = _raise_uninitialized_error
        self.__dict__["_back"] = _raise_uninitialized_error
        self.__dict__["_clear"] = _raise_uninitialized_error
        self.__dict__["_get_central_body_clipped"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_clipped"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPathPrimitive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPathPrimitive from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPathPrimitive = agcom.GUID(IPathPrimitive._uuid)
        vtable_offset_local = IPathPrimitive._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_get_capacity"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+2, POINTER(agcom.INT))
        self.__dict__["_get_update_policy"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_set_update_policy"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_get_polyline_type"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_polyline_type"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_width"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+7, POINTER(agcom.FLOAT))
        self.__dict__["_set_width"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+8, agcom.FLOAT)
        self.__dict__["_get_minimum_width_supported"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+9, POINTER(agcom.FLOAT))
        self.__dict__["_get_maximum_width_supported"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+10, POINTER(agcom.FLOAT))
        self.__dict__["_get_display_outline"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_outline"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_get_outline_width"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+13, POINTER(agcom.FLOAT))
        self.__dict__["_set_outline_width"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+14, agcom.FLOAT)
        self.__dict__["_get_per_item_picking_enabled"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_per_item_picking_enabled"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+17, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+18, POINTER(agcom.PVOID))
        self.__dict__["_add_front"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+19, agcom.PVOID)
        self.__dict__["_add_range_to_front"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+20, POINTER(agcom.SAFEARRAY))
        self.__dict__["_add_back"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+21, agcom.PVOID)
        self.__dict__["_add_range_to_back"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+22, POINTER(agcom.SAFEARRAY))
        self.__dict__["_remove_front"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+23, )
        self.__dict__["_remove_all_before"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+24, agcom.INT)
        self.__dict__["_remove_back"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+25, )
        self.__dict__["_remove_all_after"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+26, agcom.INT)
        self.__dict__["_front"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+27, POINTER(agcom.PVOID))
        self.__dict__["_back"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+28, POINTER(agcom.PVOID))
        self.__dict__["_clear"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+29, )
        self.__dict__["_get_central_body_clipped"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+30, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_central_body_clipped"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitive, vtable_offset_local+31, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPathPrimitive.__dict__ and type(IPathPrimitive.__dict__[attrname]) == property:
            return IPathPrimitive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPathPrimitive.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IPathPoint":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """Returns the number of points."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def capacity(self) -> int:
        """Returns the capacity that was set during object construction. The capacity is the amount of memory reserved for storing the points on the path. This will be automatically updated when adding/removing points."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_capacity"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def update_policy(self) -> "IPathPrimitiveUpdatePolicy":
        """Gets or sets how the primitive will be updated based on the current animation time."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_update_policy"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @update_policy.setter
    def update_policy(self, updatePolicy:"IPathPrimitiveUpdatePolicy") -> None:
        with agmarshall.AgInterface_in_arg(updatePolicy, IPathPrimitiveUpdatePolicy) as arg_updatePolicy:
            agcls.evaluate_hresult(self.__dict__["_set_update_policy"](arg_updatePolicy.COM_val))

    @property
    def polyline_type(self) -> "AgEStkGraphicsPolylineType":
        """Gets or sets how the primitive interprets the positions."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsPolylineType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_polyline_type"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @polyline_type.setter
    def polyline_type(self, polylineType:"AgEStkGraphicsPolylineType") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsPolylineType, polylineType) as arg_polylineType:
            agcls.evaluate_hresult(self.__dict__["_set_polyline_type"](arg_polylineType.COM_val))

    @property
    def width(self) -> float:
        """Gets or sets the line width, in pixels."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @width.setter
    def width(self, width:float) -> None:
        with agmarshall.FLOAT_arg(width) as arg_width:
            agcls.evaluate_hresult(self.__dict__["_set_width"](arg_width.COM_val))

    @property
    def minimum_width_supported(self) -> float:
        """Gets the minimum width, in pixels, supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_width_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def maximum_width_supported(self) -> float:
        """Gets the maximum width, in pixels, supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_width_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def display_outline(self) -> bool:
        """Gets or sets whether an outline is rendered around the line."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_outline"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_outline.setter
    def display_outline(self, displayOutline:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displayOutline) as arg_displayOutline:
            agcls.evaluate_hresult(self.__dict__["_set_display_outline"](arg_displayOutline.COM_val))

    @property
    def outline_width(self) -> float:
        """Gets or sets the width, in pixels, of the outline around the line."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_width.setter
    def outline_width(self, outlineWidth:float) -> None:
        with agmarshall.FLOAT_arg(outlineWidth) as arg_outlineWidth:
            agcls.evaluate_hresult(self.__dict__["_set_outline_width"](arg_outlineWidth.COM_val))

    @property
    def per_item_picking_enabled(self) -> bool:
        """Gets or sets whether individual line indices will be included in the pick results returned from the scene's Pick method. Each line index that is picked will be returned as a batch primitive index."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_per_item_picking_enabled"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @per_item_picking_enabled.setter
    def per_item_picking_enabled(self, perItemPickingEnabled:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(perItemPickingEnabled) as arg_perItemPickingEnabled:
            agcls.evaluate_hresult(self.__dict__["_set_per_item_picking_enabled"](arg_perItemPickingEnabled.COM_val))

    def item(self, index:int) -> "IPathPoint":
        """Returns the point at the given zero-based index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns an enumerator that iterates through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def add_front(self, pathPoint:"IPathPoint") -> None:
        """Add a path point to the front of the line."""
        with agmarshall.AgInterface_in_arg(pathPoint, IPathPoint) as arg_pathPoint:
            agcls.evaluate_hresult(self.__dict__["_add_front"](arg_pathPoint.COM_val))

    def add_range_to_front(self, positions:list) -> None:
        """Add the range of path points to the front of the line."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions:
            agcls.evaluate_hresult(self.__dict__["_add_range_to_front"](byref(arg_positions.COM_val)))

    def add_back(self, pathPoint:"IPathPoint") -> None:
        """Add a path point to the back of the line."""
        with agmarshall.AgInterface_in_arg(pathPoint, IPathPoint) as arg_pathPoint:
            agcls.evaluate_hresult(self.__dict__["_add_back"](arg_pathPoint.COM_val))

    def add_range_to_back(self, positions:list) -> None:
        """Add the range of path points to the back of the line."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions:
            agcls.evaluate_hresult(self.__dict__["_add_range_to_back"](byref(arg_positions.COM_val)))

    def remove_front(self) -> None:
        """Remove a path point to the front of the line."""
        agcls.evaluate_hresult(self.__dict__["_remove_front"]())

    def remove_all_before(self, index:int) -> None:
        """Remove all points before index."""
        with agmarshall.INT_arg(index) as arg_index:
            agcls.evaluate_hresult(self.__dict__["_remove_all_before"](arg_index.COM_val))

    def remove_back(self) -> None:
        """Remove a path point to the back of the line."""
        agcls.evaluate_hresult(self.__dict__["_remove_back"]())

    def remove_all_after(self, index:int) -> None:
        """Remove all points after index."""
        with agmarshall.INT_arg(index) as arg_index:
            agcls.evaluate_hresult(self.__dict__["_remove_all_after"](arg_index.COM_val))

    def front(self) -> "IPathPoint":
        """Access the path point at the front of the line."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_front"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def back(self) -> "IPathPoint":
        """Access the path point at the back of the line."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_back"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def clear(self) -> None:
        """Removes all of the points."""
        agcls.evaluate_hresult(self.__dict__["_clear"]())

    @property
    def central_body_clipped(self) -> bool:
        """Gets or sets whether the polyline will be clipped by the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_clipped"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @central_body_clipped.setter
    def central_body_clipped(self, centralBodyClipped:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(centralBodyClipped) as arg_centralBodyClipped:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_clipped"](arg_centralBodyClipped.COM_val))

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{264ef2e0-ae0d-412d-9d89-f5f17f095a52}", IPathPrimitive)
agcls.AgTypeNameMap["IPathPrimitive"] = IPathPrimitive

class IPickResult(object):
    """A single result from Pick."""
    _uuid = "{55238a64-4c7f-4be7-abcb-1d2321f8f64a}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_objects"] = _raise_uninitialized_error
        self.__dict__["_get_depth"] = _raise_uninitialized_error
        self.__dict__["_get_position"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPickResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPickResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPickResult = agcom.GUID(IPickResult._uuid)
        vtable_offset_local = IPickResult._vtable_offset - 1
        self.__dict__["_get_objects"] = IAGFUNCTYPE(pUnk, IID_IPickResult, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_depth"] = IAGFUNCTYPE(pUnk, IID_IPickResult, vtable_offset_local+2, POINTER(agcom.FLOAT))
        self.__dict__["_get_position"] = IAGFUNCTYPE(pUnk, IID_IPickResult, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPickResult.__dict__ and type(IPickResult.__dict__[attrname]) == property:
            return IPickResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPickResult.")
    
    @property
    def objects(self) -> "IObjectCollection":
        """Gets a collection of objects that were on the pick stack for the picked object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_objects"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def depth(self) -> float:
        """Gets the depth of the picked location in the 3D scene."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_depth"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def position(self) -> list:
        """Gets the position of the picked location in the central body's fixed reference frame. The array contains the components of the position arranged in the order x, y, z."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{55238a64-4c7f-4be7-abcb-1d2321f8f64a}", IPickResult)
agcls.AgTypeNameMap["IPickResult"] = IPickResult

class IPixelSizeDisplayCondition(object):
    """Defines an inclusive interval, in pixels, that determines when an object, such as a primitive, is rendered based on the number of pixels the object's bounding sphere (or in the case of screen overlays, bounding rectangle) covers on the screen..."""
    _uuid = "{e5ccd610-a3b3-4f0c-9d51-e367a9ea5abf}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_minimum_pixel_size"] = _raise_uninitialized_error
        self.__dict__["_set_minimum_pixel_size"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_pixel_size"] = _raise_uninitialized_error
        self.__dict__["_set_maximum_pixel_size"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPixelSizeDisplayCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPixelSizeDisplayCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPixelSizeDisplayCondition = agcom.GUID(IPixelSizeDisplayCondition._uuid)
        vtable_offset_local = IPixelSizeDisplayCondition._vtable_offset - 1
        self.__dict__["_get_minimum_pixel_size"] = IAGFUNCTYPE(pUnk, IID_IPixelSizeDisplayCondition, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_set_minimum_pixel_size"] = IAGFUNCTYPE(pUnk, IID_IPixelSizeDisplayCondition, vtable_offset_local+2, agcom.INT)
        self.__dict__["_get_maximum_pixel_size"] = IAGFUNCTYPE(pUnk, IID_IPixelSizeDisplayCondition, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_set_maximum_pixel_size"] = IAGFUNCTYPE(pUnk, IID_IPixelSizeDisplayCondition, vtable_offset_local+4, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPixelSizeDisplayCondition.__dict__ and type(IPixelSizeDisplayCondition.__dict__[attrname]) == property:
            return IPixelSizeDisplayCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPixelSizeDisplayCondition.")
    
    @property
    def minimum_pixel_size(self) -> int:
        """Gets or sets the minimum pixel size of the inclusive distance interval."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_pixel_size"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @minimum_pixel_size.setter
    def minimum_pixel_size(self, minimumPixelSize:int) -> None:
        with agmarshall.INT_arg(minimumPixelSize) as arg_minimumPixelSize:
            agcls.evaluate_hresult(self.__dict__["_set_minimum_pixel_size"](arg_minimumPixelSize.COM_val))

    @property
    def maximum_pixel_size(self) -> int:
        """Gets or sets the maximum pixel size of the inclusive distance interval. Use Int32.MaxValue to ignore checking the maximum distance."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_pixel_size"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @maximum_pixel_size.setter
    def maximum_pixel_size(self, maximumPixelSize:int) -> None:
        with agmarshall.INT_arg(maximumPixelSize) as arg_maximumPixelSize:
            agcls.evaluate_hresult(self.__dict__["_set_maximum_pixel_size"](arg_maximumPixelSize.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{e5ccd610-a3b3-4f0c-9d51-e367a9ea5abf}", IPixelSizeDisplayCondition)
agcls.AgTypeNameMap["IPixelSizeDisplayCondition"] = IPixelSizeDisplayCondition

class IPointBatchPrimitive(object):
    """ Renders one or more points in the 3D scene. Each point in the batch has a unique position and an optional color. All points in the batch share the same pixel size. For best performance, avoid creating lots of batches with only a few points each..."""
    _uuid = "{ae6c6dca-3afe-4419-8aad-dd56bee51446}"
    _num_methods = 34
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_display_outline"] = _raise_uninitialized_error
        self.__dict__["_set_display_outline"] = _raise_uninitialized_error
        self.__dict__["_get_outline_color"] = _raise_uninitialized_error
        self.__dict__["_set_outline_color"] = _raise_uninitialized_error
        self.__dict__["_get_outline_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_outline_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_outline_width"] = _raise_uninitialized_error
        self.__dict__["_set_outline_width"] = _raise_uninitialized_error
        self.__dict__["_get_pixel_size"] = _raise_uninitialized_error
        self.__dict__["_set_pixel_size"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_pixel_size_supported"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_pixel_size_supported"] = _raise_uninitialized_error
        self.__dict__["_get_distance_display_condition_per_point"] = _raise_uninitialized_error
        self.__dict__["_set_distance_display_condition_per_point"] = _raise_uninitialized_error
        self.__dict__["_get_set_hint"] = _raise_uninitialized_error
        self.__dict__["_get_per_item_picking_enabled"] = _raise_uninitialized_error
        self.__dict__["_set_per_item_picking_enabled"] = _raise_uninitialized_error
        self.__dict__["_set"] = _raise_uninitialized_error
        self.__dict__["_set_with_colors"] = _raise_uninitialized_error
        self.__dict__["_set_with_colors_and_render_pass"] = _raise_uninitialized_error
        self.__dict__["_set_cartographic"] = _raise_uninitialized_error
        self.__dict__["_set_cartographic_with_colors"] = _raise_uninitialized_error
        self.__dict__["_set_cartographic_with_colors_and_render_pass"] = _raise_uninitialized_error
        self.__dict__["_set_partial"] = _raise_uninitialized_error
        self.__dict__["_set_partial_with_indices_order"] = _raise_uninitialized_error
        self.__dict__["_set_partial_with_colors"] = _raise_uninitialized_error
        self.__dict__["_set_partial_with_colors_indices_order_and_render_pass"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic_with_indices_order"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic_with_colors"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic_with_colors_indices_order_and_render_pass"] = _raise_uninitialized_error
        self.__dict__["_get_central_body_clipped"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_clipped"] = _raise_uninitialized_error
        self.__dict__["_set_with_optional_parameters"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointBatchPrimitive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointBatchPrimitive from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointBatchPrimitive = agcom.GUID(IPointBatchPrimitive._uuid)
        vtable_offset_local = IPointBatchPrimitive._vtable_offset - 1
        self.__dict__["_get_display_outline"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_outline"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_outline_color"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+3, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_outline_color"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+4, agcom.OLE_COLOR)
        self.__dict__["_get_outline_translucency"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+5, POINTER(agcom.FLOAT))
        self.__dict__["_set_outline_translucency"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+6, agcom.FLOAT)
        self.__dict__["_get_outline_width"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+7, POINTER(agcom.FLOAT))
        self.__dict__["_set_outline_width"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+8, agcom.FLOAT)
        self.__dict__["_get_pixel_size"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+9, POINTER(agcom.FLOAT))
        self.__dict__["_set_pixel_size"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+10, agcom.FLOAT)
        self.__dict__["_get_minimum_pixel_size_supported"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+11, POINTER(agcom.FLOAT))
        self.__dict__["_get_maximum_pixel_size_supported"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+12, POINTER(agcom.FLOAT))
        self.__dict__["_get_distance_display_condition_per_point"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_set_distance_display_condition_per_point"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+14, agcom.PVOID)
        self.__dict__["_get_set_hint"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_get_per_item_picking_enabled"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_per_item_picking_enabled"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_set"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+18, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_with_colors"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+19, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_with_colors_and_render_pass"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+20, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG)
        self.__dict__["_set_cartographic"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+21, agcom.BSTR, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_cartographic_with_colors"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+22, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_cartographic_with_colors_and_render_pass"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+23, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG)
        self.__dict__["_set_partial"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+24, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_with_indices_order"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+25, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG)
        self.__dict__["_set_partial_with_colors"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+26, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_with_colors_indices_order_and_render_pass"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+27, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG, agcom.LONG)
        self.__dict__["_set_partial_cartographic"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+28, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_cartographic_with_indices_order"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+29, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG)
        self.__dict__["_set_partial_cartographic_with_colors"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+30, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_cartographic_with_colors_indices_order_and_render_pass"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+31, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG, agcom.LONG)
        self.__dict__["_get_central_body_clipped"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+32, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_central_body_clipped"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+33, agcom.VARIANT_BOOL)
        self.__dict__["_set_with_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitive, vtable_offset_local+34, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.PVOID, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointBatchPrimitive.__dict__ and type(IPointBatchPrimitive.__dict__[attrname]) == property:
            return IPointBatchPrimitive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointBatchPrimitive.")
    
    @property
    def display_outline(self) -> bool:
        """Gets or sets whether an outline is rendered around each point in the batch."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_outline"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_outline.setter
    def display_outline(self, displayOutline:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displayOutline) as arg_displayOutline:
            agcls.evaluate_hresult(self.__dict__["_set_display_outline"](arg_displayOutline.COM_val))

    @property
    def outline_color(self) -> agcolor.Color:
        """Gets or sets the outline's color."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_color.setter
    def outline_color(self, outlineColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(outlineColor) as arg_outlineColor:
            agcls.evaluate_hresult(self.__dict__["_set_outline_color"](arg_outlineColor.COM_val))

    @property
    def outline_translucency(self) -> float:
        """Gets or sets the translucency of the outline. Translucency is between 0 and 1, where 0 is opaque and 1 is transparent."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_translucency.setter
    def outline_translucency(self, outlineTranslucency:float) -> None:
        with agmarshall.FLOAT_arg(outlineTranslucency) as arg_outlineTranslucency:
            agcls.evaluate_hresult(self.__dict__["_set_outline_translucency"](arg_outlineTranslucency.COM_val))

    @property
    def outline_width(self) -> float:
        """Gets or sets the size, in pixels, of the outline around each point in the batch."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_width.setter
    def outline_width(self, outlineWidth:float) -> None:
        with agmarshall.FLOAT_arg(outlineWidth) as arg_outlineWidth:
            agcls.evaluate_hresult(self.__dict__["_set_outline_width"](arg_outlineWidth.COM_val))

    @property
    def pixel_size(self) -> float:
        """Gets or sets the size, in pixels, of each point in the point batch."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_pixel_size"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @pixel_size.setter
    def pixel_size(self, pixelSize:float) -> None:
        with agmarshall.FLOAT_arg(pixelSize) as arg_pixelSize:
            agcls.evaluate_hresult(self.__dict__["_set_pixel_size"](arg_pixelSize.COM_val))

    @property
    def minimum_pixel_size_supported(self) -> float:
        """Gets the minimum pixel size supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_pixel_size_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def maximum_pixel_size_supported(self) -> float:
        """Gets the maximum pixel size supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_pixel_size_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def distance_display_condition_per_point(self) -> "IDistanceDisplayCondition":
        """Gets or sets a distance display condition that is evaluated per point in the point batch during rendering. This is different than display condition, which is evaluated once for the entire point batch..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_distance_display_condition_per_point"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @distance_display_condition_per_point.setter
    def distance_display_condition_per_point(self, distanceDisplayConditionPerPoint:"IDistanceDisplayCondition") -> None:
        with agmarshall.AgInterface_in_arg(distanceDisplayConditionPerPoint, IDistanceDisplayCondition) as arg_distanceDisplayConditionPerPoint:
            agcls.evaluate_hresult(self.__dict__["_set_distance_display_condition_per_point"](arg_distanceDisplayConditionPerPoint.COM_val))

    @property
    def set_hint(self) -> "AgEStkGraphicsSetHint":
        """Gets the primitive's set hint. See the Set Hint Performance Overview for selecting an appropriate value to construct the primitive with."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSetHint) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_set_hint"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def per_item_picking_enabled(self) -> bool:
        """Gets or sets whether individual point indices will be included in the pick results returned from the scene's Pick method. Each point index that is picked will be returned as a batch primitive index."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_per_item_picking_enabled"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @per_item_picking_enabled.setter
    def per_item_picking_enabled(self, perItemPickingEnabled:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(perItemPickingEnabled) as arg_perItemPickingEnabled:
            agcls.evaluate_hresult(self.__dict__["_set_per_item_picking_enabled"](arg_perItemPickingEnabled.COM_val))

    def set(self, positions:list) -> None:
        """Defines the positions of points in a point batch. The points are rendered in the primitive's reference frame."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions:
            agcls.evaluate_hresult(self.__dict__["_set"](byref(arg_positions.COM_val)))

    def set_with_colors(self, positions:list, colors:list) -> None:
        """Defines the positions and colors of points in a point batch. The points are rendered in the primitive's reference frame."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors:
            agcls.evaluate_hresult(self.__dict__["_set_with_colors"](byref(arg_positions.COM_val), byref(arg_colors.COM_val)))

    def set_with_colors_and_render_pass(self, positions:list, colors:list, renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """Defines the positions and colors of points in a point batch. The points are rendered in the primitive's reference frame. renderPassHint is provided for efficiency."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_with_colors_and_render_pass"](byref(arg_positions.COM_val), byref(arg_colors.COM_val), arg_renderPassHint.COM_val))

    def set_cartographic(self, centralBody:str, positions:list) -> None:
        """For convenience. Defines the positions of points in a point batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions:
            agcls.evaluate_hresult(self.__dict__["_set_cartographic"](arg_centralBody.COM_val, byref(arg_positions.COM_val)))

    def set_cartographic_with_colors(self, centralBody:str, positions:list, colors:list) -> None:
        """For convenience. Defines the positions and colors of points in a point batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors:
            agcls.evaluate_hresult(self.__dict__["_set_cartographic_with_colors"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_colors.COM_val)))

    def set_cartographic_with_colors_and_render_pass(self, centralBody:str, positions:list, colors:list, renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """For convenience. Defines the positions and colors of points in a point batch using cartographic positions. renderPassHint is provided for efficiency. This is equivalent to converting each position in positions to cartesian and calling Set."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_cartographic_with_colors_and_render_pass"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_colors.COM_val), arg_renderPassHint.COM_val))

    def set_partial(self, positions:list, indices:list) -> None:
        """Updates a subset of positions in a point batch."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial"](byref(arg_positions.COM_val), byref(arg_indices.COM_val)))

    def set_partial_with_indices_order(self, positions:list, indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint") -> None:
        """Updates a subset of positions in a point batch."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_with_indices_order"](byref(arg_positions.COM_val), byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val))

    def set_partial_with_colors(self, positions:list, colors:list, indices:list) -> None:
        """Updates a subset of positions and/or colors in a point batch."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial_with_colors"](byref(arg_positions.COM_val), byref(arg_colors.COM_val), byref(arg_indices.COM_val)))

    def set_partial_with_colors_indices_order_and_render_pass(self, positions:list, colors:list, indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint", renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """Updates a subset of positions and/or colors in a point batch."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_with_colors_indices_order_and_render_pass"](byref(arg_positions.COM_val), byref(arg_colors.COM_val), byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val, arg_renderPassHint.COM_val))

    def set_partial_cartographic(self, centralBody:str, positions:list, indices:list) -> None:
        """For convenience. Updates a subset of positions in a point batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_indices.COM_val)))

    def set_partial_cartographic_with_indices_order(self, centralBody:str, positions:list, indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint") -> None:
        """For convenience. Updates a subset of positions in a point batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic_with_indices_order"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val))

    def set_partial_cartographic_with_colors(self, centralBody:str, positions:list, colors:list, indices:list) -> None:
        """For convenience. Updates a subset of positions and/or colors in a point batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic_with_colors"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_colors.COM_val), byref(arg_indices.COM_val)))

    def set_partial_cartographic_with_colors_indices_order_and_render_pass(self, centralBody:str, positions:list, colors:list, indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint", renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """For convenience. Updates a subset of positions and/or colors in a point batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic_with_colors_indices_order_and_render_pass"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_colors.COM_val), byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val, arg_renderPassHint.COM_val))

    @property
    def central_body_clipped(self) -> bool:
        """Gets or sets whether individual points will be clipped by the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_clipped"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @central_body_clipped.setter
    def central_body_clipped(self, centralBodyClipped:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(centralBodyClipped) as arg_centralBodyClipped:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_clipped"](arg_centralBodyClipped.COM_val))

    def set_with_optional_parameters(self, positions:list, colors:list, optionalParameters:"IPointBatchPrimitiveOptionalParameters", renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """Defines the positions, colors, and optional parameters of points in a point batch. The points are rendered in the primitive's reference frame. renderPassHint is provided for efficiency."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.AgInterface_in_arg(optionalParameters, IPointBatchPrimitiveOptionalParameters) as arg_optionalParameters, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_with_optional_parameters"](byref(arg_positions.COM_val), byref(arg_colors.COM_val), arg_optionalParameters.COM_val, arg_renderPassHint.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ae6c6dca-3afe-4419-8aad-dd56bee51446}", IPointBatchPrimitive)
agcls.AgTypeNameMap["IPointBatchPrimitive"] = IPointBatchPrimitive

class IPointBatchPrimitiveOptionalParameters(object):
    """Optional per-point parameters for point batch primitive that overrides the point batch primitive's global parameters..."""
    _uuid = "{e8b88732-1377-483c-bf19-ffafeb1d8d52}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_set_pixel_sizes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointBatchPrimitiveOptionalParameters._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointBatchPrimitiveOptionalParameters from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointBatchPrimitiveOptionalParameters = agcom.GUID(IPointBatchPrimitiveOptionalParameters._uuid)
        vtable_offset_local = IPointBatchPrimitiveOptionalParameters._vtable_offset - 1
        self.__dict__["_set_pixel_sizes"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitiveOptionalParameters, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointBatchPrimitiveOptionalParameters.__dict__ and type(IPointBatchPrimitiveOptionalParameters.__dict__[attrname]) == property:
            return IPointBatchPrimitiveOptionalParameters.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointBatchPrimitiveOptionalParameters.")
    
    def set_pixel_sizes(self, pixelSizes:list) -> None:
        """Defines a collection of pixel sizes, one for each point in the point batch."""
        with agmarshall.SAFEARRAY_arg(pixelSizes) as arg_pixelSizes:
            agcls.evaluate_hresult(self.__dict__["_set_pixel_sizes"](byref(arg_pixelSizes.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{e8b88732-1377-483c-bf19-ffafeb1d8d52}", IPointBatchPrimitiveOptionalParameters)
agcls.AgTypeNameMap["IPointBatchPrimitiveOptionalParameters"] = IPointBatchPrimitiveOptionalParameters

class IPolylinePrimitive(object):
    """Renders a polyline in the 3D scene. Each line segment may have a different color. A polyline can be constructed with a position interpolator to render great arcs or rhumb lines."""
    _uuid = "{0122dc2b-4232-443d-b8da-09b42967b841}"
    _num_methods = 42
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_width"] = _raise_uninitialized_error
        self.__dict__["_set_width"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_width_supported"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_width_supported"] = _raise_uninitialized_error
        self.__dict__["_get_position_interpolator"] = _raise_uninitialized_error
        self.__dict__["_get_polyline_type"] = _raise_uninitialized_error
        self.__dict__["_get_set_hint"] = _raise_uninitialized_error
        self.__dict__["_get_display_outline"] = _raise_uninitialized_error
        self.__dict__["_set_display_outline"] = _raise_uninitialized_error
        self.__dict__["_get_outline_color"] = _raise_uninitialized_error
        self.__dict__["_set_outline_color"] = _raise_uninitialized_error
        self.__dict__["_get_outline_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_outline_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_outline_width"] = _raise_uninitialized_error
        self.__dict__["_set_outline_width"] = _raise_uninitialized_error
        self.__dict__["_get_per_item_picking_enabled"] = _raise_uninitialized_error
        self.__dict__["_set_per_item_picking_enabled"] = _raise_uninitialized_error
        self.__dict__["_set"] = _raise_uninitialized_error
        self.__dict__["_set_with_colors"] = _raise_uninitialized_error
        self.__dict__["_set_with_colors_and_hint"] = _raise_uninitialized_error
        self.__dict__["_set_with_surface_shapes_result"] = _raise_uninitialized_error
        self.__dict__["_set_with_surface_triangulator_result"] = _raise_uninitialized_error
        self.__dict__["_set_with_solid_triangulator_result"] = _raise_uninitialized_error
        self.__dict__["_set_cartographic"] = _raise_uninitialized_error
        self.__dict__["_set_cartographic_with_colors"] = _raise_uninitialized_error
        self.__dict__["_set_cartographic_with_colors_and_hint"] = _raise_uninitialized_error
        self.__dict__["_set_subset"] = _raise_uninitialized_error
        self.__dict__["_set_subset_cartographic"] = _raise_uninitialized_error
        self.__dict__["_set_partial"] = _raise_uninitialized_error
        self.__dict__["_set_partial_with_indices_order"] = _raise_uninitialized_error
        self.__dict__["_set_partial_with_colors"] = _raise_uninitialized_error
        self.__dict__["_set_partial_with_colors_indices_order_and_render_pass_hint"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic_with_indices_order"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic_with_colors"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic_with_colors_indices_order_and_render_pass"] = _raise_uninitialized_error
        self.__dict__["_get_central_body_clipped"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_clipped"] = _raise_uninitialized_error
        self.__dict__["_set_with_colors_and_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_set_cartographic_with_colors_and_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_set_partial_with_colors_and_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic_with_optional_parameters"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPolylinePrimitive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPolylinePrimitive from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPolylinePrimitive = agcom.GUID(IPolylinePrimitive._uuid)
        vtable_offset_local = IPolylinePrimitive._vtable_offset - 1
        self.__dict__["_get_width"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+1, POINTER(agcom.FLOAT))
        self.__dict__["_set_width"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+2, agcom.FLOAT)
        self.__dict__["_get_minimum_width_supported"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+3, POINTER(agcom.FLOAT))
        self.__dict__["_get_maximum_width_supported"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+4, POINTER(agcom.FLOAT))
        self.__dict__["_get_position_interpolator"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_polyline_type"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_get_set_hint"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_get_display_outline"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_outline"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_outline_color"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+10, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_outline_color"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+11, agcom.OLE_COLOR)
        self.__dict__["_get_outline_translucency"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+12, POINTER(agcom.FLOAT))
        self.__dict__["_set_outline_translucency"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+13, agcom.FLOAT)
        self.__dict__["_get_outline_width"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+14, POINTER(agcom.FLOAT))
        self.__dict__["_set_outline_width"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+15, agcom.FLOAT)
        self.__dict__["_get_per_item_picking_enabled"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_per_item_picking_enabled"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_set"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+18, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_with_colors"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+19, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_with_colors_and_hint"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+20, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG)
        self.__dict__["_set_with_surface_shapes_result"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+21, agcom.PVOID)
        self.__dict__["_set_with_surface_triangulator_result"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+22, agcom.PVOID)
        self.__dict__["_set_with_solid_triangulator_result"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+23, agcom.PVOID)
        self.__dict__["_set_cartographic"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+24, agcom.BSTR, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_cartographic_with_colors"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+25, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_cartographic_with_colors_and_hint"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+26, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG)
        self.__dict__["_set_subset"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+27, POINTER(agcom.SAFEARRAY), agcom.INT, agcom.INT)
        self.__dict__["_set_subset_cartographic"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+28, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.INT, agcom.INT)
        self.__dict__["_set_partial"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+29, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_with_indices_order"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+30, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG)
        self.__dict__["_set_partial_with_colors"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+31, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_with_colors_indices_order_and_render_pass_hint"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+32, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG, agcom.LONG)
        self.__dict__["_set_partial_cartographic"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+33, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_cartographic_with_indices_order"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+34, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG)
        self.__dict__["_set_partial_cartographic_with_colors"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+35, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_cartographic_with_colors_indices_order_and_render_pass"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+36, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG, agcom.LONG)
        self.__dict__["_get_central_body_clipped"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+37, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_central_body_clipped"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+38, agcom.VARIANT_BOOL)
        self.__dict__["_set_with_colors_and_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+39, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.PVOID)
        self.__dict__["_set_cartographic_with_colors_and_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+40, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.PVOID)
        self.__dict__["_set_partial_with_colors_and_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+41, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.PVOID, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_cartographic_with_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitive, vtable_offset_local+42, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.PVOID, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPolylinePrimitive.__dict__ and type(IPolylinePrimitive.__dict__[attrname]) == property:
            return IPolylinePrimitive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPolylinePrimitive.")
    
    @property
    def width(self) -> float:
        """Gets or sets the line width, in pixels."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @width.setter
    def width(self, width:float) -> None:
        with agmarshall.FLOAT_arg(width) as arg_width:
            agcls.evaluate_hresult(self.__dict__["_set_width"](arg_width.COM_val))

    @property
    def minimum_width_supported(self) -> float:
        """Gets the minimum width, in pixels, supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_width_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def maximum_width_supported(self) -> float:
        """Gets the maximum width, in pixels, supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_width_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def position_interpolator(self) -> "IPositionInterpolator":
        """Gets the position interpolator applied to positions passed to Set, SetCartographic, SetSubset, and SetSubsetCartographic methods. When this property is null, linear interpolation is used."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position_interpolator"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def polyline_type(self) -> "AgEStkGraphicsPolylineType":
        """Gets how the polyline interprets the positions passed to Set methods."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsPolylineType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_polyline_type"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def set_hint(self) -> "AgEStkGraphicsSetHint":
        """Gets the primitive's set hint. See the Set Hint Performance Overview for selecting an appropriate value to construct the primitive with."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSetHint) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_set_hint"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def display_outline(self) -> bool:
        """Gets or sets whether an outline is rendered around the polyline."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_outline"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_outline.setter
    def display_outline(self, displayOutline:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displayOutline) as arg_displayOutline:
            agcls.evaluate_hresult(self.__dict__["_set_display_outline"](arg_displayOutline.COM_val))

    @property
    def outline_color(self) -> agcolor.Color:
        """Gets or sets the outline's color."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_color.setter
    def outline_color(self, outlineColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(outlineColor) as arg_outlineColor:
            agcls.evaluate_hresult(self.__dict__["_set_outline_color"](arg_outlineColor.COM_val))

    @property
    def outline_translucency(self) -> float:
        """Gets or sets the translucency of the outline. Translucency is between 0 and 1, where 0 is opaque and 1 is transparent."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_translucency.setter
    def outline_translucency(self, outlineTranslucency:float) -> None:
        with agmarshall.FLOAT_arg(outlineTranslucency) as arg_outlineTranslucency:
            agcls.evaluate_hresult(self.__dict__["_set_outline_translucency"](arg_outlineTranslucency.COM_val))

    @property
    def outline_width(self) -> float:
        """Gets or sets the width, in pixels, of the outline around the polyline."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_width.setter
    def outline_width(self, outlineWidth:float) -> None:
        with agmarshall.FLOAT_arg(outlineWidth) as arg_outlineWidth:
            agcls.evaluate_hresult(self.__dict__["_set_outline_width"](arg_outlineWidth.COM_val))

    @property
    def per_item_picking_enabled(self) -> bool:
        """Gets or sets whether individual line indices will be included in the pick results returned from the scene's Pick method. Each line index that is picked will be returned as a batch primitive index."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_per_item_picking_enabled"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @per_item_picking_enabled.setter
    def per_item_picking_enabled(self, perItemPickingEnabled:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(perItemPickingEnabled) as arg_perItemPickingEnabled:
            agcls.evaluate_hresult(self.__dict__["_set_per_item_picking_enabled"](arg_perItemPickingEnabled.COM_val))

    def set(self, positions:list) -> None:
        """Defines the positions for a polyline primitive. The polyline is rendered in its reference frame."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions:
            agcls.evaluate_hresult(self.__dict__["_set"](byref(arg_positions.COM_val)))

    def set_with_colors(self, positions:list, colors:list) -> None:
        """Defines the positions and colors of a polyline. The polyline is rendered in its reference frame."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors:
            agcls.evaluate_hresult(self.__dict__["_set_with_colors"](byref(arg_positions.COM_val), byref(arg_colors.COM_val)))

    def set_with_colors_and_hint(self, positions:list, colors:list, renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """Defines the positions and colors of a polyline. The polyline is rendered in its reference frame. renderPassHint is provided for efficiency."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_with_colors_and_hint"](byref(arg_positions.COM_val), byref(arg_colors.COM_val), arg_renderPassHint.COM_val))

    def set_with_surface_shapes_result(self, surfaceShapesResult:"ISurfaceShapesResult") -> None:
        """Defines the positions of a polyline using the positions of the specified surfaceShapesResult."""
        with agmarshall.AgInterface_in_arg(surfaceShapesResult, ISurfaceShapesResult) as arg_surfaceShapesResult:
            agcls.evaluate_hresult(self.__dict__["_set_with_surface_shapes_result"](arg_surfaceShapesResult.COM_val))

    def set_with_surface_triangulator_result(self, surfaceTriangulatorResult:"ISurfaceTriangulatorResult") -> None:
        """Defines the positions of a polyline using the boundary positions of the specified surfaceTriangulatorResult."""
        with agmarshall.AgInterface_in_arg(surfaceTriangulatorResult, ISurfaceTriangulatorResult) as arg_surfaceTriangulatorResult:
            agcls.evaluate_hresult(self.__dict__["_set_with_surface_triangulator_result"](arg_surfaceTriangulatorResult.COM_val))

    def set_with_solid_triangulator_result(self, solidTriangulatorResult:"ISolidTriangulatorResult") -> None:
        """Defines the positions of a polyline using the outline positions of the specified solidTriangulatorResult."""
        with agmarshall.AgInterface_in_arg(solidTriangulatorResult, ISolidTriangulatorResult) as arg_solidTriangulatorResult:
            agcls.evaluate_hresult(self.__dict__["_set_with_solid_triangulator_result"](arg_solidTriangulatorResult.COM_val))

    def set_cartographic(self, centralBody:str, positions:list) -> None:
        """For convenience. Defines the positions of a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions:
            agcls.evaluate_hresult(self.__dict__["_set_cartographic"](arg_centralBody.COM_val, byref(arg_positions.COM_val)))

    def set_cartographic_with_colors(self, centralBody:str, positions:list, colors:list) -> None:
        """For convenience. Defines the positions and colors of a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors:
            agcls.evaluate_hresult(self.__dict__["_set_cartographic_with_colors"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_colors.COM_val)))

    def set_cartographic_with_colors_and_hint(self, centralBody:str, positions:list, colors:list, renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """For convenience. Defines the positions and colors of a polyline using cartographic positions. renderPassHint is provided for efficiency. This is equivalent to converting each position in positions to cartesian and calling Set."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_cartographic_with_colors_and_hint"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_colors.COM_val), arg_renderPassHint.COM_val))

    def set_subset(self, positions:list, index:int, count:int) -> None:
        """Defines the positions of a polyline using a subset of input positions."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.INT_arg(index) as arg_index, \
             agmarshall.INT_arg(count) as arg_count:
            agcls.evaluate_hresult(self.__dict__["_set_subset"](byref(arg_positions.COM_val), arg_index.COM_val, arg_count.COM_val))

    def set_subset_cartographic(self, centralBody:str, positions:list, index:int, count:int) -> None:
        """For convenience. Defines the positions of a polyline using a subset of input cartographic positions. This is equivalent to converting the subset of positions to cartesian and calling SetSubset."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.INT_arg(index) as arg_index, \
             agmarshall.INT_arg(count) as arg_count:
            agcls.evaluate_hresult(self.__dict__["_set_subset_cartographic"](arg_centralBody.COM_val, byref(arg_positions.COM_val), arg_index.COM_val, arg_count.COM_val))

    def set_partial(self, positions:list, indices:list) -> None:
        """Updates a subset of positions in a polyline."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial"](byref(arg_positions.COM_val), byref(arg_indices.COM_val)))

    def set_partial_with_indices_order(self, positions:list, indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint") -> None:
        """Updates a subset of positions in a polyline."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_with_indices_order"](byref(arg_positions.COM_val), byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val))

    def set_partial_with_colors(self, positions:list, colors:list, indices:list) -> None:
        """Updates a subset of positions and/or colors in a polyline."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial_with_colors"](byref(arg_positions.COM_val), byref(arg_colors.COM_val), byref(arg_indices.COM_val)))

    def set_partial_with_colors_indices_order_and_render_pass_hint(self, positions:list, colors:list, indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint", renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """Updates a subset of positions and/or colors in a polyline."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_with_colors_indices_order_and_render_pass_hint"](byref(arg_positions.COM_val), byref(arg_colors.COM_val), byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val, arg_renderPassHint.COM_val))

    def set_partial_cartographic(self, centralBody:str, positions:list, indices:list) -> None:
        """For convenience. Updates a subset of positions in a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_indices.COM_val)))

    def set_partial_cartographic_with_indices_order(self, centralBody:str, positions:list, indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint") -> None:
        """For convenience. Updates a subset of positions in a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic_with_indices_order"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val))

    def set_partial_cartographic_with_colors(self, centralBody:str, positions:list, colors:list, indices:list) -> None:
        """For convenience. Updates a subset of positions and/or colors in a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic_with_colors"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_colors.COM_val), byref(arg_indices.COM_val)))

    def set_partial_cartographic_with_colors_indices_order_and_render_pass(self, centralBody:str, positions:list, colors:list, indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint", renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """For convenience. Updates a subset of positions and/or colors in a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic_with_colors_indices_order_and_render_pass"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_colors.COM_val), byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val, arg_renderPassHint.COM_val))

    @property
    def central_body_clipped(self) -> bool:
        """Gets or sets whether the polyline will be clipped by the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_clipped"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @central_body_clipped.setter
    def central_body_clipped(self, centralBodyClipped:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(centralBodyClipped) as arg_centralBodyClipped:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_clipped"](arg_centralBodyClipped.COM_val))

    def set_with_colors_and_optional_parameters(self, positions:list, colors:list, optionalParameters:"IPolylinePrimitiveOptionalParameters") -> None:
        """Defines the positions, colors, and/or optional point properties of a polyline. The polyline is rendered in its reference frame."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.AgInterface_in_arg(optionalParameters, IPolylinePrimitiveOptionalParameters) as arg_optionalParameters:
            agcls.evaluate_hresult(self.__dict__["_set_with_colors_and_optional_parameters"](byref(arg_positions.COM_val), byref(arg_colors.COM_val), arg_optionalParameters.COM_val))

    def set_cartographic_with_colors_and_optional_parameters(self, centralBody:str, positions:list, colors:list, optionalParameters:"IPolylinePrimitiveOptionalParameters") -> None:
        """For convenience. Defines the positions, colors, and/or optional point properties of a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.AgInterface_in_arg(optionalParameters, IPolylinePrimitiveOptionalParameters) as arg_optionalParameters:
            agcls.evaluate_hresult(self.__dict__["_set_cartographic_with_colors_and_optional_parameters"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_colors.COM_val), arg_optionalParameters.COM_val))

    def set_partial_with_colors_and_optional_parameters(self, positions:list, colors:list, optionalParameters:"IPolylinePrimitiveOptionalParameters", indices:list) -> None:
        """Updates a subset of positions, colors, and/or optional point properties in a polyline."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.AgInterface_in_arg(optionalParameters, IPolylinePrimitiveOptionalParameters) as arg_optionalParameters, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial_with_colors_and_optional_parameters"](byref(arg_positions.COM_val), byref(arg_colors.COM_val), arg_optionalParameters.COM_val, byref(arg_indices.COM_val)))

    def set_partial_cartographic_with_optional_parameters(self, centralBody:str, positions:list, colors:list, optionalParameters:"IPolylinePrimitiveOptionalParameters", indices:list) -> None:
        """For convenience. Updates a subset of positions, colors, and/or optional point properties in a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(colors) as arg_colors, \
             agmarshall.AgInterface_in_arg(optionalParameters, IPolylinePrimitiveOptionalParameters) as arg_optionalParameters, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic_with_optional_parameters"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_colors.COM_val), arg_optionalParameters.COM_val, byref(arg_indices.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{0122dc2b-4232-443d-b8da-09b42967b841}", IPolylinePrimitive)
agcls.AgTypeNameMap["IPolylinePrimitive"] = IPolylinePrimitive

class IPolylinePrimitiveOptionalParameters(object):
    """Optional per-point or per-segment parameters for polyline primitive that overrides the polyline primitive's global parameters..."""
    _uuid = "{7ccefc1c-372f-43ff-91ca-fca3de401669}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_set_time_intervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPolylinePrimitiveOptionalParameters._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPolylinePrimitiveOptionalParameters from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPolylinePrimitiveOptionalParameters = agcom.GUID(IPolylinePrimitiveOptionalParameters._uuid)
        vtable_offset_local = IPolylinePrimitiveOptionalParameters._vtable_offset - 1
        self.__dict__["_set_time_intervals"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitiveOptionalParameters, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPolylinePrimitiveOptionalParameters.__dict__ and type(IPolylinePrimitiveOptionalParameters.__dict__[attrname]) == property:
            return IPolylinePrimitiveOptionalParameters.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPolylinePrimitiveOptionalParameters.")
    
    def set_time_intervals(self, timeIntervals:list) -> None:
        """Defines a collection of TimeIntervals defined by MinimumTime and MaximumTime in Epoch Seconds, one for each point in the Polyline"""
        with agmarshall.SAFEARRAY_arg(timeIntervals) as arg_timeIntervals:
            agcls.evaluate_hresult(self.__dict__["_set_time_intervals"](byref(arg_timeIntervals.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{7ccefc1c-372f-43ff-91ca-fca3de401669}", IPolylinePrimitiveOptionalParameters)
agcls.AgTypeNameMap["IPolylinePrimitiveOptionalParameters"] = IPolylinePrimitiveOptionalParameters

class IPositionInterpolator(object):
    """Position interpolators compute positions based on a collection of input positions. Position interpolators are used in conjunction with the polyline primitive to render things such as great arcs and rhumb lines."""
    _uuid = "{512c0d62-559e-42ce-98e2-218c02662290}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_polyline_type"] = _raise_uninitialized_error
        self.__dict__["_interpolate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPositionInterpolator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPositionInterpolator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPositionInterpolator = agcom.GUID(IPositionInterpolator._uuid)
        vtable_offset_local = IPositionInterpolator._vtable_offset - 1
        self.__dict__["_get_polyline_type"] = IAGFUNCTYPE(pUnk, IID_IPositionInterpolator, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_interpolate"] = IAGFUNCTYPE(pUnk, IID_IPositionInterpolator, vtable_offset_local+2, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPositionInterpolator.__dict__ and type(IPositionInterpolator.__dict__[attrname]) == property:
            return IPositionInterpolator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPositionInterpolator.")
    
    @property
    def polyline_type(self) -> "AgEStkGraphicsPolylineType":
        """Gets the polyline type of positions returned from interpolate"""
        with agmarshall.AgEnum_arg(AgEStkGraphicsPolylineType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_polyline_type"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def interpolate(self, positions:list) -> list:
        """Computes interpolated positions based on the input positions. Returns an array of positions in the order x, y, z."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_interpolate"](byref(arg_positions.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{512c0d62-559e-42ce-98e2-218c02662290}", IPositionInterpolator)
agcls.AgTypeNameMap["IPositionInterpolator"] = IPositionInterpolator

class IPrimitive(object):
    """Primitives represent objects rendered in the 3D scene."""
    _uuid = "{b593dc7b-315a-4c37-9f3c-42dfbd996ac2}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_set_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_get_bounding_sphere"] = _raise_uninitialized_error
        self.__dict__["_set_bounding_sphere"] = _raise_uninitialized_error
        self.__dict__["_get_automatically_compute_bounding_sphere"] = _raise_uninitialized_error
        self.__dict__["_set_automatically_compute_bounding_sphere"] = _raise_uninitialized_error
        self.__dict__["_get_display_condition"] = _raise_uninitialized_error
        self.__dict__["_set_display_condition"] = _raise_uninitialized_error
        self.__dict__["_get_display"] = _raise_uninitialized_error
        self.__dict__["_set_display"] = _raise_uninitialized_error
        self.__dict__["_get_color"] = _raise_uninitialized_error
        self.__dict__["_set_color"] = _raise_uninitialized_error
        self.__dict__["_get_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_tag"] = _raise_uninitialized_error
        self.__dict__["_set_tag"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPrimitive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPrimitive from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPrimitive = agcom.GUID(IPrimitive._uuid)
        vtable_offset_local = IPrimitive._vtable_offset - 1
        self.__dict__["_get_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_set_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_get_bounding_sphere"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_set_bounding_sphere"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_get_automatically_compute_bounding_sphere"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_automatically_compute_bounding_sphere"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_display_condition"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_set_display_condition"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_get_display"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_color"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+11, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_color"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+12, agcom.OLE_COLOR)
        self.__dict__["_get_translucency"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+13, POINTER(agcom.FLOAT))
        self.__dict__["_set_translucency"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+14, agcom.FLOAT)
        self.__dict__["_get_tag"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+15, POINTER(agcom.VARIANT))
        self.__dict__["_set_tag"] = IAGFUNCTYPE(pUnk, IID_IPrimitive, vtable_offset_local+16, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPrimitive.__dict__ and type(IPrimitive.__dict__[attrname]) == property:
            return IPrimitive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPrimitive.")
    
    @property
    def reference_frame(self) -> "IVectorGeometryToolSystem":
        """Gets or sets the reference frame this primitive is defined and rendered in."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_frame"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @reference_frame.setter
    def reference_frame(self, referenceFrame:"IVectorGeometryToolSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceFrame, IVectorGeometryToolSystem) as arg_referenceFrame:
            agcls.evaluate_hresult(self.__dict__["_set_reference_frame"](arg_referenceFrame.COM_val))

    @property
    def bounding_sphere(self) -> "IBoundingSphere":
        """Gets or sets the bounding sphere that encompasses the primitive. The center is defined in the primitive's reference frame."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_bounding_sphere"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @bounding_sphere.setter
    def bounding_sphere(self, boundingSphere:"IBoundingSphere") -> None:
        with agmarshall.AgInterface_in_arg(boundingSphere, IBoundingSphere) as arg_boundingSphere:
            agcls.evaluate_hresult(self.__dict__["_set_bounding_sphere"](arg_boundingSphere.COM_val))

    @property
    def automatically_compute_bounding_sphere(self) -> bool:
        """Gets or sets if the primitive's bounding sphere is automatically computed."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_automatically_compute_bounding_sphere"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @automatically_compute_bounding_sphere.setter
    def automatically_compute_bounding_sphere(self, automaticallyComputeBoundingSphere:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(automaticallyComputeBoundingSphere) as arg_automaticallyComputeBoundingSphere:
            agcls.evaluate_hresult(self.__dict__["_set_automatically_compute_bounding_sphere"](arg_automaticallyComputeBoundingSphere.COM_val))

    @property
    def display_condition(self) -> "IDisplayCondition":
        """Gets or sets the display condition that determines if the primitive should be rendered. Both this and display must evaluate to true for the primitive to be rendered."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_condition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @display_condition.setter
    def display_condition(self, displayCondition:"IDisplayCondition") -> None:
        with agmarshall.AgInterface_in_arg(displayCondition, IDisplayCondition) as arg_displayCondition:
            agcls.evaluate_hresult(self.__dict__["_set_display_condition"](arg_displayCondition.COM_val))

    @property
    def display(self) -> bool:
        """Gets or sets if the primitive should be rendered. Both this and display condition must evaluate to true for the primitive to be rendered."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display.setter
    def display(self, display:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(display) as arg_display:
            agcls.evaluate_hresult(self.__dict__["_set_display"](arg_display.COM_val))

    @property
    def color(self) -> agcolor.Color:
        """Gets or sets the primitive's color."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @color.setter
    def color(self, color:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(color) as arg_color:
            agcls.evaluate_hresult(self.__dict__["_set_color"](arg_color.COM_val))

    @property
    def translucency(self) -> float:
        """Gets or sets the primitive's translucency. Translucency is between 0 and 1, where 0 is opaque and 1 is transparent."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @translucency.setter
    def translucency(self, translucency:float) -> None:
        with agmarshall.FLOAT_arg(translucency) as arg_translucency:
            agcls.evaluate_hresult(self.__dict__["_set_translucency"](arg_translucency.COM_val))

    @property
    def tag(self) -> typing.Any:
        """Gets or sets custom value associated with this primitive."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_tag"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @tag.setter
    def tag(self, tag:typing.Any) -> None:
        with agmarshall.VARIANT_arg(tag) as arg_tag:
            agcls.evaluate_hresult(self.__dict__["_set_tag"](arg_tag.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{b593dc7b-315a-4c37-9f3c-42dfbd996ac2}", IPrimitive)
agcls.AgTypeNameMap["IPrimitive"] = IPrimitive

class IPrimitiveManager(object):
    """The primitive manager contains spatial data structures used to efficiently render primitives. Once a primitive is constructed, it must be added to the primitive manager before it will be rendered."""
    _uuid = "{39006599-c2ac-4f46-a190-958d173714fc}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_precision_exponent"] = _raise_uninitialized_error
        self.__dict__["_set_precision_exponent"] = _raise_uninitialized_error
        self.__dict__["_get_translucent_primitives_sort_order"] = _raise_uninitialized_error
        self.__dict__["_set_translucent_primitives_sort_order"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_contains"] = _raise_uninitialized_error
        self.__dict__["_clear"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPrimitiveManager._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPrimitiveManager from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPrimitiveManager = agcom.GUID(IPrimitiveManager._uuid)
        vtable_offset_local = IPrimitiveManager._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IPrimitiveManager, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_get_precision_exponent"] = IAGFUNCTYPE(pUnk, IID_IPrimitiveManager, vtable_offset_local+2, POINTER(agcom.INT))
        self.__dict__["_set_precision_exponent"] = IAGFUNCTYPE(pUnk, IID_IPrimitiveManager, vtable_offset_local+3, agcom.INT)
        self.__dict__["_get_translucent_primitives_sort_order"] = IAGFUNCTYPE(pUnk, IID_IPrimitiveManager, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_set_translucent_primitives_sort_order"] = IAGFUNCTYPE(pUnk, IID_IPrimitiveManager, vtable_offset_local+5, agcom.LONG)
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IPrimitiveManager, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IPrimitiveManager, vtable_offset_local+7, agcom.PVOID)
        self.__dict__["_contains"] = IAGFUNCTYPE(pUnk, IID_IPrimitiveManager, vtable_offset_local+8, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_clear"] = IAGFUNCTYPE(pUnk, IID_IPrimitiveManager, vtable_offset_local+9, )
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IPrimitiveManager, vtable_offset_local+10, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPrimitiveManager.__dict__ and type(IPrimitiveManager.__dict__[attrname]) == property:
            return IPrimitiveManager.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPrimitiveManager.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> typing.Any:
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """Gets the number of primitives in the manager."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def precision_exponent(self) -> int:
        """This property is deprecated. This property is no longer in use Gets or sets the exponent used to compute the maximum precision for primitive rendering. For example, a value of -3 indicates the maximum precision of 2^-3, 0.125 m along the x, y, or z axis..."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_precision_exponent"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @precision_exponent.setter
    def precision_exponent(self, precisionExponent:int) -> None:
        with agmarshall.INT_arg(precisionExponent) as arg_precisionExponent:
            agcls.evaluate_hresult(self.__dict__["_set_precision_exponent"](arg_precisionExponent.COM_val))

    @property
    def translucent_primitives_sort_order(self) -> "AgEStkGraphicsPrimitivesSortOrder":
        """Gets or sets the sort order for translucent primitives in the primitive manager. This determines a trade-off between rendering speed and quality..."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsPrimitivesSortOrder) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_translucent_primitives_sort_order"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @translucent_primitives_sort_order.setter
    def translucent_primitives_sort_order(self, translucentPrimitivesSortOrder:"AgEStkGraphicsPrimitivesSortOrder") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsPrimitivesSortOrder, translucentPrimitivesSortOrder) as arg_translucentPrimitivesSortOrder:
            agcls.evaluate_hresult(self.__dict__["_set_translucent_primitives_sort_order"](arg_translucentPrimitivesSortOrder.COM_val))

    def add(self, primitive:"IPrimitive") -> None:
        """Adds a primitive to the manager. Primitives must be added to the manager to be rendered."""
        with agmarshall.AgInterface_in_arg(primitive, IPrimitive) as arg_primitive:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_primitive.COM_val))

    def remove(self, primitive:"IPrimitive") -> None:
        """Removes a primitive from the manager. The primitive is no longer rendered unless it is added back into the manager."""
        with agmarshall.AgInterface_in_arg(primitive, IPrimitive) as arg_primitive:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_primitive.COM_val))

    def contains(self, primitive:"IPrimitive") -> bool:
        """Determines whether the manager contains a primitive."""
        with agmarshall.AgInterface_in_arg(primitive, IPrimitive) as arg_primitive, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_contains"](arg_primitive.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def clear(self) -> None:
        """Removes all primitives from the manager."""
        agcls.evaluate_hresult(self.__dict__["_clear"]())

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns an enumerator that iterates through the collection. The order of the primitives is not guaranteed to be the order that the primitives were added."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{39006599-c2ac-4f46-a190-958d173714fc}", IPrimitiveManager)
agcls.AgTypeNameMap["IPrimitiveManager"] = IPrimitiveManager

class IRasterImageGlobeOverlay(object):
    """A globe image overlay for handling rasters."""
    _uuid = "{de016591-933e-4085-b6a4-401e117109e9}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_transparent_color"] = _raise_uninitialized_error
        self.__dict__["_set_use_transparent_color"] = _raise_uninitialized_error
        self.__dict__["_get_transparent_color"] = _raise_uninitialized_error
        self.__dict__["_set_transparent_color"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRasterImageGlobeOverlay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRasterImageGlobeOverlay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRasterImageGlobeOverlay = agcom.GUID(IRasterImageGlobeOverlay._uuid)
        vtable_offset_local = IRasterImageGlobeOverlay._vtable_offset - 1
        self.__dict__["_get_use_transparent_color"] = IAGFUNCTYPE(pUnk, IID_IRasterImageGlobeOverlay, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_transparent_color"] = IAGFUNCTYPE(pUnk, IID_IRasterImageGlobeOverlay, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_transparent_color"] = IAGFUNCTYPE(pUnk, IID_IRasterImageGlobeOverlay, vtable_offset_local+3, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_transparent_color"] = IAGFUNCTYPE(pUnk, IID_IRasterImageGlobeOverlay, vtable_offset_local+4, agcom.OLE_COLOR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRasterImageGlobeOverlay.__dict__ and type(IRasterImageGlobeOverlay.__dict__[attrname]) == property:
            return IRasterImageGlobeOverlay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRasterImageGlobeOverlay.")
    
    @property
    def use_transparent_color(self) -> bool:
        """Gets or sets whether transparent color should be used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_transparent_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @use_transparent_color.setter
    def use_transparent_color(self, useTransparentColor:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useTransparentColor) as arg_useTransparentColor:
            agcls.evaluate_hresult(self.__dict__["_set_use_transparent_color"](arg_useTransparentColor.COM_val))

    @property
    def transparent_color(self) -> agcolor.Color:
        """Gets or sets the color that will become transparent."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_transparent_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @transparent_color.setter
    def transparent_color(self, transparentColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(transparentColor) as arg_transparentColor:
            agcls.evaluate_hresult(self.__dict__["_set_transparent_color"](arg_transparentColor.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{de016591-933e-4085-b6a4-401e117109e9}", IRasterImageGlobeOverlay)
agcls.AgTypeNameMap["IRasterImageGlobeOverlay"] = IRasterImageGlobeOverlay

class IRhumbLineInterpolator(object):
    """The rhumb line interpolator computes interpolated positions along a rhumb line. Rhumb lines are lines of constant bearing. They appear as straight lines on a Mercator 2D map projection and are well suited to navigation."""
    _uuid = "{ccdec605-222e-4dea-a897-2632b43af87f}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body"] = _raise_uninitialized_error
        self.__dict__["_set_central_body"] = _raise_uninitialized_error
        self.__dict__["_get_granularity"] = _raise_uninitialized_error
        self.__dict__["_set_granularity"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRhumbLineInterpolator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRhumbLineInterpolator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRhumbLineInterpolator = agcom.GUID(IRhumbLineInterpolator._uuid)
        vtable_offset_local = IRhumbLineInterpolator._vtable_offset - 1
        self.__dict__["_get_central_body"] = IAGFUNCTYPE(pUnk, IID_IRhumbLineInterpolator, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body"] = IAGFUNCTYPE(pUnk, IID_IRhumbLineInterpolator, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_granularity"] = IAGFUNCTYPE(pUnk, IID_IRhumbLineInterpolator, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_granularity"] = IAGFUNCTYPE(pUnk, IID_IRhumbLineInterpolator, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRhumbLineInterpolator.__dict__ and type(IRhumbLineInterpolator.__dict__[attrname]) == property:
            return IRhumbLineInterpolator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRhumbLineInterpolator.")
    
    @property
    def central_body(self) -> str:
        """Gets or sets the central body used when interpolating with interpolate."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_set_central_body"](arg_centralBody.COM_val))

    @property
    def granularity(self) -> float:
        """Gets or sets the granularity used when interpolating with interpolate. Lower granularities are more precise but create more positions."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_granularity"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @granularity.setter
    def granularity(self, granularity:float) -> None:
        with agmarshall.DOUBLE_arg(granularity) as arg_granularity:
            agcls.evaluate_hresult(self.__dict__["_set_granularity"](arg_granularity.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ccdec605-222e-4dea-a897-2632b43af87f}", IRhumbLineInterpolator)
agcls.AgTypeNameMap["IRhumbLineInterpolator"] = IRhumbLineInterpolator

class IScene(object):
    """A scene provides properties and functionality that are reflected in the rendering of the globe control that it is associated with. An globe control's scene is available from the scene property..."""
    _uuid = "{2d15c682-efb5-499f-8851-a49599b2097d}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_camera"] = _raise_uninitialized_error
        self.__dict__["_get_lighting"] = _raise_uninitialized_error
        self.__dict__["_get_show_sunshine"] = _raise_uninitialized_error
        self.__dict__["_set_show_sunshine"] = _raise_uninitialized_error
        self.__dict__["_get_central_bodies"] = _raise_uninitialized_error
        self.__dict__["_get_background_color"] = _raise_uninitialized_error
        self.__dict__["_set_background_color"] = _raise_uninitialized_error
        self.__dict__["_get_shade_sky_based_on_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_shade_sky_based_on_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_show_stars"] = _raise_uninitialized_error
        self.__dict__["_set_show_stars"] = _raise_uninitialized_error
        self.__dict__["_get_globe_overlay_settings"] = _raise_uninitialized_error
        self.__dict__["_render"] = _raise_uninitialized_error
        self.__dict__["_pick"] = _raise_uninitialized_error
        self.__dict__["_pick_rectangular"] = _raise_uninitialized_error
        self.__dict__["_pick_screen_overlays"] = _raise_uninitialized_error
        self.__dict__["_get_scene_id"] = _raise_uninitialized_error
        self.__dict__["_get_show_water_surface"] = _raise_uninitialized_error
        self.__dict__["_set_show_water_surface"] = _raise_uninitialized_error
        self.__dict__["_get_anti_aliasing"] = _raise_uninitialized_error
        self.__dict__["_set_anti_aliasing"] = _raise_uninitialized_error
        self.__dict__["_get_visual_effects"] = _raise_uninitialized_error
        self.__dict__["_get_clouds"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScene._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScene from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScene = agcom.GUID(IScene._uuid)
        vtable_offset_local = IScene._vtable_offset - 1
        self.__dict__["_get_camera"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_lighting"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_show_sunshine"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show_sunshine"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_central_bodies"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_background_color"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+6, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_background_color"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+7, agcom.OLE_COLOR)
        self.__dict__["_get_shade_sky_based_on_altitude"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_shade_sky_based_on_altitude"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_show_stars"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show_stars"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_globe_overlay_settings"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+12, POINTER(agcom.PVOID))
        self.__dict__["_render"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+13, )
        self.__dict__["_pick"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+14, agcom.INT, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_pick_rectangular"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+15, agcom.INT, agcom.INT, agcom.INT, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_pick_screen_overlays"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+16, agcom.INT, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_scene_id"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+17, POINTER(agcom.INT))
        self.__dict__["_get_show_water_surface"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show_water_surface"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+19, agcom.VARIANT_BOOL)
        self.__dict__["_get_anti_aliasing"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+20, POINTER(agcom.LONG))
        self.__dict__["_set_anti_aliasing"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+21, agcom.LONG)
        self.__dict__["_get_visual_effects"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+22, POINTER(agcom.PVOID))
        self.__dict__["_get_clouds"] = IAGFUNCTYPE(pUnk, IID_IScene, vtable_offset_local+23, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScene.__dict__ and type(IScene.__dict__[attrname]) == property:
            return IScene.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScene.")
    def Subscribe(self) -> ISceneEventHandler:
        """Returns an ISceneEventHandler that is subscribed to handle events associated with this instance of IScene."""
        return ISceneEventHandler(self._pUnk)    
    @property
    def camera(self) -> "ICamera":
        """Gets the camera associated with the scene, which affects the view that is rendered by the scene."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_camera"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def lighting(self) -> "ILighting":
        """Gets the lighting associated with the scene."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_lighting"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def show_sunshine(self) -> bool:
        """Gets or sets whether sunshine is rendered by the Sun central body. Sunshine renders a halo effect around the sun when it is viewed in the scene."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_show_sunshine"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @show_sunshine.setter
    def show_sunshine(self, showSunshine:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(showSunshine) as arg_showSunshine:
            agcls.evaluate_hresult(self.__dict__["_set_show_sunshine"](arg_showSunshine.COM_val))

    @property
    def central_bodies(self) -> "ICentralBodyGraphicsIndexer":
        """Gets the central body graphics for a specified central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_bodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def background_color(self) -> agcolor.Color:
        """Gets or sets the background color of the scene."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_background_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @background_color.setter
    def background_color(self, backgroundColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(backgroundColor) as arg_backgroundColor:
            agcls.evaluate_hresult(self.__dict__["_set_background_color"](arg_backgroundColor.COM_val))

    @property
    def shade_sky_based_on_altitude(self) -> bool:
        """Gets or sets whether the sky will be shaded based on camera altitude. When shade sky based on altitude is set to true, the sky will become more blue as the Camera gets closer to the surface of the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_shade_sky_based_on_altitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @shade_sky_based_on_altitude.setter
    def shade_sky_based_on_altitude(self, shadeSkyBasedOnAltitude:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(shadeSkyBasedOnAltitude) as arg_shadeSkyBasedOnAltitude:
            agcls.evaluate_hresult(self.__dict__["_set_shade_sky_based_on_altitude"](arg_shadeSkyBasedOnAltitude.COM_val))

    @property
    def show_stars(self) -> bool:
        """Gets or sets whether stars are shown or hidden in the scene."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_show_stars"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @show_stars.setter
    def show_stars(self, showStars:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(showStars) as arg_showStars:
            agcls.evaluate_hresult(self.__dict__["_set_show_stars"](arg_showStars.COM_val))

    @property
    def globe_overlay_settings(self) -> "ISceneGlobeOverlaySettings":
        """Gets the scene globe overlay settings for the scene."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_globe_overlay_settings"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def render(self) -> None:
        """Renders the scene. To render all the scenes within an application, use the Render method."""
        agcls.evaluate_hresult(self.__dict__["_render"]())

    def pick(self, x:int, y:int) -> "IPickResultCollection":
        """Executes a pick at the given x, y and returns a depth sorted collection of picked objects. The coordinate origin is top, left. To pick screen overlays, use the PickScreenOverlays method."""
        with agmarshall.INT_arg(x) as arg_x, \
             agmarshall.INT_arg(y) as arg_y, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_pick"](arg_x.COM_val, arg_y.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def pick_rectangular(self, left:int, bottom:int, right:int, top:int) -> "IPickResultCollection":
        """Executes a pick in the given rectangular region and returns a depth sorted collection of picked objects. The coordinate origin is top, left. To pick screen overlays, use the PickScreenOverlays method."""
        with agmarshall.INT_arg(left) as arg_left, \
             agmarshall.INT_arg(bottom) as arg_bottom, \
             agmarshall.INT_arg(right) as arg_right, \
             agmarshall.INT_arg(top) as arg_top, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_pick_rectangular"](arg_left.COM_val, arg_bottom.COM_val, arg_right.COM_val, arg_top.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def pick_screen_overlays(self, x:int, y:int) -> "IScreenOverlayPickResultCollection":
        """Executes a pick on screen overlays at the given x, y and returns a front to back sorted collection of picked overlays. The coordinate origin is top, left. To pick other objects in the scene, use the Pick method."""
        with agmarshall.INT_arg(x) as arg_x, \
             agmarshall.INT_arg(y) as arg_y, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_pick_screen_overlays"](arg_x.COM_val, arg_y.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def scene_id(self) -> int:
        """Returns the scene identifier."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scene_id"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def show_water_surface(self) -> bool:
        """Gets or sets whether water surface on earth is shown or hidden in the scene."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_show_water_surface"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @show_water_surface.setter
    def show_water_surface(self, showWaterSurface:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(showWaterSurface) as arg_showWaterSurface:
            agcls.evaluate_hresult(self.__dict__["_set_show_water_surface"](arg_showWaterSurface.COM_val))

    @property
    def anti_aliasing(self) -> "AgEStkGraphicsAntiAliasing":
        """Gets or sets the multisample anti-aliasing (MSAA) option for this scene. As the level of anti-aliasing increases, performance will generally decrease, but the quality of the anti-aliasing will improve."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsAntiAliasing) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_anti_aliasing"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @anti_aliasing.setter
    def anti_aliasing(self, antiAliasing:"AgEStkGraphicsAntiAliasing") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsAntiAliasing, antiAliasing) as arg_antiAliasing:
            agcls.evaluate_hresult(self.__dict__["_set_anti_aliasing"](arg_antiAliasing.COM_val))

    @property
    def visual_effects(self) -> "IVisualEffects":
        """Gets the visual  effects associated with the scene."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_visual_effects"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def clouds(self) -> "IClouds":
        """Gets the clouds for the scene."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_clouds"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2d15c682-efb5-499f-8851-a49599b2097d}", IScene)
agcls.AgTypeNameMap["IScene"] = IScene

class ISceneDisplayCondition(object):
    """A display condition used to control what scene or scenes an object, such as a primitive, is rendered in. This is used to show an object in some scenes and hide it in others."""
    _uuid = "{84cbf48f-1672-460e-86fd-9afda647bcca}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_set_display_in_scene"] = _raise_uninitialized_error
        self.__dict__["_get_display_in_scene"] = _raise_uninitialized_error
        self.__dict__["_display_only_in_scene"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISceneDisplayCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISceneDisplayCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISceneDisplayCondition = agcom.GUID(ISceneDisplayCondition._uuid)
        vtable_offset_local = ISceneDisplayCondition._vtable_offset - 1
        self.__dict__["_set_display_in_scene"] = IAGFUNCTYPE(pUnk, IID_ISceneDisplayCondition, vtable_offset_local+1, agcom.PVOID, agcom.VARIANT_BOOL)
        self.__dict__["_get_display_in_scene"] = IAGFUNCTYPE(pUnk, IID_ISceneDisplayCondition, vtable_offset_local+2, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_display_only_in_scene"] = IAGFUNCTYPE(pUnk, IID_ISceneDisplayCondition, vtable_offset_local+3, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISceneDisplayCondition.__dict__ and type(ISceneDisplayCondition.__dict__[attrname]) == property:
            return ISceneDisplayCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISceneDisplayCondition.")
    
    def set_display_in_scene(self, scene:"IScene", on:bool) -> None:
        """Allows or disallows rendering for in a particular scene for."""
        with agmarshall.AgInterface_in_arg(scene, IScene) as arg_scene, \
             agmarshall.VARIANT_BOOL_arg(on) as arg_on:
            agcls.evaluate_hresult(self.__dict__["_set_display_in_scene"](arg_scene.COM_val, arg_on.COM_val))

    def get_display_in_scene(self, scene:"IScene") -> bool:
        """Determines whether the display condition allows rendering rendering in the given scene."""
        with agmarshall.AgInterface_in_arg(scene, IScene) as arg_scene, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_in_scene"](arg_scene.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def display_only_in_scene(self, scene:"IScene") -> None:
        """Allows rendering only in the given scene. The display condition will not allow rendering in other scenes, including newly created ones."""
        with agmarshall.AgInterface_in_arg(scene, IScene) as arg_scene:
            agcls.evaluate_hresult(self.__dict__["_display_only_in_scene"](arg_scene.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{84cbf48f-1672-460e-86fd-9afda647bcca}", ISceneDisplayCondition)
agcls.AgTypeNameMap["ISceneDisplayCondition"] = ISceneDisplayCondition

class ISceneManager(object):
    """The static scene manager class provides global properties and functionality that apply to all scenes and thus affect the rendering of every globe control..."""
    _uuid = "{257b97ef-839b-4a17-a924-c40320174d13}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_primitives"] = _raise_uninitialized_error
        self.__dict__["_get_screen_overlays"] = _raise_uninitialized_error
        self.__dict__["_get_textures"] = _raise_uninitialized_error
        self.__dict__["_get_globe_overlay_settings"] = _raise_uninitialized_error
        self.__dict__["_get_scenes"] = _raise_uninitialized_error
        self.__dict__["_render"] = _raise_uninitialized_error
        self.__dict__["_get_initializers"] = _raise_uninitialized_error
        self.__dict__["_get_frame_rate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISceneManager._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISceneManager from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISceneManager = agcom.GUID(ISceneManager._uuid)
        vtable_offset_local = ISceneManager._vtable_offset - 1
        self.__dict__["_get_primitives"] = IAGFUNCTYPE(pUnk, IID_ISceneManager, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_screen_overlays"] = IAGFUNCTYPE(pUnk, IID_ISceneManager, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_textures"] = IAGFUNCTYPE(pUnk, IID_ISceneManager, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_globe_overlay_settings"] = IAGFUNCTYPE(pUnk, IID_ISceneManager, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_scenes"] = IAGFUNCTYPE(pUnk, IID_ISceneManager, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_render"] = IAGFUNCTYPE(pUnk, IID_ISceneManager, vtable_offset_local+6, )
        self.__dict__["_get_initializers"] = IAGFUNCTYPE(pUnk, IID_ISceneManager, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_frame_rate"] = IAGFUNCTYPE(pUnk, IID_ISceneManager, vtable_offset_local+8, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISceneManager.__dict__ and type(ISceneManager.__dict__[attrname]) == property:
            return ISceneManager.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISceneManager.")
    
    @property
    def primitives(self) -> "IPrimitiveManager":
        """Gets the primitive manager, which is used to add primitives to your scenes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_primitives"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def screen_overlays(self) -> "IScreenOverlayManager":
        """Gets the screen overlay manager, which is used to add screen overlays to your scenes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_screen_overlays"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def textures(self) -> "ITexture2DFactory":
        """Gets the texture 2d factory, which can be used to create textures from various sources."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_textures"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def globe_overlay_settings(self) -> "IGlobeOverlaySettings":
        """Gets the globe overlay settings, which are used to set global settings for all globe overlays."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_globe_overlay_settings"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def scenes(self) -> "ISceneCollection":
        """Gets a read-only collection of scenes that are associated with the scene manager."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scenes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def render(self) -> None:
        """Renders all scenes within an application. To render a specific scene, use the Render method."""
        agcls.evaluate_hresult(self.__dict__["_render"]())

    @property
    def initializers(self) -> "IFactoryAndInitializers":
        """Allows the user to create or initialize primitives, display conditions, tringulators and other types of objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_initializers"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def frame_rate(self) -> "IFrameRate":
        """Gets the frame rate class, which can be used to keep track of how fast scenes are being <see ref='Render'>rendered</see>."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_frame_rate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{257b97ef-839b-4a17-a924-c40320174d13}", ISceneManager)
agcls.AgTypeNameMap["ISceneManager"] = ISceneManager

class IScreenOverlay(object):
    """A visible element drawn in screen space. Overlays are useful for floating logos, heads up displays, and integrating user interfaces into the 3D window."""
    _uuid = "{e9bdc8ad-dc02-4b22-9513-eb0cdfa85cf3}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScreenOverlay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScreenOverlay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScreenOverlay = agcom.GUID(IScreenOverlay._uuid)
        vtable_offset_local = IScreenOverlay._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScreenOverlay.__dict__ and type(IScreenOverlay.__dict__[attrname]) == property:
            return IScreenOverlay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScreenOverlay.")
    

agcls.AgClassCatalog.add_catalog_entry("{e9bdc8ad-dc02-4b22-9513-eb0cdfa85cf3}", IScreenOverlay)
agcls.AgTypeNameMap["IScreenOverlay"] = IScreenOverlay

class IScreenOverlayCollection(object):
    """A collection of screen overlays."""
    _uuid = "{1bf5a224-26b7-4907-aa7d-fd6fc81a51f3}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScreenOverlayCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScreenOverlayCollection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScreenOverlayCollection = agcom.GUID(IScreenOverlayCollection._uuid)
        vtable_offset_local = IScreenOverlayCollection._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScreenOverlayCollection.__dict__ and type(IScreenOverlayCollection.__dict__[attrname]) == property:
            return IScreenOverlayCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScreenOverlayCollection.")
    

agcls.AgClassCatalog.add_catalog_entry("{1bf5a224-26b7-4907-aa7d-fd6fc81a51f3}", IScreenOverlayCollection)
agcls.AgTypeNameMap["IScreenOverlayCollection"] = IScreenOverlayCollection

class IScreenOverlayManager(object):
    """The top-level container for screen overlays. All child screen overlays that are added to this container are specified relative to the overall globe control."""
    _uuid = "{25bf4e85-98ce-48e3-9c15-f517115bc794}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_bounds"] = _raise_uninitialized_error
        self.__dict__["_get_overlays"] = _raise_uninitialized_error
        self.__dict__["_get_padding"] = _raise_uninitialized_error
        self.__dict__["_set_padding"] = _raise_uninitialized_error
        self.__dict__["_get_display"] = _raise_uninitialized_error
        self.__dict__["_set_display"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScreenOverlayManager._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScreenOverlayManager from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScreenOverlayManager = agcom.GUID(IScreenOverlayManager._uuid)
        vtable_offset_local = IScreenOverlayManager._vtable_offset - 1
        self.__dict__["_get_bounds"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayManager, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_overlays"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayManager, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_padding"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayManager, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_padding"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayManager, vtable_offset_local+4, agcom.SAFEARRAY)
        self.__dict__["_get_display"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayManager, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayManager, vtable_offset_local+6, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScreenOverlayManager.__dict__ and type(IScreenOverlayManager.__dict__[attrname]) == property:
            return IScreenOverlayManager.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScreenOverlayManager.")
    
    @property
    def bounds(self) -> list:
        """Gets the overall bounds of the globe control. The array contains the properties defining the bounds in the order left x location, top y location, width, height."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_bounds"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def overlays(self) -> "IScreenOverlayCollection":
        """Gets the collection of overlays that are contained within this manager."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_overlays"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def padding(self) -> list:
        """Gets or sets the padding surrounding the overlays that are contained within this manager. The array contains the components of the padding arranged in the order left, top, right, bottom."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_padding"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @padding.setter
    def padding(self, padding:list) -> None:
        with agmarshall.SAFEARRAY_arg(padding) as arg_padding:
            agcls.evaluate_hresult(self.__dict__["_set_padding"](arg_padding.COM_val))

    @property
    def display(self) -> bool:
        """Gets or sets if the collection of overlays that are contained within this manager should be rendered."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display.setter
    def display(self, display:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(display) as arg_display:
            agcls.evaluate_hresult(self.__dict__["_set_display"](arg_display.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{25bf4e85-98ce-48e3-9c15-f517115bc794}", IScreenOverlayManager)
agcls.AgTypeNameMap["IScreenOverlayManager"] = IScreenOverlayManager

class IScreenOverlayPickResult(object):
    """Describes a picked screen overlay as a result of a call to pick screen overlays."""
    _uuid = "{4872a8d1-b96f-4713-96f8-5ed5e5d6b8b4}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_position"] = _raise_uninitialized_error
        self.__dict__["_get_control_position"] = _raise_uninitialized_error
        self.__dict__["_get_overlay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScreenOverlayPickResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScreenOverlayPickResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScreenOverlayPickResult = agcom.GUID(IScreenOverlayPickResult._uuid)
        vtable_offset_local = IScreenOverlayPickResult._vtable_offset - 1
        self.__dict__["_get_position"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayPickResult, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_control_position"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayPickResult, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_overlay"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayPickResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScreenOverlayPickResult.__dict__ and type(IScreenOverlayPickResult.__dict__[attrname]) == property:
            return IScreenOverlayPickResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScreenOverlayPickResult.")
    
    @property
    def position(self) -> list:
        """Gets the position that was picked within the picked overlay. The array represents the picked position and has a size of 4. The elements are in the order x position, y position, x screen overlay unit, y screen overlay unit."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def control_position(self) -> list:
        """Gets the position that was picked within the overall globe control. This is essentially the same position that was passed to pick screen overlays. The array represents the picked position and has a size of 4..."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_position"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def overlay(self) -> "IScreenOverlay":
        """Gets the screen overlay that was picked."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_overlay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4872a8d1-b96f-4713-96f8-5ed5e5d6b8b4}", IScreenOverlayPickResult)
agcls.AgTypeNameMap["IScreenOverlayPickResult"] = IScreenOverlayPickResult

class ISolidPrimitive(object):
    """Renders filled solid objects and their outlines. Example solids include boxes and ellipsoids. Various effects are supported, such as displaying the solid's silhouette, and hiding the outline of the backside of the solid..."""
    _uuid = "{10ae68b3-ec89-4ced-9b4c-8aae9123eb24}"
    _num_methods = 39
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_affected_by_lighting"] = _raise_uninitialized_error
        self.__dict__["_set_affected_by_lighting"] = _raise_uninitialized_error
        self.__dict__["_get_display_fill"] = _raise_uninitialized_error
        self.__dict__["_set_display_fill"] = _raise_uninitialized_error
        self.__dict__["_get_display_silhouette"] = _raise_uninitialized_error
        self.__dict__["_set_display_silhouette"] = _raise_uninitialized_error
        self.__dict__["_get_silhouette_color"] = _raise_uninitialized_error
        self.__dict__["_set_silhouette_color"] = _raise_uninitialized_error
        self.__dict__["_get_silhouette_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_silhouette_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_silhouette_width"] = _raise_uninitialized_error
        self.__dict__["_set_silhouette_width"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_silhouette_width_supported"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_silhouette_width_supported"] = _raise_uninitialized_error
        self.__dict__["_get_display_outline"] = _raise_uninitialized_error
        self.__dict__["_set_display_outline"] = _raise_uninitialized_error
        self.__dict__["_get_outline_color"] = _raise_uninitialized_error
        self.__dict__["_set_outline_color"] = _raise_uninitialized_error
        self.__dict__["_get_outline_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_outline_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_outline_width"] = _raise_uninitialized_error
        self.__dict__["_set_outline_width"] = _raise_uninitialized_error
        self.__dict__["_get_outline_appearance"] = _raise_uninitialized_error
        self.__dict__["_set_outline_appearance"] = _raise_uninitialized_error
        self.__dict__["_get_back_line_color"] = _raise_uninitialized_error
        self.__dict__["_set_back_line_color"] = _raise_uninitialized_error
        self.__dict__["_get_back_line_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_back_line_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_position"] = _raise_uninitialized_error
        self.__dict__["_set_position"] = _raise_uninitialized_error
        self.__dict__["_get_rotation"] = _raise_uninitialized_error
        self.__dict__["_set_rotation"] = _raise_uninitialized_error
        self.__dict__["_get_scale"] = _raise_uninitialized_error
        self.__dict__["_set_scale"] = _raise_uninitialized_error
        self.__dict__["_get_back_line_width"] = _raise_uninitialized_error
        self.__dict__["_set_back_line_width"] = _raise_uninitialized_error
        self.__dict__["_get_set_hint"] = _raise_uninitialized_error
        self.__dict__["_set_with_result"] = _raise_uninitialized_error
        self.__dict__["_set"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISolidPrimitive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISolidPrimitive from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISolidPrimitive = agcom.GUID(ISolidPrimitive._uuid)
        vtable_offset_local = ISolidPrimitive._vtable_offset - 1
        self.__dict__["_get_affected_by_lighting"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_affected_by_lighting"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_display_fill"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_fill"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_display_silhouette"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_silhouette"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_silhouette_color"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+7, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_silhouette_color"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+8, agcom.OLE_COLOR)
        self.__dict__["_get_silhouette_translucency"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+9, POINTER(agcom.FLOAT))
        self.__dict__["_set_silhouette_translucency"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+10, agcom.FLOAT)
        self.__dict__["_get_silhouette_width"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+11, POINTER(agcom.FLOAT))
        self.__dict__["_set_silhouette_width"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+12, agcom.FLOAT)
        self.__dict__["_get_minimum_silhouette_width_supported"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+13, POINTER(agcom.FLOAT))
        self.__dict__["_get_maximum_silhouette_width_supported"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+14, POINTER(agcom.FLOAT))
        self.__dict__["_get_display_outline"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_outline"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_get_outline_color"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+17, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_outline_color"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+18, agcom.OLE_COLOR)
        self.__dict__["_get_outline_translucency"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+19, POINTER(agcom.FLOAT))
        self.__dict__["_set_outline_translucency"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+20, agcom.FLOAT)
        self.__dict__["_get_outline_width"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+21, POINTER(agcom.FLOAT))
        self.__dict__["_set_outline_width"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+22, agcom.FLOAT)
        self.__dict__["_get_outline_appearance"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_set_outline_appearance"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+24, agcom.LONG)
        self.__dict__["_get_back_line_color"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+25, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_back_line_color"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+26, agcom.OLE_COLOR)
        self.__dict__["_get_back_line_translucency"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+27, POINTER(agcom.FLOAT))
        self.__dict__["_set_back_line_translucency"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+28, agcom.FLOAT)
        self.__dict__["_get_position"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+29, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_position"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+30, agcom.SAFEARRAY)
        self.__dict__["_get_rotation"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+31, POINTER(agcom.PVOID))
        self.__dict__["_set_rotation"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+32, agcom.PVOID)
        self.__dict__["_get_scale"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+33, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_scale"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+34, agcom.SAFEARRAY)
        self.__dict__["_get_back_line_width"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+35, POINTER(agcom.FLOAT))
        self.__dict__["_set_back_line_width"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+36, agcom.FLOAT)
        self.__dict__["_get_set_hint"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+37, POINTER(agcom.LONG))
        self.__dict__["_set_with_result"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+38, agcom.PVOID)
        self.__dict__["_set"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitive, vtable_offset_local+39, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG, agcom.PVOID, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISolidPrimitive.__dict__ and type(ISolidPrimitive.__dict__[attrname]) == property:
            return ISolidPrimitive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISolidPrimitive.")
    
    @property
    def affected_by_lighting(self) -> bool:
        """Gets or sets whether the primitive is affected by lighting."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_affected_by_lighting"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @affected_by_lighting.setter
    def affected_by_lighting(self, affectedByLighting:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(affectedByLighting) as arg_affectedByLighting:
            agcls.evaluate_hresult(self.__dict__["_set_affected_by_lighting"](arg_affectedByLighting.COM_val))

    @property
    def display_fill(self) -> bool:
        """Gets or sets whether the solid's fill is displayed."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_fill"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_fill.setter
    def display_fill(self, displayFill:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displayFill) as arg_displayFill:
            agcls.evaluate_hresult(self.__dict__["_set_display_fill"](arg_displayFill.COM_val))

    @property
    def display_silhouette(self) -> bool:
        """Gets or sets whether the solid's silhouette is displayed."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_silhouette"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_silhouette.setter
    def display_silhouette(self, displaySilhouette:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displaySilhouette) as arg_displaySilhouette:
            agcls.evaluate_hresult(self.__dict__["_set_display_silhouette"](arg_displaySilhouette.COM_val))

    @property
    def silhouette_color(self) -> agcolor.Color:
        """Gets or sets the silhouette's color."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_silhouette_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @silhouette_color.setter
    def silhouette_color(self, silhouetteColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(silhouetteColor) as arg_silhouetteColor:
            agcls.evaluate_hresult(self.__dict__["_set_silhouette_color"](arg_silhouetteColor.COM_val))

    @property
    def silhouette_translucency(self) -> float:
        """Gets or sets the silhouette's translucency. Translucency is between 0 and 1, where 0 is opaque and 1 is transparent."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_silhouette_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @silhouette_translucency.setter
    def silhouette_translucency(self, silhouetteTranslucency:float) -> None:
        with agmarshall.FLOAT_arg(silhouetteTranslucency) as arg_silhouetteTranslucency:
            agcls.evaluate_hresult(self.__dict__["_set_silhouette_translucency"](arg_silhouetteTranslucency.COM_val))

    @property
    def silhouette_width(self) -> float:
        """Gets or sets the silhouette' width, in pixels."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_silhouette_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @silhouette_width.setter
    def silhouette_width(self, silhouetteWidth:float) -> None:
        with agmarshall.FLOAT_arg(silhouetteWidth) as arg_silhouetteWidth:
            agcls.evaluate_hresult(self.__dict__["_set_silhouette_width"](arg_silhouetteWidth.COM_val))

    @property
    def minimum_silhouette_width_supported(self) -> float:
        """Gets the minimum silhouette width, in pixels, supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_silhouette_width_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def maximum_silhouette_width_supported(self) -> float:
        """Gets the maximum silhouette width, in pixels, supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_silhouette_width_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def display_outline(self) -> bool:
        """Gets or sets whether the solid's outline is displayed."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_outline"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_outline.setter
    def display_outline(self, displayOutline:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displayOutline) as arg_displayOutline:
            agcls.evaluate_hresult(self.__dict__["_set_display_outline"](arg_displayOutline.COM_val))

    @property
    def outline_color(self) -> agcolor.Color:
        """Gets or sets the outline's color."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_color.setter
    def outline_color(self, outlineColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(outlineColor) as arg_outlineColor:
            agcls.evaluate_hresult(self.__dict__["_set_outline_color"](arg_outlineColor.COM_val))

    @property
    def outline_translucency(self) -> float:
        """Gets or sets the outline's translucency. Translucency is between 0 and 1, where 0 is opaque and 1 is transparent."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_translucency.setter
    def outline_translucency(self, outlineTranslucency:float) -> None:
        with agmarshall.FLOAT_arg(outlineTranslucency) as arg_outlineTranslucency:
            agcls.evaluate_hresult(self.__dict__["_set_outline_translucency"](arg_outlineTranslucency.COM_val))

    @property
    def outline_width(self) -> float:
        """Gets or sets the outline's width, in pixels."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_width.setter
    def outline_width(self, outlineWidth:float) -> None:
        with agmarshall.FLOAT_arg(outlineWidth) as arg_outlineWidth:
            agcls.evaluate_hresult(self.__dict__["_set_outline_width"](arg_outlineWidth.COM_val))

    @property
    def outline_appearance(self) -> "AgEStkGraphicsOutlineAppearance":
        """Gets or sets the outline's appearance."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsOutlineAppearance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_appearance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_appearance.setter
    def outline_appearance(self, outlineAppearance:"AgEStkGraphicsOutlineAppearance") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsOutlineAppearance, outlineAppearance) as arg_outlineAppearance:
            agcls.evaluate_hresult(self.__dict__["_set_outline_appearance"](arg_outlineAppearance.COM_val))

    @property
    def back_line_color(self) -> agcolor.Color:
        """Gets or sets the back line's color."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_back_line_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @back_line_color.setter
    def back_line_color(self, backLineColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(backLineColor) as arg_backLineColor:
            agcls.evaluate_hresult(self.__dict__["_set_back_line_color"](arg_backLineColor.COM_val))

    @property
    def back_line_translucency(self) -> float:
        """Gets or sets the back line's translucency. Translucency is between 0 and 1, where 0 is opaque and 1 is transparent."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_back_line_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @back_line_translucency.setter
    def back_line_translucency(self, backLineTranslucency:float) -> None:
        with agmarshall.FLOAT_arg(backLineTranslucency) as arg_backLineTranslucency:
            agcls.evaluate_hresult(self.__dict__["_set_back_line_translucency"](arg_backLineTranslucency.COM_val))

    @property
    def position(self) -> list:
        """Gets or sets the solid's position. The position is defined in the solid's reference frame. The array contains the components of the position in the order x, y, z."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @position.setter
    def position(self, position:list) -> None:
        with agmarshall.SAFEARRAY_arg(position) as arg_position:
            agcls.evaluate_hresult(self.__dict__["_set_position"](arg_position.COM_val))

    @property
    def rotation(self) -> "IOrientation":
        """Gets or sets the rotation applied to the solid before rendering."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_rotation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @rotation.setter
    def rotation(self, rotation:"IOrientation") -> None:
        with agmarshall.AgInterface_in_arg(rotation, IOrientation) as arg_rotation:
            agcls.evaluate_hresult(self.__dict__["_set_rotation"](arg_rotation.COM_val))

    @property
    def scale(self) -> list:
        """Gets or sets a non-uniform scale that is applied to the solid to increase or decrease its rendered size. The array contains the scale for each component of the size in the order x scale, y scale, z scale."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scale"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @scale.setter
    def scale(self, scale:list) -> None:
        with agmarshall.SAFEARRAY_arg(scale) as arg_scale:
            agcls.evaluate_hresult(self.__dict__["_set_scale"](arg_scale.COM_val))

    @property
    def back_line_width(self) -> float:
        """Gets or sets the back line's width, in pixels."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_back_line_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @back_line_width.setter
    def back_line_width(self, backLineWidth:float) -> None:
        with agmarshall.FLOAT_arg(backLineWidth) as arg_backLineWidth:
            agcls.evaluate_hresult(self.__dict__["_set_back_line_width"](arg_backLineWidth.COM_val))

    @property
    def set_hint(self) -> "AgEStkGraphicsSetHint":
        """Gets the primitive's set hint. See the Set Hint Performance Overview for selecting an appropriate value to construct the primitive with."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSetHint) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_set_hint"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def set_with_result(self, solidTriangulatorResult:"ISolidTriangulatorResult") -> None:
        """Defines the solid using the specified solidTriangulatorResult. The solid is rendered in the primitive's reference frame."""
        with agmarshall.AgInterface_in_arg(solidTriangulatorResult, ISolidTriangulatorResult) as arg_solidTriangulatorResult:
            agcls.evaluate_hresult(self.__dict__["_set_with_result"](arg_solidTriangulatorResult.COM_val))

    def set(self, positions:list, normals:list, indices:list, outlineIndices:list, windingOrder:"AgEStkGraphicsWindingOrder", boundingSphere:"IBoundingSphere", closed:bool) -> None:
        """Defines the solid using the specified parameters. The solid is rendered in the primitive's reference frame."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(normals) as arg_normals, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.SAFEARRAY_arg(outlineIndices) as arg_outlineIndices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder, windingOrder) as arg_windingOrder, \
             agmarshall.AgInterface_in_arg(boundingSphere, IBoundingSphere) as arg_boundingSphere, \
             agmarshall.VARIANT_BOOL_arg(closed) as arg_closed:
            agcls.evaluate_hresult(self.__dict__["_set"](byref(arg_positions.COM_val), byref(arg_normals.COM_val), byref(arg_indices.COM_val), byref(arg_outlineIndices.COM_val), arg_windingOrder.COM_val, arg_boundingSphere.COM_val, arg_closed.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{10ae68b3-ec89-4ced-9b4c-8aae9123eb24}", ISolidPrimitive)
agcls.AgTypeNameMap["ISolidPrimitive"] = ISolidPrimitive

class IStereoscopic(object):
    """Gets the stereoscopic options for all Scenes. To use a particular stereoscopic display mode, ensure that your system supports the feature and that it is enabled."""
    _uuid = "{41d0e11b-d00c-4255-b869-2fc8430f994e}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_display_mode"] = _raise_uninitialized_error
        self.__dict__["_set_display_mode"] = _raise_uninitialized_error
        self.__dict__["_get_projection_mode"] = _raise_uninitialized_error
        self.__dict__["_set_projection_mode"] = _raise_uninitialized_error
        self.__dict__["_get_projection_distance"] = _raise_uninitialized_error
        self.__dict__["_set_projection_distance"] = _raise_uninitialized_error
        self.__dict__["_get_eye_separation_factor"] = _raise_uninitialized_error
        self.__dict__["_set_eye_separation_factor"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStereoscopic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStereoscopic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStereoscopic = agcom.GUID(IStereoscopic._uuid)
        vtable_offset_local = IStereoscopic._vtable_offset - 1
        self.__dict__["_get_display_mode"] = IAGFUNCTYPE(pUnk, IID_IStereoscopic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_display_mode"] = IAGFUNCTYPE(pUnk, IID_IStereoscopic, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_projection_mode"] = IAGFUNCTYPE(pUnk, IID_IStereoscopic, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_projection_mode"] = IAGFUNCTYPE(pUnk, IID_IStereoscopic, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_projection_distance"] = IAGFUNCTYPE(pUnk, IID_IStereoscopic, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_projection_distance"] = IAGFUNCTYPE(pUnk, IID_IStereoscopic, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_eye_separation_factor"] = IAGFUNCTYPE(pUnk, IID_IStereoscopic, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_eye_separation_factor"] = IAGFUNCTYPE(pUnk, IID_IStereoscopic, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStereoscopic.__dict__ and type(IStereoscopic.__dict__[attrname]) == property:
            return IStereoscopic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStereoscopic.")
    
    @property
    def display_mode(self) -> "AgEStkGraphicsStereoscopicDisplayMode":
        """Gets or sets the stereoscopic display mode for all Scenes. To use a particular stereoscopic display mode, ensure that your system supports the feature and that it is enabled."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsStereoscopicDisplayMode) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_mode"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_mode.setter
    def display_mode(self, displayMode:"AgEStkGraphicsStereoscopicDisplayMode") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsStereoscopicDisplayMode, displayMode) as arg_displayMode:
            agcls.evaluate_hresult(self.__dict__["_set_display_mode"](arg_displayMode.COM_val))

    @property
    def projection_mode(self) -> "AgEStkGraphicsStereoProjectionMode":
        """Gets or sets whether the type of stereo projection that will be used."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsStereoProjectionMode) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_projection_mode"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @projection_mode.setter
    def projection_mode(self, projectionMode:"AgEStkGraphicsStereoProjectionMode") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsStereoProjectionMode, projectionMode) as arg_projectionMode:
            agcls.evaluate_hresult(self.__dict__["_set_projection_mode"](arg_projectionMode.COM_val))

    @property
    def projection_distance(self) -> float:
        """Gets or sets the projection distance. If projection mode is set to eStkGraphicsStereoProjectionAutomatic, the value of this property will be ignored."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_projection_distance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @projection_distance.setter
    def projection_distance(self, projectionDistance:float) -> None:
        with agmarshall.DOUBLE_arg(projectionDistance) as arg_projectionDistance:
            agcls.evaluate_hresult(self.__dict__["_set_projection_distance"](arg_projectionDistance.COM_val))

    @property
    def eye_separation_factor(self) -> float:
        """Gets or sets the eye separation factor."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_eye_separation_factor"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @eye_separation_factor.setter
    def eye_separation_factor(self, eyeSeparationFactor:float) -> None:
        with agmarshall.DOUBLE_arg(eyeSeparationFactor) as arg_eyeSeparationFactor:
            agcls.evaluate_hresult(self.__dict__["_set_eye_separation_factor"](arg_eyeSeparationFactor.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{41d0e11b-d00c-4255-b869-2fc8430f994e}", IStereoscopic)
agcls.AgTypeNameMap["IStereoscopic"] = IStereoscopic

class ISurfaceMeshPrimitive(object):
    """A triangle mesh primitive for meshes on the surface that need to conform to terrain."""
    _uuid = "{9f13f05b-9c30-4118-8d6b-ab331881aba6}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_texture"] = _raise_uninitialized_error
        self.__dict__["_set_texture"] = _raise_uninitialized_error
        self.__dict__["_get_wireframe"] = _raise_uninitialized_error
        self.__dict__["_set_wireframe"] = _raise_uninitialized_error
        self.__dict__["_get_triangle_winding_order"] = _raise_uninitialized_error
        self.__dict__["_get_set_hint"] = _raise_uninitialized_error
        self.__dict__["_get_rendering_method"] = _raise_uninitialized_error
        self.__dict__["_get_texture_filter"] = _raise_uninitialized_error
        self.__dict__["_set_texture_filter"] = _raise_uninitialized_error
        self.__dict__["_get_texture_matrix"] = _raise_uninitialized_error
        self.__dict__["_set_texture_matrix"] = _raise_uninitialized_error
        self.__dict__["_get_transparent_texture_border"] = _raise_uninitialized_error
        self.__dict__["_set_transparent_texture_border"] = _raise_uninitialized_error
        self.__dict__["_set"] = _raise_uninitialized_error
        self.__dict__["_set_without_texturing"] = _raise_uninitialized_error
        self.__dict__["_supported"] = _raise_uninitialized_error
        self.__dict__["_supported_with_default_rendering_method"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISurfaceMeshPrimitive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISurfaceMeshPrimitive from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISurfaceMeshPrimitive = agcom.GUID(ISurfaceMeshPrimitive._uuid)
        vtable_offset_local = ISurfaceMeshPrimitive._vtable_offset - 1
        self.__dict__["_get_texture"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_set_texture"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_get_wireframe"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_wireframe"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_triangle_winding_order"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_get_set_hint"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_get_rendering_method"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_get_texture_filter"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_set_texture_filter"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+9, agcom.PVOID)
        self.__dict__["_get_texture_matrix"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_set_texture_matrix"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+11, agcom.PVOID)
        self.__dict__["_get_transparent_texture_border"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_transparent_texture_border"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+13, agcom.VARIANT_BOOL)
        self.__dict__["_set"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+14, agcom.PVOID)
        self.__dict__["_set_without_texturing"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+15, agcom.PVOID)
        self.__dict__["_supported"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+16, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_supported_with_default_rendering_method"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitive, vtable_offset_local+17, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISurfaceMeshPrimitive.__dict__ and type(ISurfaceMeshPrimitive.__dict__[attrname]) == property:
            return ISurfaceMeshPrimitive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISurfaceMeshPrimitive.")
    
    @property
    def texture(self) -> "IRendererTexture2D":
        """Gets or sets the texture applied to this primitive when rendering."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_texture"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @texture.setter
    def texture(self, texture:"IRendererTexture2D") -> None:
        with agmarshall.AgInterface_in_arg(texture, IRendererTexture2D) as arg_texture:
            agcls.evaluate_hresult(self.__dict__["_set_texture"](arg_texture.COM_val))

    @property
    def wireframe(self) -> bool:
        """Gets or sets whether the primitive is rendered in wireframe. This is useful for debugging."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_wireframe"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @wireframe.setter
    def wireframe(self, wireframe:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(wireframe) as arg_wireframe:
            agcls.evaluate_hresult(self.__dict__["_set_wireframe"](arg_wireframe.COM_val))

    @property
    def triangle_winding_order(self) -> "AgEStkGraphicsWindingOrder":
        """Gets the orientation of front-facing triangles in the mesh."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_triangle_winding_order"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def set_hint(self) -> "AgEStkGraphicsSetHint":
        """Gets the primitive's set hint. See the Set Hint Performance Overview for selecting an appropriate value to construct the primitive with."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSetHint) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_set_hint"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def rendering_method(self) -> "AgEStkGraphicsSurfaceMeshRenderingMethod":
        """Gets the rendering method used to render the mesh."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSurfaceMeshRenderingMethod) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_rendering_method"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def texture_filter(self) -> "ITextureFilter2D":
        """Gets or sets the filter used when a texture is applied to this primitive."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_texture_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @texture_filter.setter
    def texture_filter(self, textureFilter:"ITextureFilter2D") -> None:
        with agmarshall.AgInterface_in_arg(textureFilter, ITextureFilter2D) as arg_textureFilter:
            agcls.evaluate_hresult(self.__dict__["_set_texture_filter"](arg_textureFilter.COM_val))

    @property
    def texture_matrix(self) -> "ITextureMatrix":
        """Gets or sets the matrix used to transform texture coordinates when a texture is applied to this primitive."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_texture_matrix"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @texture_matrix.setter
    def texture_matrix(self, textureMatrix:"ITextureMatrix") -> None:
        with agmarshall.AgInterface_in_arg(textureMatrix, ITextureMatrix) as arg_textureMatrix:
            agcls.evaluate_hresult(self.__dict__["_set_texture_matrix"](arg_textureMatrix.COM_val))

    @property
    def transparent_texture_border(self) -> bool:
        """Gets or set the boolean that defines if the color obtained from texture coordinates beyond the texture border should be considered transparent or not. This is typically used in conjunction with the a texture matrix."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_transparent_texture_border"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @transparent_texture_border.setter
    def transparent_texture_border(self, transparentTextureBorder:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(transparentTextureBorder) as arg_transparentTextureBorder:
            agcls.evaluate_hresult(self.__dict__["_set_transparent_texture_border"](arg_transparentTextureBorder.COM_val))

    def set(self, surfaceTriangulator:"ISurfaceTriangulatorResult") -> None:
        """Defines the surface mesh using the specified surfaceTriangulator. The mesh is rendered in the primitive's reference frame."""
        with agmarshall.AgInterface_in_arg(surfaceTriangulator, ISurfaceTriangulatorResult) as arg_surfaceTriangulator:
            agcls.evaluate_hresult(self.__dict__["_set"](arg_surfaceTriangulator.COM_val))

    def set_without_texturing(self, surfaceTriangulator:"ISurfaceTriangulatorResult") -> None:
        """Defines the surface mesh using the specified surfaceTriangulator. The mesh is rendered in the primitive's reference frame."""
        with agmarshall.AgInterface_in_arg(surfaceTriangulator, ISurfaceTriangulatorResult) as arg_surfaceTriangulator:
            agcls.evaluate_hresult(self.__dict__["_set_without_texturing"](arg_surfaceTriangulator.COM_val))

    def supported(self, renderingMethod:"AgEStkGraphicsSurfaceMeshRenderingMethod") -> bool:
        """Determines whether or not the video card supports the surface mesh primitive with the given renderingMethod."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSurfaceMeshRenderingMethod, renderingMethod) as arg_renderingMethod, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_supported"](arg_renderingMethod.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def supported_with_default_rendering_method(self) -> bool:
        """Determines whether or not the video card supports the surface mesh primitive. This is equivalent to calling Supported with automatic."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_supported_with_default_rendering_method"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{9f13f05b-9c30-4118-8d6b-ab331881aba6}", ISurfaceMeshPrimitive)
agcls.AgTypeNameMap["ISurfaceMeshPrimitive"] = ISurfaceMeshPrimitive

class ITerrainOverlayCollection(object):
    """A collection of terrain overlay objects."""
    _uuid = "{6dbd63a6-624b-4318-8fec-daf384f070c4}"
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_is_read_only"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_contains"] = _raise_uninitialized_error
        self.__dict__["_contains_uri_string"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_clear"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_add_async"] = _raise_uninitialized_error
        self.__dict__["_index_of"] = _raise_uninitialized_error
        self.__dict__["_index_of_uri_string"] = _raise_uninitialized_error
        self.__dict__["_add_uri_string"] = _raise_uninitialized_error
        self.__dict__["_add_async_uri_string"] = _raise_uninitialized_error
        self.__dict__["_swap"] = _raise_uninitialized_error
        self.__dict__["_swap_by_index"] = _raise_uninitialized_error
        self.__dict__["_move"] = _raise_uninitialized_error
        self.__dict__["_move_by_index"] = _raise_uninitialized_error
        self.__dict__["_bring_to_front"] = _raise_uninitialized_error
        self.__dict__["_send_to_back"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITerrainOverlayCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITerrainOverlayCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITerrainOverlayCollection = agcom.GUID(ITerrainOverlayCollection._uuid)
        vtable_offset_local = ITerrainOverlayCollection._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_get_is_read_only"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+2, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+3, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_contains"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+5, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_contains_uri_string"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+7, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_clear"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+8, )
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+9, agcom.PVOID)
        self.__dict__["_add_async"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+10, agcom.PVOID)
        self.__dict__["_index_of"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+11, agcom.PVOID, POINTER(agcom.INT))
        self.__dict__["_index_of_uri_string"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+12, agcom.BSTR, POINTER(agcom.INT))
        self.__dict__["_add_uri_string"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+13, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_add_async_uri_string"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+14, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_swap"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+15, agcom.PVOID, agcom.PVOID)
        self.__dict__["_swap_by_index"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+16, agcom.INT, agcom.INT)
        self.__dict__["_move"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+17, agcom.PVOID, agcom.INT)
        self.__dict__["_move_by_index"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+18, agcom.INT, agcom.INT)
        self.__dict__["_bring_to_front"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+19, agcom.PVOID)
        self.__dict__["_send_to_back"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayCollection, vtable_offset_local+20, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITerrainOverlayCollection.__dict__ and type(ITerrainOverlayCollection.__dict__[attrname]) == property:
            return ITerrainOverlayCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITerrainOverlayCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ITerrainOverlay":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    def Subscribe(self) -> ITerrainOverlayCollectionEventHandler:
        """Returns an ITerrainOverlayCollectionEventHandler that is subscribed to handle events associated with this instance of ITerrainOverlayCollection."""
        return ITerrainOverlayCollectionEventHandler(self._pUnk)    
    @property
    def count(self) -> int:
        """Gets the number of terrain overlay objects in the collection."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def is_read_only(self) -> bool:
        """Gets whether or not the collection is read only."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_read_only"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> "ITerrainOverlay":
        """Gets the terrain overlay at the specified index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Constructs an iterator that can be used to iterate the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def contains(self, terrainOverlay:"ITerrainOverlay") -> bool:
        """Checks the presence of a terrain overlay in the collection."""
        with agmarshall.AgInterface_in_arg(terrainOverlay, ITerrainOverlay) as arg_terrainOverlay, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_contains"](arg_terrainOverlay.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def contains_uri_string(self, stringUri:str) -> bool:
        """Checks the presence of a terrain overlay with the specified Uri in the collection."""
        with agmarshall.BSTR_arg(stringUri) as arg_stringUri, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_contains_uri_string"](arg_stringUri.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def remove(self, terrainOverlay:"ITerrainOverlay") -> bool:
        """Removes a terrain overlay from the collection."""
        with agmarshall.AgInterface_in_arg(terrainOverlay, ITerrainOverlay) as arg_terrainOverlay, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_terrainOverlay.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def clear(self) -> None:
        """Removes all terrain overlay objects from the collection."""
        agcls.evaluate_hresult(self.__dict__["_clear"]())

    def add(self, terrainOverlay:"ITerrainOverlay") -> None:
        """Adds terrainOverlay to the collection."""
        with agmarshall.AgInterface_in_arg(terrainOverlay, ITerrainOverlay) as arg_terrainOverlay:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_terrainOverlay.COM_val))

    def add_async(self, terrainOverlay:"ITerrainOverlay") -> None:
        """Adds terrainOverlay to the collection asynchronously."""
        with agmarshall.AgInterface_in_arg(terrainOverlay, ITerrainOverlay) as arg_terrainOverlay:
            agcls.evaluate_hresult(self.__dict__["_add_async"](arg_terrainOverlay.COM_val))

    def index_of(self, terrainOverlay:"ITerrainOverlay") -> int:
        """Gets the index of the specified terrain overlay."""
        with agmarshall.AgInterface_in_arg(terrainOverlay, ITerrainOverlay) as arg_terrainOverlay, \
             agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_index_of"](arg_terrainOverlay.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def index_of_uri_string(self, stringUri:str) -> int:
        """Gets the index of the terrain overlay with the specified Uri."""
        with agmarshall.BSTR_arg(stringUri) as arg_stringUri, \
             agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_index_of_uri_string"](arg_stringUri.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def add_uri_string(self, uri:str) -> "ITerrainOverlay":
        """Creates a terrain overlay from the uri, which represents a uri, and adds it to the collection."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_add_uri_string"](arg_uri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def add_async_uri_string(self, uri:str) -> "ITerrainOverlay":
        """Creates a terrain overlay from the uri, which represents a uri, and adds it to the collection asynchronously."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_add_async_uri_string"](arg_uri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def swap(self, terrainOverlay1:"ITerrainOverlay", terrainOverlay2:"ITerrainOverlay") -> None:
        """Swaps the position of two terrain overlay objects."""
        with agmarshall.AgInterface_in_arg(terrainOverlay1, ITerrainOverlay) as arg_terrainOverlay1, \
             agmarshall.AgInterface_in_arg(terrainOverlay2, ITerrainOverlay) as arg_terrainOverlay2:
            agcls.evaluate_hresult(self.__dict__["_swap"](arg_terrainOverlay1.COM_val, arg_terrainOverlay2.COM_val))

    def swap_by_index(self, index1:int, index2:int) -> None:
        """Swaps the position of two terrain overlay objects at the specified indices."""
        with agmarshall.INT_arg(index1) as arg_index1, \
             agmarshall.INT_arg(index2) as arg_index2:
            agcls.evaluate_hresult(self.__dict__["_swap_by_index"](arg_index1.COM_val, arg_index2.COM_val))

    def move(self, terrainOverlay:"ITerrainOverlay", newPosition:int) -> None:
        """Moves the terrain overlay to the specified position."""
        with agmarshall.AgInterface_in_arg(terrainOverlay, ITerrainOverlay) as arg_terrainOverlay, \
             agmarshall.INT_arg(newPosition) as arg_newPosition:
            agcls.evaluate_hresult(self.__dict__["_move"](arg_terrainOverlay.COM_val, arg_newPosition.COM_val))

    def move_by_index(self, index:int, newPosition:int) -> None:
        """Moves the terrain overlay at the specified index to the specified position."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.INT_arg(newPosition) as arg_newPosition:
            agcls.evaluate_hresult(self.__dict__["_move_by_index"](arg_index.COM_val, arg_newPosition.COM_val))

    def bring_to_front(self, terrainOverlay:"ITerrainOverlay") -> None:
        """Brings the terrain overlay to the front of the collection so it is rendered first or on the bottom."""
        with agmarshall.AgInterface_in_arg(terrainOverlay, ITerrainOverlay) as arg_terrainOverlay:
            agcls.evaluate_hresult(self.__dict__["_bring_to_front"](arg_terrainOverlay.COM_val))

    def send_to_back(self, terrainOverlay:"ITerrainOverlay") -> None:
        """Sends the terrain overlay to the back of the collection so it is rendered last or on the top."""
        with agmarshall.AgInterface_in_arg(terrainOverlay, ITerrainOverlay) as arg_terrainOverlay:
            agcls.evaluate_hresult(self.__dict__["_send_to_back"](arg_terrainOverlay.COM_val))

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{6dbd63a6-624b-4318-8fec-daf384f070c4}", ITerrainOverlayCollection)
agcls.AgTypeNameMap["ITerrainOverlayCollection"] = ITerrainOverlayCollection

class ITerrainOverlay(object):
    """A globe overlay which shows terrain."""
    _uuid = "{dfe57e34-7b31-4360-a7a8-8db856882670}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_scale"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_scale"] = _raise_uninitialized_error
        self.__dict__["_get_supported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITerrainOverlay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITerrainOverlay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITerrainOverlay = agcom.GUID(ITerrainOverlay._uuid)
        vtable_offset_local = ITerrainOverlay._vtable_offset - 1
        self.__dict__["_get_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlay, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlay, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_altitude_scale"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlay, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_scale"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlay, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_supported"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlay, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITerrainOverlay.__dict__ and type(ITerrainOverlay.__dict__[attrname]) == property:
            return ITerrainOverlay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITerrainOverlay.")
    
    @property
    def altitude_offset(self) -> float:
        """Gets or sets the value from which to offset the terrain height."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_offset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @altitude_offset.setter
    def altitude_offset(self, altitudeOffset:float) -> None:
        with agmarshall.DOUBLE_arg(altitudeOffset) as arg_altitudeOffset:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_offset"](arg_altitudeOffset.COM_val))

    @property
    def altitude_scale(self) -> float:
        """Gets or sets the value from which to scale the terrain height."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_scale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @altitude_scale.setter
    def altitude_scale(self, altitudeScale:float) -> None:
        with agmarshall.DOUBLE_arg(altitudeScale) as arg_altitudeScale:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_scale"](arg_altitudeScale.COM_val))

    @property
    def supported(self) -> bool:
        """Gets whether the video card supports adding terrain overlay objects. Video cards that support OpenGL 1.2 or higher support terrain overlay objects."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{dfe57e34-7b31-4360-a7a8-8db856882670}", ITerrainOverlay)
agcls.AgTypeNameMap["ITerrainOverlay"] = ITerrainOverlay

class ITextBatchPrimitive(object):
    """ Renders one or more strings in the 3D scene.  For best performance, avoid creating lots of batches with only a few strings each. See the Batching Performance Overview. """
    _uuid = "{037722fb-c0e5-4052-b34d-60aa662b5d2b}"
    _num_methods = 32
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_set_hint"] = _raise_uninitialized_error
        self.__dict__["_get_bounding_sphere_scale"] = _raise_uninitialized_error
        self.__dict__["_set_bounding_sphere_scale"] = _raise_uninitialized_error
        self.__dict__["_get_font"] = _raise_uninitialized_error
        self.__dict__["_get_outline_color"] = _raise_uninitialized_error
        self.__dict__["_set_outline_color"] = _raise_uninitialized_error
        self.__dict__["_get_outline_translucency"] = _raise_uninitialized_error
        self.__dict__["_set_outline_translucency"] = _raise_uninitialized_error
        self.__dict__["_get_align_to_pixel"] = _raise_uninitialized_error
        self.__dict__["_set_align_to_pixel"] = _raise_uninitialized_error
        self.__dict__["_get_distance_display_condition_per_string"] = _raise_uninitialized_error
        self.__dict__["_set_distance_display_condition_per_string"] = _raise_uninitialized_error
        self.__dict__["_get_per_item_picking_enabled"] = _raise_uninitialized_error
        self.__dict__["_set_per_item_picking_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_texture_filter"] = _raise_uninitialized_error
        self.__dict__["_set_texture_filter"] = _raise_uninitialized_error
        self.__dict__["_set"] = _raise_uninitialized_error
        self.__dict__["_set_with_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_set_with_optional_parameters_and_render_pass"] = _raise_uninitialized_error
        self.__dict__["_set_cartographic"] = _raise_uninitialized_error
        self.__dict__["_set_cartographic_with_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_set_cartographic_with_optional_parameters_and_render_pass"] = _raise_uninitialized_error
        self.__dict__["_set_partial"] = _raise_uninitialized_error
        self.__dict__["_set_partial_with_indices_order"] = _raise_uninitialized_error
        self.__dict__["_set_partial_with_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_set_partial_with_optional_parameters_indices_order_and_render_pass"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic_with_indices_order"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic_with_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass"] = _raise_uninitialized_error
        self.__dict__["_get_render_in_screen_space"] = _raise_uninitialized_error
        self.__dict__["_set_render_in_screen_space"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITextBatchPrimitive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITextBatchPrimitive from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITextBatchPrimitive = agcom.GUID(ITextBatchPrimitive._uuid)
        vtable_offset_local = ITextBatchPrimitive._vtable_offset - 1
        self.__dict__["_get_set_hint"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_get_bounding_sphere_scale"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_set_bounding_sphere_scale"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+3, agcom.DOUBLE)
        self.__dict__["_get_font"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_outline_color"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+5, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_outline_color"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+6, agcom.OLE_COLOR)
        self.__dict__["_get_outline_translucency"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+7, POINTER(agcom.FLOAT))
        self.__dict__["_set_outline_translucency"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+8, agcom.FLOAT)
        self.__dict__["_get_align_to_pixel"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_align_to_pixel"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_distance_display_condition_per_string"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_set_distance_display_condition_per_string"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_get_per_item_picking_enabled"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_per_item_picking_enabled"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+14, agcom.VARIANT_BOOL)
        self.__dict__["_get_texture_filter"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_set_texture_filter"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+16, agcom.PVOID)
        self.__dict__["_set"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+17, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_with_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+18, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.PVOID)
        self.__dict__["_set_with_optional_parameters_and_render_pass"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+19, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.PVOID, agcom.LONG)
        self.__dict__["_set_cartographic"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+20, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_cartographic_with_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+21, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.PVOID)
        self.__dict__["_set_cartographic_with_optional_parameters_and_render_pass"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+22, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.PVOID, agcom.LONG)
        self.__dict__["_set_partial"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+23, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_with_indices_order"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+24, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG)
        self.__dict__["_set_partial_with_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+25, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.PVOID, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_with_optional_parameters_indices_order_and_render_pass"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+26, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.PVOID, POINTER(agcom.SAFEARRAY), agcom.LONG, agcom.LONG)
        self.__dict__["_set_partial_cartographic"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+27, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_cartographic_with_indices_order"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+28, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG)
        self.__dict__["_set_partial_cartographic_with_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+29, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.PVOID, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+30, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.PVOID, POINTER(agcom.SAFEARRAY), agcom.LONG, agcom.LONG)
        self.__dict__["_get_render_in_screen_space"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+31, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_render_in_screen_space"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitive, vtable_offset_local+32, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITextBatchPrimitive.__dict__ and type(ITextBatchPrimitive.__dict__[attrname]) == property:
            return ITextBatchPrimitive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITextBatchPrimitive.")
    
    @property
    def set_hint(self) -> "AgEStkGraphicsSetHint":
        """Gets the primitive's set hint. See the Set Hint Performance Overview for selecting an appropriate value to construct the primitive with."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSetHint) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_set_hint"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def bounding_sphere_scale(self) -> float:
        """Gets or sets the scale applied to the radius of this primitive's bounding sphere."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_bounding_sphere_scale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @bounding_sphere_scale.setter
    def bounding_sphere_scale(self, boundingSphereScale:float) -> None:
        with agmarshall.DOUBLE_arg(boundingSphereScale) as arg_boundingSphereScale:
            agcls.evaluate_hresult(self.__dict__["_set_bounding_sphere_scale"](arg_boundingSphereScale.COM_val))

    @property
    def font(self) -> "IGraphicsFont":
        """Gets the font used to render the text batch."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_font"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def outline_color(self) -> agcolor.Color:
        """Gets or sets the text's outline color."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_color.setter
    def outline_color(self, outlineColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(outlineColor) as arg_outlineColor:
            agcls.evaluate_hresult(self.__dict__["_set_outline_color"](arg_outlineColor.COM_val))

    @property
    def outline_translucency(self) -> float:
        """Gets or sets the text's outline translucency. Translucency is between 0 and 1, where 0 is opaque and 1 is transparent."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_translucency"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_translucency.setter
    def outline_translucency(self, outlineTranslucency:float) -> None:
        with agmarshall.FLOAT_arg(outlineTranslucency) as arg_outlineTranslucency:
            agcls.evaluate_hresult(self.__dict__["_set_outline_translucency"](arg_outlineTranslucency.COM_val))

    @property
    def align_to_pixel(self) -> bool:
        """Gets or sets whether the screen space position of each string is aligned to a pixel."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_align_to_pixel"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @align_to_pixel.setter
    def align_to_pixel(self, alignToPixel:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(alignToPixel) as arg_alignToPixel:
            agcls.evaluate_hresult(self.__dict__["_set_align_to_pixel"](arg_alignToPixel.COM_val))

    @property
    def distance_display_condition_per_string(self) -> "IDistanceDisplayCondition":
        """Gets or sets a distance display condition that is evaluated per string in the text batch during rendering. This is different than display condition, which is evaluated once for the entire text batch..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_distance_display_condition_per_string"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @distance_display_condition_per_string.setter
    def distance_display_condition_per_string(self, distanceDisplayConditionPerString:"IDistanceDisplayCondition") -> None:
        with agmarshall.AgInterface_in_arg(distanceDisplayConditionPerString, IDistanceDisplayCondition) as arg_distanceDisplayConditionPerString:
            agcls.evaluate_hresult(self.__dict__["_set_distance_display_condition_per_string"](arg_distanceDisplayConditionPerString.COM_val))

    @property
    def per_item_picking_enabled(self) -> bool:
        """Gets or sets whether individual text indices will be included in the pick results returned from the scene's Pick method. Each text index that is picked will be returned as a batch primitive index."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_per_item_picking_enabled"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @per_item_picking_enabled.setter
    def per_item_picking_enabled(self, perItemPickingEnabled:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(perItemPickingEnabled) as arg_perItemPickingEnabled:
            agcls.evaluate_hresult(self.__dict__["_set_per_item_picking_enabled"](arg_perItemPickingEnabled.COM_val))

    @property
    def texture_filter(self) -> "ITextureFilter2D":
        """Gets or sets the filter used to filter the texture-based font."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_texture_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @texture_filter.setter
    def texture_filter(self, textureFilter:"ITextureFilter2D") -> None:
        with agmarshall.AgInterface_in_arg(textureFilter, ITextureFilter2D) as arg_textureFilter:
            agcls.evaluate_hresult(self.__dict__["_set_texture_filter"](arg_textureFilter.COM_val))

    def set(self, positions:list, text:list) -> None:
        """Defines the positions and text of strings in a text batch. The strings are rendered in the primitive's reference frame."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(text) as arg_text:
            agcls.evaluate_hresult(self.__dict__["_set"](byref(arg_positions.COM_val), byref(arg_text.COM_val)))

    def set_with_optional_parameters(self, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters") -> None:
        """Defines the positions, text, and optional parameters of strings in a text batch. The strings are rendered in the primitive's reference frame."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(text) as arg_text, \
             agmarshall.AgInterface_in_arg(optionalParameters, ITextBatchPrimitiveOptionalParameters) as arg_optionalParameters:
            agcls.evaluate_hresult(self.__dict__["_set_with_optional_parameters"](byref(arg_positions.COM_val), byref(arg_text.COM_val), arg_optionalParameters.COM_val))

    def set_with_optional_parameters_and_render_pass(self, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters", renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """Defines the positions, text, and optional parameters of strings in a text batch. The strings are rendered in the primitive's reference frame. renderPassHint is provided for efficiency."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(text) as arg_text, \
             agmarshall.AgInterface_in_arg(optionalParameters, ITextBatchPrimitiveOptionalParameters) as arg_optionalParameters, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_with_optional_parameters_and_render_pass"](byref(arg_positions.COM_val), byref(arg_text.COM_val), arg_optionalParameters.COM_val, arg_renderPassHint.COM_val))

    def set_cartographic(self, centralBody:str, positions:list, text:list) -> None:
        """For convenience. Defines the positions and text of strings in a text batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(text) as arg_text:
            agcls.evaluate_hresult(self.__dict__["_set_cartographic"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_text.COM_val)))

    def set_cartographic_with_optional_parameters(self, centralBody:str, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters") -> None:
        """For convenience. Defines the positions, text, and optional parameters of strings in a text batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(text) as arg_text, \
             agmarshall.AgInterface_in_arg(optionalParameters, ITextBatchPrimitiveOptionalParameters) as arg_optionalParameters:
            agcls.evaluate_hresult(self.__dict__["_set_cartographic_with_optional_parameters"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_text.COM_val), arg_optionalParameters.COM_val))

    def set_cartographic_with_optional_parameters_and_render_pass(self, centralBody:str, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters", renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """For convenience. Defines the positions, text, and optional parameters of strings in a text batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(text) as arg_text, \
             agmarshall.AgInterface_in_arg(optionalParameters, ITextBatchPrimitiveOptionalParameters) as arg_optionalParameters, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_cartographic_with_optional_parameters_and_render_pass"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_text.COM_val), arg_optionalParameters.COM_val, arg_renderPassHint.COM_val))

    def set_partial(self, positions:list, text:list, indices:list) -> None:
        """Updates a subset of positions and/or text in a text batch."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(text) as arg_text, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial"](byref(arg_positions.COM_val), byref(arg_text.COM_val), byref(arg_indices.COM_val)))

    def set_partial_with_indices_order(self, positions:list, text:list, indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint") -> None:
        """Updates a subset of positions and/or text in a text batch."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(text) as arg_text, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_with_indices_order"](byref(arg_positions.COM_val), byref(arg_text.COM_val), byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val))

    def set_partial_with_optional_parameters(self, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters", indices:list) -> None:
        """Updates a subset of positions, text, and/or optional per-string parameters in a text batch."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(text) as arg_text, \
             agmarshall.AgInterface_in_arg(optionalParameters, ITextBatchPrimitiveOptionalParameters) as arg_optionalParameters, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial_with_optional_parameters"](byref(arg_positions.COM_val), byref(arg_text.COM_val), arg_optionalParameters.COM_val, byref(arg_indices.COM_val)))

    def set_partial_with_optional_parameters_indices_order_and_render_pass(self, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters", indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint", renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """Updates a subset of positions, text, and/or optional per-string parameters in a text batch."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(text) as arg_text, \
             agmarshall.AgInterface_in_arg(optionalParameters, ITextBatchPrimitiveOptionalParameters) as arg_optionalParameters, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_with_optional_parameters_indices_order_and_render_pass"](byref(arg_positions.COM_val), byref(arg_text.COM_val), arg_optionalParameters.COM_val, byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val, arg_renderPassHint.COM_val))

    def set_partial_cartographic(self, centralBody:str, positions:list, text:list, indices:list) -> None:
        """For convenience. Updates a subset of positions and/or text in a text batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(text) as arg_text, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_text.COM_val), byref(arg_indices.COM_val)))

    def set_partial_cartographic_with_indices_order(self, centralBody:str, positions:list, text:list, indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint") -> None:
        """For convenience. Updates a subset of positions and/or text in a text batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(text) as arg_text, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic_with_indices_order"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_text.COM_val), byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val))

    def set_partial_cartographic_with_optional_parameters(self, centralBody:str, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters", indices:list) -> None:
        """For convenience. Updates a subset of positions, text, and/or per-string parameters in a text batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(text) as arg_text, \
             agmarshall.AgInterface_in_arg(optionalParameters, ITextBatchPrimitiveOptionalParameters) as arg_optionalParameters, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic_with_optional_parameters"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_text.COM_val), arg_optionalParameters.COM_val, byref(arg_indices.COM_val)))

    def set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass(self, centralBody:str, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters", indices:list, indicesOrderHint:"AgEStkGraphicsIndicesOrderHint", renderPassHint:"AgEStkGraphicsRenderPassHint") -> None:
        """For convenience. Updates a subset of positions, text, and/or per-string parameters in a text batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(text) as arg_text, \
             agmarshall.AgInterface_in_arg(optionalParameters, ITextBatchPrimitiveOptionalParameters) as arg_optionalParameters, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsIndicesOrderHint, indicesOrderHint) as arg_indicesOrderHint, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRenderPassHint, renderPassHint) as arg_renderPassHint:
            agcls.evaluate_hresult(self.__dict__["_set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_text.COM_val), arg_optionalParameters.COM_val, byref(arg_indices.COM_val), arg_indicesOrderHint.COM_val, arg_renderPassHint.COM_val))

    @property
    def render_in_screen_space(self) -> bool:
        """Gets or sets whether the primitive is positioned and rendered in screen space coordinates."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_render_in_screen_space"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @render_in_screen_space.setter
    def render_in_screen_space(self, renderInScreenSpace:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(renderInScreenSpace) as arg_renderInScreenSpace:
            agcls.evaluate_hresult(self.__dict__["_set_render_in_screen_space"](arg_renderInScreenSpace.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{037722fb-c0e5-4052-b34d-60aa662b5d2b}", ITextBatchPrimitive)
agcls.AgTypeNameMap["ITextBatchPrimitive"] = ITextBatchPrimitive

class ITextBatchPrimitiveOptionalParameters(object):
    """Optional per-string and per-batch parameters for text batch primitive..."""
    _uuid = "{e18b012f-840d-4f32-8810-dd253c38ce7f}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_origin"] = _raise_uninitialized_error
        self.__dict__["_set_origin"] = _raise_uninitialized_error
        self.__dict__["_get_eye_offset"] = _raise_uninitialized_error
        self.__dict__["_set_eye_offset"] = _raise_uninitialized_error
        self.__dict__["_get_pixel_offset"] = _raise_uninitialized_error
        self.__dict__["_set_pixel_offset"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_string_length"] = _raise_uninitialized_error
        self.__dict__["_set_maximum_string_length"] = _raise_uninitialized_error
        self.__dict__["_set_origins"] = _raise_uninitialized_error
        self.__dict__["_set_eye_offsets"] = _raise_uninitialized_error
        self.__dict__["_set_pixel_offsets"] = _raise_uninitialized_error
        self.__dict__["_set_colors"] = _raise_uninitialized_error
        self.__dict__["_get_screen_space_rendering"] = _raise_uninitialized_error
        self.__dict__["_set_screen_space_rendering"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITextBatchPrimitiveOptionalParameters._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITextBatchPrimitiveOptionalParameters from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITextBatchPrimitiveOptionalParameters = agcom.GUID(ITextBatchPrimitiveOptionalParameters._uuid)
        vtable_offset_local = ITextBatchPrimitiveOptionalParameters._vtable_offset - 1
        self.__dict__["_get_origin"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveOptionalParameters, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_origin"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveOptionalParameters, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_eye_offset"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveOptionalParameters, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_eye_offset"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveOptionalParameters, vtable_offset_local+4, agcom.SAFEARRAY)
        self.__dict__["_get_pixel_offset"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveOptionalParameters, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_pixel_offset"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveOptionalParameters, vtable_offset_local+6, agcom.SAFEARRAY)
        self.__dict__["_get_maximum_string_length"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveOptionalParameters, vtable_offset_local+7, POINTER(agcom.INT))
        self.__dict__["_set_maximum_string_length"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveOptionalParameters, vtable_offset_local+8, agcom.INT)
        self.__dict__["_set_origins"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveOptionalParameters, vtable_offset_local+9, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_eye_offsets"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveOptionalParameters, vtable_offset_local+10, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_pixel_offsets"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveOptionalParameters, vtable_offset_local+11, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_colors"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveOptionalParameters, vtable_offset_local+12, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_screen_space_rendering"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveOptionalParameters, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_screen_space_rendering"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveOptionalParameters, vtable_offset_local+14, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITextBatchPrimitiveOptionalParameters.__dict__ and type(ITextBatchPrimitiveOptionalParameters.__dict__[attrname]) == property:
            return ITextBatchPrimitiveOptionalParameters.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITextBatchPrimitiveOptionalParameters.")
    
    @property
    def origin(self) -> "AgEStkGraphicsOrigin":
        """Gets or sets the per-batch origin, which is applied to each string in the text batch."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsOrigin) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_origin"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @origin.setter
    def origin(self, origin:"AgEStkGraphicsOrigin") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsOrigin, origin) as arg_origin:
            agcls.evaluate_hresult(self.__dict__["_set_origin"](arg_origin.COM_val))

    @property
    def eye_offset(self) -> list:
        """Gets or sets the per-batch eye offset, which is applied to each string in the text batch. The array contains the components of the offset arranged in the order x, y, z."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_eye_offset"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @eye_offset.setter
    def eye_offset(self, eyeOffset:list) -> None:
        with agmarshall.SAFEARRAY_arg(eyeOffset) as arg_eyeOffset:
            agcls.evaluate_hresult(self.__dict__["_set_eye_offset"](arg_eyeOffset.COM_val))

    @property
    def pixel_offset(self) -> list:
        """Gets or sets the per-batch pixel offset, which is applied to each string in the text batch. The array contains one x pixel offset followed by one y pixel offset."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_pixel_offset"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @pixel_offset.setter
    def pixel_offset(self, pixelOffset:list) -> None:
        with agmarshall.SAFEARRAY_arg(pixelOffset) as arg_pixelOffset:
            agcls.evaluate_hresult(self.__dict__["_set_pixel_offset"](arg_pixelOffset.COM_val))

    @property
    def maximum_string_length(self) -> int:
        """Gets or sets the maximum length of each string in the text batch."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_string_length"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @maximum_string_length.setter
    def maximum_string_length(self, maximumStringLength:int) -> None:
        with agmarshall.INT_arg(maximumStringLength) as arg_maximumStringLength:
            agcls.evaluate_hresult(self.__dict__["_set_maximum_string_length"](arg_maximumStringLength.COM_val))

    def set_origins(self, origins:list) -> None:
        """Defines a collection of origins, one for each string in the batch."""
        with agmarshall.SAFEARRAY_arg(origins) as arg_origins:
            agcls.evaluate_hresult(self.__dict__["_set_origins"](byref(arg_origins.COM_val)))

    def set_eye_offsets(self, eyeOffsets:list) -> None:
        """Defines a collection of eye offsets, one for each string in the batch."""
        with agmarshall.SAFEARRAY_arg(eyeOffsets) as arg_eyeOffsets:
            agcls.evaluate_hresult(self.__dict__["_set_eye_offsets"](byref(arg_eyeOffsets.COM_val)))

    def set_pixel_offsets(self, pixelOffsets:list) -> None:
        """Defines a collection of pixel offsets, one for each string in the batch."""
        with agmarshall.SAFEARRAY_arg(pixelOffsets) as arg_pixelOffsets:
            agcls.evaluate_hresult(self.__dict__["_set_pixel_offsets"](byref(arg_pixelOffsets.COM_val)))

    def set_colors(self, colors:list) -> None:
        """Defines a collection of colors, one for each string in the batch."""
        with agmarshall.SAFEARRAY_arg(colors) as arg_colors:
            agcls.evaluate_hresult(self.__dict__["_set_colors"](byref(arg_colors.COM_val)))

    @property
    def screen_space_rendering(self) -> bool:
        """Gets or sets a flag that informs the CTextBatchPrimitive to use rendering optimized for screen space text."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_screen_space_rendering"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @screen_space_rendering.setter
    def screen_space_rendering(self, screenSpaceRendering:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(screenSpaceRendering) as arg_screenSpaceRendering:
            agcls.evaluate_hresult(self.__dict__["_set_screen_space_rendering"](arg_screenSpaceRendering.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{e18b012f-840d-4f32-8810-dd253c38ce7f}", ITextBatchPrimitiveOptionalParameters)
agcls.AgTypeNameMap["ITextBatchPrimitiveOptionalParameters"] = ITextBatchPrimitiveOptionalParameters

class ITextOverlay(object):
    """A rectangular overlay that contains text."""
    _uuid = "{7d847a28-dfe3-4f2c-923b-683f0250c491}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_text"] = _raise_uninitialized_error
        self.__dict__["_set_text"] = _raise_uninitialized_error
        self.__dict__["_get_outline_color"] = _raise_uninitialized_error
        self.__dict__["_set_outline_color"] = _raise_uninitialized_error
        self.__dict__["_get_font"] = _raise_uninitialized_error
        self.__dict__["_set_font"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITextOverlay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITextOverlay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITextOverlay = agcom.GUID(ITextOverlay._uuid)
        vtable_offset_local = ITextOverlay._vtable_offset - 1
        self.__dict__["_get_text"] = IAGFUNCTYPE(pUnk, IID_ITextOverlay, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_text"] = IAGFUNCTYPE(pUnk, IID_ITextOverlay, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_outline_color"] = IAGFUNCTYPE(pUnk, IID_ITextOverlay, vtable_offset_local+3, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_outline_color"] = IAGFUNCTYPE(pUnk, IID_ITextOverlay, vtable_offset_local+4, agcom.OLE_COLOR)
        self.__dict__["_get_font"] = IAGFUNCTYPE(pUnk, IID_ITextOverlay, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_set_font"] = IAGFUNCTYPE(pUnk, IID_ITextOverlay, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITextOverlay.__dict__ and type(ITextOverlay.__dict__[attrname]) == property:
            return ITextOverlay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITextOverlay.")
    
    @property
    def text(self) -> str:
        r"""Sets the Text to be rendered to an overlay using newline characters ('\n') to mark the start of the next line in the text."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_text"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @text.setter
    def text(self, text:str) -> None:
        with agmarshall.BSTR_arg(text) as arg_text:
            agcls.evaluate_hresult(self.__dict__["_set_text"](arg_text.COM_val))

    @property
    def outline_color(self) -> agcolor.Color:
        """Gets or sets the text's outline color."""
        with agmarshall.OLE_COLOR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_outline_color"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @outline_color.setter
    def outline_color(self, outlineColor:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(outlineColor) as arg_outlineColor:
            agcls.evaluate_hresult(self.__dict__["_set_outline_color"](arg_outlineColor.COM_val))

    @property
    def font(self) -> "IGraphicsFont":
        """Get the graphics font used to style the text."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_font"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @font.setter
    def font(self, font:"IGraphicsFont") -> None:
        with agmarshall.AgInterface_in_arg(font, IGraphicsFont) as arg_font:
            agcls.evaluate_hresult(self.__dict__["_set_font"](arg_font.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7d847a28-dfe3-4f2c-923b-683f0250c491}", ITextOverlay)
agcls.AgTypeNameMap["ITextOverlay"] = ITextOverlay

class ITextureMatrix(object):
    """A 4 by 4 matrix applied to a texture coordinate."""
    _uuid = "{0a4c4c8f-0131-466f-99a5-1f41f9db403b}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_m11"] = _raise_uninitialized_error
        self.__dict__["_get_m12"] = _raise_uninitialized_error
        self.__dict__["_get_m13"] = _raise_uninitialized_error
        self.__dict__["_get_m14"] = _raise_uninitialized_error
        self.__dict__["_get_m21"] = _raise_uninitialized_error
        self.__dict__["_get_m22"] = _raise_uninitialized_error
        self.__dict__["_get_m23"] = _raise_uninitialized_error
        self.__dict__["_get_m24"] = _raise_uninitialized_error
        self.__dict__["_get_m31"] = _raise_uninitialized_error
        self.__dict__["_get_m32"] = _raise_uninitialized_error
        self.__dict__["_get_m33"] = _raise_uninitialized_error
        self.__dict__["_get_m34"] = _raise_uninitialized_error
        self.__dict__["_get_m41"] = _raise_uninitialized_error
        self.__dict__["_get_m42"] = _raise_uninitialized_error
        self.__dict__["_get_m43"] = _raise_uninitialized_error
        self.__dict__["_get_m44"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITextureMatrix._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITextureMatrix from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITextureMatrix = agcom.GUID(ITextureMatrix._uuid)
        vtable_offset_local = ITextureMatrix._vtable_offset - 1
        self.__dict__["_get_m11"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+1, POINTER(agcom.FLOAT))
        self.__dict__["_get_m12"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+2, POINTER(agcom.FLOAT))
        self.__dict__["_get_m13"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+3, POINTER(agcom.FLOAT))
        self.__dict__["_get_m14"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+4, POINTER(agcom.FLOAT))
        self.__dict__["_get_m21"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+5, POINTER(agcom.FLOAT))
        self.__dict__["_get_m22"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+6, POINTER(agcom.FLOAT))
        self.__dict__["_get_m23"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+7, POINTER(agcom.FLOAT))
        self.__dict__["_get_m24"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+8, POINTER(agcom.FLOAT))
        self.__dict__["_get_m31"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+9, POINTER(agcom.FLOAT))
        self.__dict__["_get_m32"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+10, POINTER(agcom.FLOAT))
        self.__dict__["_get_m33"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+11, POINTER(agcom.FLOAT))
        self.__dict__["_get_m34"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+12, POINTER(agcom.FLOAT))
        self.__dict__["_get_m41"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+13, POINTER(agcom.FLOAT))
        self.__dict__["_get_m42"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+14, POINTER(agcom.FLOAT))
        self.__dict__["_get_m43"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+15, POINTER(agcom.FLOAT))
        self.__dict__["_get_m44"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrix, vtable_offset_local+16, POINTER(agcom.FLOAT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITextureMatrix.__dict__ and type(ITextureMatrix.__dict__[attrname]) == property:
            return ITextureMatrix.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITextureMatrix.")
    
    @property
    def m11(self) -> float:
        """Gets the element in the first row, first column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m11"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def m12(self) -> float:
        """Gets the element in the first row, second column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m12"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def m13(self) -> float:
        """Gets the element in the first row, third column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m13"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def m14(self) -> float:
        """Gets the element in the first row, fourth column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m14"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def m21(self) -> float:
        """Gets the element in the second row, first column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m21"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def m22(self) -> float:
        """Gets the element in the second row, second column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m22"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def m23(self) -> float:
        """Gets the element in the second row, third column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m23"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def m24(self) -> float:
        """Gets the element in the second row, fourth column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m24"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def m31(self) -> float:
        """Gets the element in the third row, first column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m31"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def m32(self) -> float:
        """Gets the element in the third row, second column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m32"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def m33(self) -> float:
        """Gets the element in the third row, third column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m33"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def m34(self) -> float:
        """Gets the element in the third row, fourth column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m34"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def m41(self) -> float:
        """Gets the element in the fourth row, first column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m41"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def m42(self) -> float:
        """Gets the element in the fourth row, second column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m42"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def m43(self) -> float:
        """Gets the element in the fourth row, third column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m43"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def m44(self) -> float:
        """Gets the element in the fourth row, fourth column."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_m44"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{0a4c4c8f-0131-466f-99a5-1f41f9db403b}", ITextureMatrix)
agcls.AgTypeNameMap["ITextureMatrix"] = ITextureMatrix

class ITextureScreenOverlay(object):
    """A rectangular overlay that can be assigned a texture."""
    _uuid = "{4d09eb77-14cf-40a7-b7bb-130f4ddd60c6}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_texture"] = _raise_uninitialized_error
        self.__dict__["_set_texture"] = _raise_uninitialized_error
        self.__dict__["_get_texture_filter"] = _raise_uninitialized_error
        self.__dict__["_set_texture_filter"] = _raise_uninitialized_error
        self.__dict__["_get_maintain_aspect_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_maintain_aspect_ratio"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITextureScreenOverlay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITextureScreenOverlay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITextureScreenOverlay = agcom.GUID(ITextureScreenOverlay._uuid)
        vtable_offset_local = ITextureScreenOverlay._vtable_offset - 1
        self.__dict__["_get_texture"] = IAGFUNCTYPE(pUnk, IID_ITextureScreenOverlay, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_set_texture"] = IAGFUNCTYPE(pUnk, IID_ITextureScreenOverlay, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_get_texture_filter"] = IAGFUNCTYPE(pUnk, IID_ITextureScreenOverlay, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_set_texture_filter"] = IAGFUNCTYPE(pUnk, IID_ITextureScreenOverlay, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_get_maintain_aspect_ratio"] = IAGFUNCTYPE(pUnk, IID_ITextureScreenOverlay, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_maintain_aspect_ratio"] = IAGFUNCTYPE(pUnk, IID_ITextureScreenOverlay, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITextureScreenOverlay.__dict__ and type(ITextureScreenOverlay.__dict__[attrname]) == property:
            return ITextureScreenOverlay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITextureScreenOverlay.")
    
    @property
    def texture(self) -> "IRendererTexture2D":
        """Gets or sets the texture (image) to be drawn on the overlay. Textures can be obtained from textures."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_texture"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @texture.setter
    def texture(self, texture:"IRendererTexture2D") -> None:
        with agmarshall.AgInterface_in_arg(texture, IRendererTexture2D) as arg_texture:
            agcls.evaluate_hresult(self.__dict__["_set_texture"](arg_texture.COM_val))

    @property
    def texture_filter(self) -> "ITextureFilter2D":
        """Gets or sets the filter used for the texture associated with this overlay."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_texture_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @texture_filter.setter
    def texture_filter(self, textureFilter:"ITextureFilter2D") -> None:
        with agmarshall.AgInterface_in_arg(textureFilter, ITextureFilter2D) as arg_textureFilter:
            agcls.evaluate_hresult(self.__dict__["_set_texture_filter"](arg_textureFilter.COM_val))

    @property
    def maintain_aspect_ratio(self) -> "AgEStkGraphicsMaintainAspectRatio":
        """Gets or sets a value indicating whether the aspect ratio of the texture screen overlay is maintained or not."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMaintainAspectRatio) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maintain_aspect_ratio"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @maintain_aspect_ratio.setter
    def maintain_aspect_ratio(self, maintainAspectRatio:"AgEStkGraphicsMaintainAspectRatio") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsMaintainAspectRatio, maintainAspectRatio) as arg_maintainAspectRatio:
            agcls.evaluate_hresult(self.__dict__["_set_maintain_aspect_ratio"](arg_maintainAspectRatio.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4d09eb77-14cf-40a7-b7bb-130f4ddd60c6}", ITextureScreenOverlay)
agcls.AgTypeNameMap["ITextureScreenOverlay"] = ITextureScreenOverlay

class ITimeIntervalDisplayCondition(object):
    """Defines an inclusive time interval that determines when an object, such as a primitive, is rendered based on the current animation time ."""
    _uuid = "{2f0f3c32-c1d9-42a1-9422-8ecd2b9c1ad0}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_minimum_time"] = _raise_uninitialized_error
        self.__dict__["_set_minimum_time"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_time"] = _raise_uninitialized_error
        self.__dict__["_set_maximum_time"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeIntervalDisplayCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeIntervalDisplayCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeIntervalDisplayCondition = agcom.GUID(ITimeIntervalDisplayCondition._uuid)
        vtable_offset_local = ITimeIntervalDisplayCondition._vtable_offset - 1
        self.__dict__["_get_minimum_time"] = IAGFUNCTYPE(pUnk, IID_ITimeIntervalDisplayCondition, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_set_minimum_time"] = IAGFUNCTYPE(pUnk, IID_ITimeIntervalDisplayCondition, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_get_maximum_time"] = IAGFUNCTYPE(pUnk, IID_ITimeIntervalDisplayCondition, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_set_maximum_time"] = IAGFUNCTYPE(pUnk, IID_ITimeIntervalDisplayCondition, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeIntervalDisplayCondition.__dict__ and type(ITimeIntervalDisplayCondition.__dict__[attrname]) == property:
            return ITimeIntervalDisplayCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeIntervalDisplayCondition.")
    
    @property
    def minimum_time(self) -> "IDate":
        """Gets or sets the minimum time of the inclusive time interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_time"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @minimum_time.setter
    def minimum_time(self, minimumTime:"IDate") -> None:
        with agmarshall.AgInterface_in_arg(minimumTime, IDate) as arg_minimumTime:
            agcls.evaluate_hresult(self.__dict__["_set_minimum_time"](arg_minimumTime.COM_val))

    @property
    def maximum_time(self) -> "IDate":
        """Gets or sets the maximum time of the inclusive time interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_time"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @maximum_time.setter
    def maximum_time(self, maximumTime:"IDate") -> None:
        with agmarshall.AgInterface_in_arg(maximumTime, IDate) as arg_maximumTime:
            agcls.evaluate_hresult(self.__dict__["_set_maximum_time"](arg_maximumTime.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2f0f3c32-c1d9-42a1-9422-8ecd2b9c1ad0}", ITimeIntervalDisplayCondition)
agcls.AgTypeNameMap["ITimeIntervalDisplayCondition"] = ITimeIntervalDisplayCondition

class ITriangleMeshPrimitive(object):
    """Renders a triangle mesh in the 3D scene. Examples of triangle meshes includes polygons on the globe (e.g. states or countries), terrain and imagery extents, ellipses, and extrusions."""
    _uuid = "{b878e10c-0fc9-446e-88ba-1e1088970150}"
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_wireframe"] = _raise_uninitialized_error
        self.__dict__["_set_wireframe"] = _raise_uninitialized_error
        self.__dict__["_get_render_back_then_front_faces"] = _raise_uninitialized_error
        self.__dict__["_set_render_back_then_front_faces"] = _raise_uninitialized_error
        self.__dict__["_get_lighting"] = _raise_uninitialized_error
        self.__dict__["_set_lighting"] = _raise_uninitialized_error
        self.__dict__["_get_triangle_winding_order"] = _raise_uninitialized_error
        self.__dict__["_set_triangle_winding_order"] = _raise_uninitialized_error
        self.__dict__["_get_cull_face"] = _raise_uninitialized_error
        self.__dict__["_set_cull_face"] = _raise_uninitialized_error
        self.__dict__["_get_shade_model"] = _raise_uninitialized_error
        self.__dict__["_set_shade_model"] = _raise_uninitialized_error
        self.__dict__["_get_texture"] = _raise_uninitialized_error
        self.__dict__["_set_texture"] = _raise_uninitialized_error
        self.__dict__["_get_texture_filter"] = _raise_uninitialized_error
        self.__dict__["_set_texture_filter"] = _raise_uninitialized_error
        self.__dict__["_get_set_hint"] = _raise_uninitialized_error
        self.__dict__["_set"] = _raise_uninitialized_error
        self.__dict__["_set_with_optional_parameters"] = _raise_uninitialized_error
        self.__dict__["_set_triangulator"] = _raise_uninitialized_error
        self.__dict__["_get_central_body_clipped"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_clipped"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITriangleMeshPrimitive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITriangleMeshPrimitive from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITriangleMeshPrimitive = agcom.GUID(ITriangleMeshPrimitive._uuid)
        vtable_offset_local = ITriangleMeshPrimitive._vtable_offset - 1
        self.__dict__["_get_wireframe"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_wireframe"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_render_back_then_front_faces"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_render_back_then_front_faces"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_lighting"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_lighting"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_triangle_winding_order"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_triangle_winding_order"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_cull_face"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_cull_face"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_shade_model"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_shade_model"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_texture"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_set_texture"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+14, agcom.PVOID)
        self.__dict__["_get_texture_filter"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_set_texture_filter"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+16, agcom.PVOID)
        self.__dict__["_get_set_hint"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+18, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_with_optional_parameters"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+19, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.PVOID)
        self.__dict__["_set_triangulator"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+20, agcom.PVOID)
        self.__dict__["_get_central_body_clipped"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_central_body_clipped"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitive, vtable_offset_local+22, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITriangleMeshPrimitive.__dict__ and type(ITriangleMeshPrimitive.__dict__[attrname]) == property:
            return ITriangleMeshPrimitive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITriangleMeshPrimitive.")
    
    @property
    def wireframe(self) -> bool:
        """Gets or sets whether the primitive is rendered in wireframe. This is useful for debugging."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_wireframe"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @wireframe.setter
    def wireframe(self, wireframe:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(wireframe) as arg_wireframe:
            agcls.evaluate_hresult(self.__dict__["_set_wireframe"](arg_wireframe.COM_val))

    @property
    def render_back_then_front_faces(self) -> bool:
        """Gets or sets whether the primitive is rendered in two passes to improve the visual quality for translucent, convex meshes."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_render_back_then_front_faces"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @render_back_then_front_faces.setter
    def render_back_then_front_faces(self, renderBackThenFrontFaces:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(renderBackThenFrontFaces) as arg_renderBackThenFrontFaces:
            agcls.evaluate_hresult(self.__dict__["_set_render_back_then_front_faces"](arg_renderBackThenFrontFaces.COM_val))

    @property
    def lighting(self) -> bool:
        """Gets or sets whether the primitive is lit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_lighting"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @lighting.setter
    def lighting(self, lighting:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(lighting) as arg_lighting:
            agcls.evaluate_hresult(self.__dict__["_set_lighting"](arg_lighting.COM_val))

    @property
    def triangle_winding_order(self) -> "AgEStkGraphicsWindingOrder":
        """Gets or sets the orientation of front-facing triangles. This is used in combination with cull face for culling."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_triangle_winding_order"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @triangle_winding_order.setter
    def triangle_winding_order(self, triangleWindingOrder:"AgEStkGraphicsWindingOrder") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder, triangleWindingOrder) as arg_triangleWindingOrder:
            agcls.evaluate_hresult(self.__dict__["_set_triangle_winding_order"](arg_triangleWindingOrder.COM_val))

    @property
    def cull_face(self) -> "AgEStkGraphicsCullFace":
        """Gets or sets whether front and/or back-facing triangles may be culled. This is used in combination with triangle winding order for culling."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsCullFace) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_cull_face"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @cull_face.setter
    def cull_face(self, cullFace:"AgEStkGraphicsCullFace") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsCullFace, cullFace) as arg_cullFace:
            agcls.evaluate_hresult(self.__dict__["_set_cull_face"](arg_cullFace.COM_val))

    @property
    def shade_model(self) -> "AgEStkGraphicsRendererShadeModel":
        """Gets or sets the shading model for the mesh."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsRendererShadeModel) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_shade_model"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @shade_model.setter
    def shade_model(self, shadeModel:"AgEStkGraphicsRendererShadeModel") -> None:
        with agmarshall.AgEnum_arg(AgEStkGraphicsRendererShadeModel, shadeModel) as arg_shadeModel:
            agcls.evaluate_hresult(self.__dict__["_set_shade_model"](arg_shadeModel.COM_val))

    @property
    def texture(self) -> "IRendererTexture2D":
        """Gets or sets the texture to be drawn on the triangle mesh. Textures can be obtained from textures."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_texture"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @texture.setter
    def texture(self, texture:"IRendererTexture2D") -> None:
        with agmarshall.AgInterface_in_arg(texture, IRendererTexture2D) as arg_texture:
            agcls.evaluate_hresult(self.__dict__["_set_texture"](arg_texture.COM_val))

    @property
    def texture_filter(self) -> "ITextureFilter2D":
        """Gets or sets the filter used for the texture associated with this triangle mesh."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_texture_filter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @texture_filter.setter
    def texture_filter(self, textureFilter:"ITextureFilter2D") -> None:
        with agmarshall.AgInterface_in_arg(textureFilter, ITextureFilter2D) as arg_textureFilter:
            agcls.evaluate_hresult(self.__dict__["_set_texture_filter"](arg_textureFilter.COM_val))

    @property
    def set_hint(self) -> "AgEStkGraphicsSetHint":
        """Gets the primitive's set hint. See the Set Hint Performance Overview for selecting an appropriate value to construct the primitive with."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSetHint) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_set_hint"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def set(self, positions:list, normals:list, indices:list) -> None:
        """Defines the triangle mesh using an indexed triangle list specified by positions, normals, and indices. The mesh is rendered in the primitive's reference frame."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(normals) as arg_normals, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices:
            agcls.evaluate_hresult(self.__dict__["_set"](byref(arg_positions.COM_val), byref(arg_normals.COM_val), byref(arg_indices.COM_val)))

    def set_with_optional_parameters(self, positions:list, normals:list, indices:list, optionalParameters:"ITriangleMeshPrimitiveOptionalParameters") -> None:
        """Defines the triangle mesh using an indexed triangle list specified by positions, normals, indices, and optionalParameters. The mesh is rendered in the primitive's reference frame."""
        with agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(normals) as arg_normals, \
             agmarshall.SAFEARRAY_arg(indices) as arg_indices, \
             agmarshall.AgInterface_in_arg(optionalParameters, ITriangleMeshPrimitiveOptionalParameters) as arg_optionalParameters:
            agcls.evaluate_hresult(self.__dict__["_set_with_optional_parameters"](byref(arg_positions.COM_val), byref(arg_normals.COM_val), byref(arg_indices.COM_val), arg_optionalParameters.COM_val))

    def set_triangulator(self, triangulator:"ITriangulatorResult") -> None:
        """Defines the triangle mesh using the specified triangulator. The mesh is rendered in the primitive's reference frame."""
        with agmarshall.AgInterface_in_arg(triangulator, ITriangulatorResult) as arg_triangulator:
            agcls.evaluate_hresult(self.__dict__["_set_triangulator"](arg_triangulator.COM_val))

    @property
    def central_body_clipped(self) -> bool:
        """Gets or sets whether individual points will be clipped by the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_clipped"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @central_body_clipped.setter
    def central_body_clipped(self, centralBodyClipped:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(centralBodyClipped) as arg_centralBodyClipped:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_clipped"](arg_centralBodyClipped.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{b878e10c-0fc9-446e-88ba-1e1088970150}", ITriangleMeshPrimitive)
agcls.AgTypeNameMap["ITriangleMeshPrimitive"] = ITriangleMeshPrimitive

class ITriangleMeshPrimitiveOptionalParameters(object):
    """Optional parameters for triangle mesh primitive..."""
    _uuid = "{881b260c-4a26-4fb7-9fec-779b3c540a94}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_set_texture_coordinates"] = _raise_uninitialized_error
        self.__dict__["_set_per_vertex_colors"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITriangleMeshPrimitiveOptionalParameters._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITriangleMeshPrimitiveOptionalParameters from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITriangleMeshPrimitiveOptionalParameters = agcom.GUID(ITriangleMeshPrimitiveOptionalParameters._uuid)
        vtable_offset_local = ITriangleMeshPrimitiveOptionalParameters._vtable_offset - 1
        self.__dict__["_set_texture_coordinates"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitiveOptionalParameters, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_per_vertex_colors"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitiveOptionalParameters, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITriangleMeshPrimitiveOptionalParameters.__dict__ and type(ITriangleMeshPrimitiveOptionalParameters.__dict__[attrname]) == property:
            return ITriangleMeshPrimitiveOptionalParameters.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITriangleMeshPrimitiveOptionalParameters.")
    
    def set_texture_coordinates(self, textureCoordinates:list) -> None:
        """Defines a collection of texture coordinates."""
        with agmarshall.SAFEARRAY_arg(textureCoordinates) as arg_textureCoordinates:
            agcls.evaluate_hresult(self.__dict__["_set_texture_coordinates"](byref(arg_textureCoordinates.COM_val)))

    def set_per_vertex_colors(self, colors:list) -> None:
        """Defines a collection of colors."""
        with agmarshall.SAFEARRAY_arg(colors) as arg_colors:
            agcls.evaluate_hresult(self.__dict__["_set_per_vertex_colors"](byref(arg_colors.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{881b260c-4a26-4fb7-9fec-779b3c540a94}", ITriangleMeshPrimitiveOptionalParameters)
agcls.AgTypeNameMap["ITriangleMeshPrimitiveOptionalParameters"] = ITriangleMeshPrimitiveOptionalParameters

class IVectorPrimitive(object):
    """Renders a vector in the 3D scene. A vector is defined by a source (given by an ISystem) and a direction (given by an IVector or IPoint). Length is auto-calculated or can be set separately."""
    _uuid = "{8244e37a-140a-40a8-9554-37dc0be9bd1b}"
    _num_methods = 28
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_lighting"] = _raise_uninitialized_error
        self.__dict__["_set_lighting"] = _raise_uninitialized_error
        self.__dict__["_get_label"] = _raise_uninitialized_error
        self.__dict__["_set_label"] = _raise_uninitialized_error
        self.__dict__["_get_display_label"] = _raise_uninitialized_error
        self.__dict__["_set_display_label"] = _raise_uninitialized_error
        self.__dict__["_get_display_magnitude"] = _raise_uninitialized_error
        self.__dict__["_set_display_magnitude"] = _raise_uninitialized_error
        self.__dict__["_get_display_ra_dec"] = _raise_uninitialized_error
        self.__dict__["_set_display_ra_dec"] = _raise_uninitialized_error
        self.__dict__["_get_display_trace"] = _raise_uninitialized_error
        self.__dict__["_set_display_trace"] = _raise_uninitialized_error
        self.__dict__["_get_display_sweep"] = _raise_uninitialized_error
        self.__dict__["_set_display_sweep"] = _raise_uninitialized_error
        self.__dict__["_get_display_lines"] = _raise_uninitialized_error
        self.__dict__["_set_display_lines"] = _raise_uninitialized_error
        self.__dict__["_get_persistence_width"] = _raise_uninitialized_error
        self.__dict__["_set_persistence_width"] = _raise_uninitialized_error
        self.__dict__["_get_fade_persistence"] = _raise_uninitialized_error
        self.__dict__["_set_fade_persistence"] = _raise_uninitialized_error
        self.__dict__["_get_persistence_duration"] = _raise_uninitialized_error
        self.__dict__["_set_persistence_duration"] = _raise_uninitialized_error
        self.__dict__["_get_length"] = _raise_uninitialized_error
        self.__dict__["_set_length"] = _raise_uninitialized_error
        self.__dict__["_get_width"] = _raise_uninitialized_error
        self.__dict__["_set_width"] = _raise_uninitialized_error
        self.__dict__["_get_true_scale"] = _raise_uninitialized_error
        self.__dict__["_set_true_scale"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorPrimitive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorPrimitive from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorPrimitive = agcom.GUID(IVectorPrimitive._uuid)
        vtable_offset_local = IVectorPrimitive._vtable_offset - 1
        self.__dict__["_get_lighting"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_lighting"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_label"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_label"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_display_label"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_label"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_display_magnitude"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_magnitude"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_display_ra_dec"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_ra_dec"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_display_trace"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_trace"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_get_display_sweep"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_sweep"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+14, agcom.VARIANT_BOOL)
        self.__dict__["_get_display_lines"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_display_lines"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_get_persistence_width"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_persistence_width"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_fade_persistence"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_fade_persistence"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__["_get_persistence_duration"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_persistence_duration"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_length"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_length"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_width"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_width"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_true_scale"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+27, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_true_scale"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitive, vtable_offset_local+28, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorPrimitive.__dict__ and type(IVectorPrimitive.__dict__[attrname]) == property:
            return IVectorPrimitive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorPrimitive.")
    
    @property
    def lighting(self) -> bool:
        """Gets or Sets whether the primitive is lit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_lighting"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @lighting.setter
    def lighting(self, lighting:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(lighting) as arg_lighting:
            agcls.evaluate_hresult(self.__dict__["_set_lighting"](arg_lighting.COM_val))

    @property
    def label(self) -> str:
        """Gets or Sets the a user-defined label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_label"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @label.setter
    def label(self, label:str) -> None:
        with agmarshall.BSTR_arg(label) as arg_label:
            agcls.evaluate_hresult(self.__dict__["_set_label"](arg_label.COM_val))

    @property
    def display_label(self) -> bool:
        """Gets or Sets whether the vector's label is displayed."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_label"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_label.setter
    def display_label(self, displayLabel:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displayLabel) as arg_displayLabel:
            agcls.evaluate_hresult(self.__dict__["_set_display_label"](arg_displayLabel.COM_val))

    @property
    def display_magnitude(self) -> bool:
        """Gets or Sets whether the vector's magnitude is displayed. Formatter controls unit conversions."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_magnitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_magnitude.setter
    def display_magnitude(self, displayMagnitude:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displayMagnitude) as arg_displayMagnitude:
            agcls.evaluate_hresult(self.__dict__["_set_display_magnitude"](arg_displayMagnitude.COM_val))

    @property
    def display_ra_dec(self) -> bool:
        """Gets or Sets whether the vector's RA-Dec is displayed. Formatter controls unit conversions."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_ra_dec"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_ra_dec.setter
    def display_ra_dec(self, displayRADec:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displayRADec) as arg_displayRADec:
            agcls.evaluate_hresult(self.__dict__["_set_display_ra_dec"](arg_displayRADec.COM_val))

    @property
    def display_trace(self) -> bool:
        """Gets or Sets whether the persistence trace (points) is displayed."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_trace"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_trace.setter
    def display_trace(self, displayTrace:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displayTrace) as arg_displayTrace:
            agcls.evaluate_hresult(self.__dict__["_set_display_trace"](arg_displayTrace.COM_val))

    @property
    def display_sweep(self) -> bool:
        """Gets or Sets whether the persistence sweep (triangles) is displayed."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_sweep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_sweep.setter
    def display_sweep(self, displaySweep:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displaySweep) as arg_displaySweep:
            agcls.evaluate_hresult(self.__dict__["_set_display_sweep"](arg_displaySweep.COM_val))

    @property
    def display_lines(self) -> bool:
        """Gets or Sets whether persistence lines are displayed."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_lines"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @display_lines.setter
    def display_lines(self, displayLines:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(displayLines) as arg_displayLines:
            agcls.evaluate_hresult(self.__dict__["_set_display_lines"](arg_displayLines.COM_val))

    @property
    def persistence_width(self) -> float:
        """Gets or Sets persistence point/line width."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_persistence_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @persistence_width.setter
    def persistence_width(self, persistenceWidth:float) -> None:
        with agmarshall.DOUBLE_arg(persistenceWidth) as arg_persistenceWidth:
            agcls.evaluate_hresult(self.__dict__["_set_persistence_width"](arg_persistenceWidth.COM_val))

    @property
    def fade_persistence(self) -> bool:
        """Gets or Sets whether the persistence path should fade over time."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_fade_persistence"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @fade_persistence.setter
    def fade_persistence(self, fadePersistence:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(fadePersistence) as arg_fadePersistence:
            agcls.evaluate_hresult(self.__dict__["_set_fade_persistence"](arg_fadePersistence.COM_val))

    @property
    def persistence_duration(self) -> float:
        """Gets or Sets the maximum duration of the persistence path."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_persistence_duration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @persistence_duration.setter
    def persistence_duration(self, persistenceDuration:float) -> None:
        with agmarshall.DOUBLE_arg(persistenceDuration) as arg_persistenceDuration:
            agcls.evaluate_hresult(self.__dict__["_set_persistence_duration"](arg_persistenceDuration.COM_val))

    @property
    def length(self) -> float:
        """Gets or Sets the vector's source-to-arrow-tip length."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_length"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @length.setter
    def length(self, length:float) -> None:
        with agmarshall.DOUBLE_arg(length) as arg_length:
            agcls.evaluate_hresult(self.__dict__["_set_length"](arg_length.COM_val))

    @property
    def width(self) -> float:
        """Gets or Sets the vector's width in pixels. As the camera distances changes from this primitive, the geometry will autoscale to maintain this thickness."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_width"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @width.setter
    def width(self, width:float) -> None:
        with agmarshall.DOUBLE_arg(width) as arg_width:
            agcls.evaluate_hresult(self.__dict__["_set_width"](arg_width.COM_val))

    @property
    def true_scale(self) -> bool:
        """Gets or Sets whether vector's 'true scale' length (based on how the primitive was created) should be used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_true_scale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @true_scale.setter
    def true_scale(self, trueScale:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(trueScale) as arg_trueScale:
            agcls.evaluate_hresult(self.__dict__["_set_true_scale"](arg_trueScale.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8244e37a-140a-40a8-9554-37dc0be9bd1b}", IVectorPrimitive)
agcls.AgTypeNameMap["IVectorPrimitive"] = IVectorPrimitive

class IBoxTriangulatorInitializer(object):
    """Triangulates a box. It is recommended to visualize the box using a solid primitive. Although, if only the fill is desired for visualization, a triangle mesh primitive with render back then front faces set to true can be used..."""
    _uuid = "{3d49da39-dbe0-4ef9-b589-bc0cf5e78085}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_compute"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBoxTriangulatorInitializer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBoxTriangulatorInitializer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBoxTriangulatorInitializer = agcom.GUID(IBoxTriangulatorInitializer._uuid)
        vtable_offset_local = IBoxTriangulatorInitializer._vtable_offset - 1
        self.__dict__["_compute"] = IAGFUNCTYPE(pUnk, IID_IBoxTriangulatorInitializer, vtable_offset_local+1, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBoxTriangulatorInitializer.__dict__ and type(IBoxTriangulatorInitializer.__dict__[attrname]) == property:
            return IBoxTriangulatorInitializer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBoxTriangulatorInitializer.")
    
    def compute(self, size:list) -> "ISolidTriangulatorResult":
        """Computes the triangulation for a box of the specified size, centered at the origin."""
        with agmarshall.SAFEARRAY_arg(size) as arg_size, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute"](byref(arg_size.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{3d49da39-dbe0-4ef9-b589-bc0cf5e78085}", IBoxTriangulatorInitializer)
agcls.AgTypeNameMap["IBoxTriangulatorInitializer"] = IBoxTriangulatorInitializer

class ICylinderTriangulatorInitializer(object):
    """Triangulates a cylinder. It is recommended to visualize the cylinder using a solid primitive. Although, if only the fill is desired for visualization, a triangle mesh primitive with render back then front faces set to true can be used..."""
    _uuid = "{ee39d933-ce2c-4087-8c8a-f38ebe83842f}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_create_simple"] = _raise_uninitialized_error
        self.__dict__["_compute"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICylinderTriangulatorInitializer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICylinderTriangulatorInitializer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICylinderTriangulatorInitializer = agcom.GUID(ICylinderTriangulatorInitializer._uuid)
        vtable_offset_local = ICylinderTriangulatorInitializer._vtable_offset - 1
        self.__dict__["_create_simple"] = IAGFUNCTYPE(pUnk, IID_ICylinderTriangulatorInitializer, vtable_offset_local+1, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute"] = IAGFUNCTYPE(pUnk, IID_ICylinderTriangulatorInitializer, vtable_offset_local+2, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.INT, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICylinderTriangulatorInitializer.__dict__ and type(ICylinderTriangulatorInitializer.__dict__[attrname]) == property:
            return ICylinderTriangulatorInitializer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICylinderTriangulatorInitializer.")
    
    def create_simple(self, length:float, radius:float) -> "ISolidTriangulatorResult":
        """Computes the triangulation for a cylinder centered at the origin."""
        with agmarshall.DOUBLE_arg(length) as arg_length, \
             agmarshall.DOUBLE_arg(radius) as arg_radius, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_create_simple"](arg_length.COM_val, arg_radius.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute(self, length:float, bottomRadius:float, topRadius:float, slices:int, cylinderFill:"AgEStkGraphicsCylinderFill") -> "ISolidTriangulatorResult":
        """Computes the triangulation for a cylinder centered at the origin."""
        with agmarshall.DOUBLE_arg(length) as arg_length, \
             agmarshall.DOUBLE_arg(bottomRadius) as arg_bottomRadius, \
             agmarshall.DOUBLE_arg(topRadius) as arg_topRadius, \
             agmarshall.INT_arg(slices) as arg_slices, \
             agmarshall.AgEnum_arg(AgEStkGraphicsCylinderFill, cylinderFill) as arg_cylinderFill, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute"](arg_length.COM_val, arg_bottomRadius.COM_val, arg_topRadius.COM_val, arg_slices.COM_val, arg_cylinderFill.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{ee39d933-ce2c-4087-8c8a-f38ebe83842f}", ICylinderTriangulatorInitializer)
agcls.AgTypeNameMap["ICylinderTriangulatorInitializer"] = ICylinderTriangulatorInitializer

class IEllipsoidTriangulatorInitializer(object):
    """Triangulates an ellipsoid. It is recommended to visualize the ellipsoid using a solid primitive. Although, if only the fill is desired for visualization, a triangle mesh primitive with render back then front faces set to true can be used..."""
    _uuid = "{8c50173b-e1e0-4321-aeac-5c75e4ef323f}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_compute_simple"] = _raise_uninitialized_error
        self.__dict__["_compute"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEllipsoidTriangulatorInitializer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEllipsoidTriangulatorInitializer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEllipsoidTriangulatorInitializer = agcom.GUID(IEllipsoidTriangulatorInitializer._uuid)
        vtable_offset_local = IEllipsoidTriangulatorInitializer._vtable_offset - 1
        self.__dict__["_compute_simple"] = IAGFUNCTYPE(pUnk, IID_IEllipsoidTriangulatorInitializer, vtable_offset_local+1, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_compute"] = IAGFUNCTYPE(pUnk, IID_IEllipsoidTriangulatorInitializer, vtable_offset_local+2, POINTER(agcom.SAFEARRAY), agcom.INT, agcom.INT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEllipsoidTriangulatorInitializer.__dict__ and type(IEllipsoidTriangulatorInitializer.__dict__[attrname]) == property:
            return IEllipsoidTriangulatorInitializer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEllipsoidTriangulatorInitializer.")
    
    def compute_simple(self, radii:list) -> "ISolidTriangulatorResult":
        """Computes the triangulation for an ellipsoid with the specified radii, centered at the origin, using 32 slices and 16 stacks."""
        with agmarshall.SAFEARRAY_arg(radii) as arg_radii, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_simple"](byref(arg_radii.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute(self, radii:list, slices:int, stacks:int) -> "ISolidTriangulatorResult":
        """Computes the triangulation for an ellipsoid with the specified radii, centered at the origin."""
        with agmarshall.SAFEARRAY_arg(radii) as arg_radii, \
             agmarshall.INT_arg(slices) as arg_slices, \
             agmarshall.INT_arg(stacks) as arg_stacks, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute"](byref(arg_radii.COM_val), arg_slices.COM_val, arg_stacks.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8c50173b-e1e0-4321-aeac-5c75e4ef323f}", IEllipsoidTriangulatorInitializer)
agcls.AgTypeNameMap["IEllipsoidTriangulatorInitializer"] = IEllipsoidTriangulatorInitializer

class IExtrudedPolylineTriangulatorInitializer(object):
    """Triangulates a polyline into an extrusion with bottom and top boundaries."""
    _uuid = "{b6b79988-0b1f-4b6e-8970-ff86b6d94b36}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_compute"] = _raise_uninitialized_error
        self.__dict__["_compute_with_winding_order"] = _raise_uninitialized_error
        self.__dict__["_compute_cartographic"] = _raise_uninitialized_error
        self.__dict__["_compute_cartographic_with_winding_order"] = _raise_uninitialized_error
        self.__dict__["_compute_with_altitudes"] = _raise_uninitialized_error
        self.__dict__["_compute_with_altitudes_and_winding_order"] = _raise_uninitialized_error
        self.__dict__["_compute_cartographic_with_altitudes"] = _raise_uninitialized_error
        self.__dict__["_compute_cartographic_with_altitudes_and_winding_order"] = _raise_uninitialized_error
        self.__dict__["_compute_single_constant_altitude"] = _raise_uninitialized_error
        self.__dict__["_compute_single_constant_altitude_with_winding_order"] = _raise_uninitialized_error
        self.__dict__["_compute_single_constant_altitude_cartographic"] = _raise_uninitialized_error
        self.__dict__["_compute_single_constant_altitude_cartographic_with_winding_order"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IExtrudedPolylineTriangulatorInitializer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IExtrudedPolylineTriangulatorInitializer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IExtrudedPolylineTriangulatorInitializer = agcom.GUID(IExtrudedPolylineTriangulatorInitializer._uuid)
        vtable_offset_local = IExtrudedPolylineTriangulatorInitializer._vtable_offset - 1
        self.__dict__["_compute"] = IAGFUNCTYPE(pUnk, IID_IExtrudedPolylineTriangulatorInitializer, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_compute_with_winding_order"] = IAGFUNCTYPE(pUnk, IID_IExtrudedPolylineTriangulatorInitializer, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_compute_cartographic"] = IAGFUNCTYPE(pUnk, IID_IExtrudedPolylineTriangulatorInitializer, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_compute_cartographic_with_winding_order"] = IAGFUNCTYPE(pUnk, IID_IExtrudedPolylineTriangulatorInitializer, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_compute_with_altitudes"] = IAGFUNCTYPE(pUnk, IID_IExtrudedPolylineTriangulatorInitializer, vtable_offset_local+5, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_with_altitudes_and_winding_order"] = IAGFUNCTYPE(pUnk, IID_IExtrudedPolylineTriangulatorInitializer, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_compute_cartographic_with_altitudes"] = IAGFUNCTYPE(pUnk, IID_IExtrudedPolylineTriangulatorInitializer, vtable_offset_local+7, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_cartographic_with_altitudes_and_winding_order"] = IAGFUNCTYPE(pUnk, IID_IExtrudedPolylineTriangulatorInitializer, vtable_offset_local+8, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_compute_single_constant_altitude"] = IAGFUNCTYPE(pUnk, IID_IExtrudedPolylineTriangulatorInitializer, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_single_constant_altitude_with_winding_order"] = IAGFUNCTYPE(pUnk, IID_IExtrudedPolylineTriangulatorInitializer, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_compute_single_constant_altitude_cartographic"] = IAGFUNCTYPE(pUnk, IID_IExtrudedPolylineTriangulatorInitializer, vtable_offset_local+11, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_single_constant_altitude_cartographic_with_winding_order"] = IAGFUNCTYPE(pUnk, IID_IExtrudedPolylineTriangulatorInitializer, vtable_offset_local+12, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IExtrudedPolylineTriangulatorInitializer.__dict__ and type(IExtrudedPolylineTriangulatorInitializer.__dict__[attrname]) == property:
            return IExtrudedPolylineTriangulatorInitializer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IExtrudedPolylineTriangulatorInitializer.")
    
    def compute(self, centralBody:str, bottomPositions:list, topPositions:list) -> "IExtrudedPolylineTriangulatorResult":
        """Computes an extrusion between bottomPositions and topPositions on the specified centralBody. This is equivalent to calling Compute with a positionsWindingOrder of compute."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(bottomPositions) as arg_bottomPositions, \
             agmarshall.SAFEARRAY_arg(topPositions) as arg_topPositions, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute"](arg_centralBody.COM_val, byref(arg_bottomPositions.COM_val), byref(arg_topPositions.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_with_winding_order(self, centralBody:str, bottomPositions:list, topPositions:list, positionsWindingOrder:"AgEStkGraphicsWindingOrder") -> "IExtrudedPolylineTriangulatorResult":
        """Computes an extrusion between bottomPositions and topPositions on the specified centralBody."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(bottomPositions) as arg_bottomPositions, \
             agmarshall.SAFEARRAY_arg(topPositions) as arg_topPositions, \
             agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder, positionsWindingOrder) as arg_positionsWindingOrder, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_with_winding_order"](arg_centralBody.COM_val, byref(arg_bottomPositions.COM_val), byref(arg_topPositions.COM_val), arg_positionsWindingOrder.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_cartographic(self, centralBody:str, bottomPositions:list, topPositions:list) -> "IExtrudedPolylineTriangulatorResult":
        """For convenience. Computes an extrusion between bottomPositions and topPositions on the specified centralBody using cartographic positions. This is equivalent to converting each position in bottomPositions and topPositions to cartesian and calling Compute"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(bottomPositions) as arg_bottomPositions, \
             agmarshall.SAFEARRAY_arg(topPositions) as arg_topPositions, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_cartographic"](arg_centralBody.COM_val, byref(arg_bottomPositions.COM_val), byref(arg_topPositions.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_cartographic_with_winding_order(self, centralBody:str, bottomPositions:list, topPositions:list, positionsWindingOrder:"AgEStkGraphicsWindingOrder") -> "IExtrudedPolylineTriangulatorResult":
        """For convenience. Computes an extrusion between bottomPositions and topPositions on the specified centralBody using cartographic positions. This is equivalent to converting each position in bottomPositions and topPositions to cartesian and calling Compute"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(bottomPositions) as arg_bottomPositions, \
             agmarshall.SAFEARRAY_arg(topPositions) as arg_topPositions, \
             agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder, positionsWindingOrder) as arg_positionsWindingOrder, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_cartographic_with_winding_order"](arg_centralBody.COM_val, byref(arg_bottomPositions.COM_val), byref(arg_topPositions.COM_val), arg_positionsWindingOrder.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_with_altitudes(self, centralBody:str, positions:list, bottomAltitude:float, topAltitude:float) -> "IExtrudedPolylineTriangulatorResult":
        """Computes an extrusion of positions on the specified centralBody with a constant bottomAltitude and topAltitude. This is equivalent to calling Compute with a positionsWindingOrder of compute."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.DOUBLE_arg(bottomAltitude) as arg_bottomAltitude, \
             agmarshall.DOUBLE_arg(topAltitude) as arg_topAltitude, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_with_altitudes"](arg_centralBody.COM_val, byref(arg_positions.COM_val), arg_bottomAltitude.COM_val, arg_topAltitude.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_with_altitudes_and_winding_order(self, centralBody:str, positions:list, bottomAltitude:float, topAltitude:float, positionsWindingOrder:"AgEStkGraphicsWindingOrder") -> "IExtrudedPolylineTriangulatorResult":
        """Computes an extrusion of positions on the specified centralBody with a constant bottomAltitude and topAltitude."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.DOUBLE_arg(bottomAltitude) as arg_bottomAltitude, \
             agmarshall.DOUBLE_arg(topAltitude) as arg_topAltitude, \
             agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder, positionsWindingOrder) as arg_positionsWindingOrder, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_with_altitudes_and_winding_order"](arg_centralBody.COM_val, byref(arg_positions.COM_val), arg_bottomAltitude.COM_val, arg_topAltitude.COM_val, arg_positionsWindingOrder.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_cartographic_with_altitudes(self, centralBody:str, positions:list, bottomAltitude:float, topAltitude:float) -> "IExtrudedPolylineTriangulatorResult":
        """For convenience. Computes an extrusion of positions on the specified centralBody with a constant bottomAltitude and topAltitude using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Compute"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.DOUBLE_arg(bottomAltitude) as arg_bottomAltitude, \
             agmarshall.DOUBLE_arg(topAltitude) as arg_topAltitude, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_cartographic_with_altitudes"](arg_centralBody.COM_val, byref(arg_positions.COM_val), arg_bottomAltitude.COM_val, arg_topAltitude.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_cartographic_with_altitudes_and_winding_order(self, centralBody:str, positions:list, bottomAltitude:float, topAltitude:float, positionsWindingOrder:"AgEStkGraphicsWindingOrder") -> "IExtrudedPolylineTriangulatorResult":
        """For convenience. Computes an extrusion of positions on the specified centralBody with a constant bottomAltitude and topAltitude using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Compute"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.DOUBLE_arg(bottomAltitude) as arg_bottomAltitude, \
             agmarshall.DOUBLE_arg(topAltitude) as arg_topAltitude, \
             agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder, positionsWindingOrder) as arg_positionsWindingOrder, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_cartographic_with_altitudes_and_winding_order"](arg_centralBody.COM_val, byref(arg_positions.COM_val), arg_bottomAltitude.COM_val, arg_topAltitude.COM_val, arg_positionsWindingOrder.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_single_constant_altitude(self, centralBody:str, positions:list, altitude:float) -> "IExtrudedPolylineTriangulatorResult":
        """Computes an extrusion of positions on the specified centralBody. One side of the extrusion has a constant altitude and the other has the original altitudes from positions..."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_single_constant_altitude"](arg_centralBody.COM_val, byref(arg_positions.COM_val), arg_altitude.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_single_constant_altitude_with_winding_order(self, centralBody:str, positions:list, altitude:float, positionsWindingOrder:"AgEStkGraphicsWindingOrder") -> "IExtrudedPolylineTriangulatorResult":
        """Computes an extrusion of positions on the specified centralBody. One side of the extrusion has a constant altitude and the other has the original altitudes from positions."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder, positionsWindingOrder) as arg_positionsWindingOrder, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_single_constant_altitude_with_winding_order"](arg_centralBody.COM_val, byref(arg_positions.COM_val), arg_altitude.COM_val, arg_positionsWindingOrder.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_single_constant_altitude_cartographic(self, centralBody:str, positions:list, altitude:float) -> "IExtrudedPolylineTriangulatorResult":
        """For convenience. Computes an extrusion of positions on the specified centralBody using cartographic positions. One side of the extrusion has a constant altitude and the other has the original altitudes from positions..."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_single_constant_altitude_cartographic"](arg_centralBody.COM_val, byref(arg_positions.COM_val), arg_altitude.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_single_constant_altitude_cartographic_with_winding_order(self, centralBody:str, positions:list, altitude:float, positionsWindingOrder:"AgEStkGraphicsWindingOrder") -> "IExtrudedPolylineTriangulatorResult":
        """For convenience. Computes an extrusion of positions on the specified centralBody using cartographic positions. One side of the extrusion has a constant altitude and the other has the original altitudes from positions..."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder, positionsWindingOrder) as arg_positionsWindingOrder, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_single_constant_altitude_cartographic_with_winding_order"](arg_centralBody.COM_val, byref(arg_positions.COM_val), arg_altitude.COM_val, arg_positionsWindingOrder.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{b6b79988-0b1f-4b6e-8970-ff86b6d94b36}", IExtrudedPolylineTriangulatorInitializer)
agcls.AgTypeNameMap["IExtrudedPolylineTriangulatorInitializer"] = IExtrudedPolylineTriangulatorInitializer

class ISurfaceExtentTriangulatorInitializer(object):
    """Triangulates an extent on a central body into a triangle mesh and a surrounding boundary. The mesh is commonly visualized with the triangle mesh primitive or surface mesh primitive. The boundary is commonly visualized with the polyline primitive."""
    _uuid = "{74b85e21-b114-46b6-820d-2be8adc7ea7a}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_compute_simple"] = _raise_uninitialized_error
        self.__dict__["_compute"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISurfaceExtentTriangulatorInitializer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISurfaceExtentTriangulatorInitializer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISurfaceExtentTriangulatorInitializer = agcom.GUID(ISurfaceExtentTriangulatorInitializer._uuid)
        vtable_offset_local = ISurfaceExtentTriangulatorInitializer._vtable_offset - 1
        self.__dict__["_compute_simple"] = IAGFUNCTYPE(pUnk, IID_ISurfaceExtentTriangulatorInitializer, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_compute"] = IAGFUNCTYPE(pUnk, IID_ISurfaceExtentTriangulatorInitializer, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISurfaceExtentTriangulatorInitializer.__dict__ and type(ISurfaceExtentTriangulatorInitializer.__dict__[attrname]) == property:
            return ISurfaceExtentTriangulatorInitializer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISurfaceExtentTriangulatorInitializer.")
    
    def compute_simple(self, centralBody:str, extent:list) -> "ISurfaceTriangulatorResult":
        """Computes a triangulation on the specified centralBody for the specified extent. This is equivalent to calling Compute with an altitude of 0 and a granularity of 1 degree."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(extent) as arg_extent, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_simple"](arg_centralBody.COM_val, byref(arg_extent.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute(self, centralBody:str, extent:list, altitude:float, granularity:float) -> "ISurfaceTriangulatorResult":
        """Computes a triangulation on the specified centralBody for the specified extent."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(extent) as arg_extent, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.DOUBLE_arg(granularity) as arg_granularity, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute"](arg_centralBody.COM_val, byref(arg_extent.COM_val), arg_altitude.COM_val, arg_granularity.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{74b85e21-b114-46b6-820d-2be8adc7ea7a}", ISurfaceExtentTriangulatorInitializer)
agcls.AgTypeNameMap["ISurfaceExtentTriangulatorInitializer"] = ISurfaceExtentTriangulatorInitializer

class ISurfacePolygonTriangulatorInitializer(object):
    """Triangulates a polygon, with an optional hole, on a central body, into a triangle mesh and a surrounding boundary. The mesh is commonly visualized with the triangle mesh primitive or surface mesh primitive..."""
    _uuid = "{52654c8a-3c27-415f-b346-c0e433241b49}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_compute"] = _raise_uninitialized_error
        self.__dict__["_compute_cartographic"] = _raise_uninitialized_error
        self.__dict__["_compute_with_hole"] = _raise_uninitialized_error
        self.__dict__["_compute_with_hole_altitude_and_granularity"] = _raise_uninitialized_error
        self.__dict__["_compute_with_altitude_and_granularity"] = _raise_uninitialized_error
        self.__dict__["_compute_cartographic_with_altitude_and_granularity"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISurfacePolygonTriangulatorInitializer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISurfacePolygonTriangulatorInitializer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISurfacePolygonTriangulatorInitializer = agcom.GUID(ISurfacePolygonTriangulatorInitializer._uuid)
        vtable_offset_local = ISurfacePolygonTriangulatorInitializer._vtable_offset - 1
        self.__dict__["_compute"] = IAGFUNCTYPE(pUnk, IID_ISurfacePolygonTriangulatorInitializer, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_compute_cartographic"] = IAGFUNCTYPE(pUnk, IID_ISurfacePolygonTriangulatorInitializer, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_compute_with_hole"] = IAGFUNCTYPE(pUnk, IID_ISurfacePolygonTriangulatorInitializer, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_compute_with_hole_altitude_and_granularity"] = IAGFUNCTYPE(pUnk, IID_ISurfacePolygonTriangulatorInitializer, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_with_altitude_and_granularity"] = IAGFUNCTYPE(pUnk, IID_ISurfacePolygonTriangulatorInitializer, vtable_offset_local+5, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_compute_cartographic_with_altitude_and_granularity"] = IAGFUNCTYPE(pUnk, IID_ISurfacePolygonTriangulatorInitializer, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISurfacePolygonTriangulatorInitializer.__dict__ and type(ISurfacePolygonTriangulatorInitializer.__dict__[attrname]) == property:
            return ISurfacePolygonTriangulatorInitializer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISurfacePolygonTriangulatorInitializer.")
    
    def compute(self, centralBody:str, positions:list) -> "ISurfaceTriangulatorResult":
        """Computes the triangulation on the specified centralBody for a polygon whose boundary is defined by the specified positions. This is equivalent to calling Compute with an altitude of 0, a granularity of 1 degree, and a positionsWindingOrder of compute."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_cartographic(self, centralBody:str, positions:list) -> "ISurfaceTriangulatorResult":
        """For convenience. Computes the triangulation on the specified centralBody for a polygon whose boundary is defined by the specified cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Compute"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_cartographic"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_with_hole(self, centralBody:str, positions:list, holePositions:list) -> "ISurfaceTriangulatorResult":
        """Computes the triangulation on the specified centralBody for a polygon whose boundary is defined by the specified positions with a hole specified by holePositions. This is equivalent to calling Compute with an altitude of 0 and a granularity of 1 degree."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(holePositions) as arg_holePositions, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_with_hole"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_holePositions.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_with_hole_altitude_and_granularity(self, centralBody:str, positions:list, holePositions:list, altitude:float, granularity:float) -> "ISurfaceTriangulatorResult":
        """Computes the triangulation on the specified centralBody for a polygon whose boundary is defined by the specified positions with a hole specified by holePositions."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.SAFEARRAY_arg(holePositions) as arg_holePositions, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.DOUBLE_arg(granularity) as arg_granularity, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_with_hole_altitude_and_granularity"](arg_centralBody.COM_val, byref(arg_positions.COM_val), byref(arg_holePositions.COM_val), arg_altitude.COM_val, arg_granularity.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_with_altitude_and_granularity(self, centralBody:str, positions:list, altitude:float, granularity:float, positionsWindingOrder:"AgEStkGraphicsWindingOrder") -> "ISurfaceTriangulatorResult":
        """Computes the triangulation on the specified centralBody for a polygon whose boundary is defined by the specified positions."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.DOUBLE_arg(granularity) as arg_granularity, \
             agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder, positionsWindingOrder) as arg_positionsWindingOrder, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_with_altitude_and_granularity"](arg_centralBody.COM_val, byref(arg_positions.COM_val), arg_altitude.COM_val, arg_granularity.COM_val, arg_positionsWindingOrder.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_cartographic_with_altitude_and_granularity(self, centralBody:str, positions:list, altitude:float, granularity:float, positionsWindingOrder:"AgEStkGraphicsWindingOrder") -> "ISurfaceTriangulatorResult":
        """For convenience. Computes the triangulation on the specified centralBody for a polygon whose boundary is defined by the specified cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Compute"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(positions) as arg_positions, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.DOUBLE_arg(granularity) as arg_granularity, \
             agmarshall.AgEnum_arg(AgEStkGraphicsWindingOrder, positionsWindingOrder) as arg_positionsWindingOrder, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_cartographic_with_altitude_and_granularity"](arg_centralBody.COM_val, byref(arg_positions.COM_val), arg_altitude.COM_val, arg_granularity.COM_val, arg_positionsWindingOrder.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{52654c8a-3c27-415f-b346-c0e433241b49}", ISurfacePolygonTriangulatorInitializer)
agcls.AgTypeNameMap["ISurfacePolygonTriangulatorInitializer"] = ISurfacePolygonTriangulatorInitializer

class ISurfaceShapesInitializer(object):
    """Computes boundary positions for shapes on the surface such as circles, ellipses, and sectors."""
    _uuid = "{8b711790-8bc2-4e20-8795-89a4863a0566}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_compute_circle_with_granularity"] = _raise_uninitialized_error
        self.__dict__["_compute_circle"] = _raise_uninitialized_error
        self.__dict__["_compute_circle_cartographic_with_granularity"] = _raise_uninitialized_error
        self.__dict__["_compute_circle_cartographic"] = _raise_uninitialized_error
        self.__dict__["_compute_ellipse_with_granularity"] = _raise_uninitialized_error
        self.__dict__["_compute_ellipse"] = _raise_uninitialized_error
        self.__dict__["_compute_ellipse_cartographic_with_granularity"] = _raise_uninitialized_error
        self.__dict__["_compute_ellipse_cartographic"] = _raise_uninitialized_error
        self.__dict__["_compute_sector_with_granularity"] = _raise_uninitialized_error
        self.__dict__["_compute_sector"] = _raise_uninitialized_error
        self.__dict__["_compute_sector_cartographic_with_granularity"] = _raise_uninitialized_error
        self.__dict__["_compute_sector_cartographic"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISurfaceShapesInitializer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISurfaceShapesInitializer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISurfaceShapesInitializer = agcom.GUID(ISurfaceShapesInitializer._uuid)
        vtable_offset_local = ISurfaceShapesInitializer._vtable_offset - 1
        self.__dict__["_compute_circle_with_granularity"] = IAGFUNCTYPE(pUnk, IID_ISurfaceShapesInitializer, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_circle"] = IAGFUNCTYPE(pUnk, IID_ISurfaceShapesInitializer, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_circle_cartographic_with_granularity"] = IAGFUNCTYPE(pUnk, IID_ISurfaceShapesInitializer, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_circle_cartographic"] = IAGFUNCTYPE(pUnk, IID_ISurfaceShapesInitializer, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_ellipse_with_granularity"] = IAGFUNCTYPE(pUnk, IID_ISurfaceShapesInitializer, vtable_offset_local+5, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_ellipse"] = IAGFUNCTYPE(pUnk, IID_ISurfaceShapesInitializer, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_ellipse_cartographic_with_granularity"] = IAGFUNCTYPE(pUnk, IID_ISurfaceShapesInitializer, vtable_offset_local+7, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_ellipse_cartographic"] = IAGFUNCTYPE(pUnk, IID_ISurfaceShapesInitializer, vtable_offset_local+8, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_sector_with_granularity"] = IAGFUNCTYPE(pUnk, IID_ISurfaceShapesInitializer, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_sector"] = IAGFUNCTYPE(pUnk, IID_ISurfaceShapesInitializer, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_sector_cartographic_with_granularity"] = IAGFUNCTYPE(pUnk, IID_ISurfaceShapesInitializer, vtable_offset_local+11, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_compute_sector_cartographic"] = IAGFUNCTYPE(pUnk, IID_ISurfaceShapesInitializer, vtable_offset_local+12, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISurfaceShapesInitializer.__dict__ and type(ISurfaceShapesInitializer.__dict__[attrname]) == property:
            return ISurfaceShapesInitializer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISurfaceShapesInitializer.")
    
    def compute_circle_with_granularity(self, centralBody:str, center:list, radius:float, granularity:float) -> "ISurfaceShapesResult":
        """Computes boundary positions for a circle on the specified centralBody with the specified center, radius and granularity."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(center) as arg_center, \
             agmarshall.DOUBLE_arg(radius) as arg_radius, \
             agmarshall.DOUBLE_arg(granularity) as arg_granularity, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_circle_with_granularity"](arg_centralBody.COM_val, byref(arg_center.COM_val), arg_radius.COM_val, arg_granularity.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_circle(self, centralBody:str, center:list, radius:float) -> "ISurfaceShapesResult":
        """Computes boundary positions for a circle on the specified centralBody with the specified center and radius. This is equivalent to calling ComputeCircle with a granularity of 1 degree."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(center) as arg_center, \
             agmarshall.DOUBLE_arg(radius) as arg_radius, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_circle"](arg_centralBody.COM_val, byref(arg_center.COM_val), arg_radius.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_circle_cartographic_with_granularity(self, centralBody:str, center:list, radius:float, granularity:float) -> "ISurfaceShapesResult":
        """For convenience. Computes boundary positions for a circle on the specified centralBody using a cartographic center. This is equivalent to converting center to cartesian and calling ComputeCircle"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(center) as arg_center, \
             agmarshall.DOUBLE_arg(radius) as arg_radius, \
             agmarshall.DOUBLE_arg(granularity) as arg_granularity, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_circle_cartographic_with_granularity"](arg_centralBody.COM_val, byref(arg_center.COM_val), arg_radius.COM_val, arg_granularity.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_circle_cartographic(self, centralBody:str, center:list, radius:float) -> "ISurfaceShapesResult":
        """For convenience. Computes boundary positions for a circle on the specified centralBody using a cartographic center. This is equivalent to converting center to cartesian and calling ComputeCircle"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(center) as arg_center, \
             agmarshall.DOUBLE_arg(radius) as arg_radius, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_circle_cartographic"](arg_centralBody.COM_val, byref(arg_center.COM_val), arg_radius.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_ellipse_with_granularity(self, centralBody:str, center:list, majorAxisRadius:float, minorAxisRadius:float, bearing:float, granularity:float) -> "ISurfaceShapesResult":
        """Computes boundary positions for an ellipse on the specified centralBody."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(center) as arg_center, \
             agmarshall.DOUBLE_arg(majorAxisRadius) as arg_majorAxisRadius, \
             agmarshall.DOUBLE_arg(minorAxisRadius) as arg_minorAxisRadius, \
             agmarshall.DOUBLE_arg(bearing) as arg_bearing, \
             agmarshall.DOUBLE_arg(granularity) as arg_granularity, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_ellipse_with_granularity"](arg_centralBody.COM_val, byref(arg_center.COM_val), arg_majorAxisRadius.COM_val, arg_minorAxisRadius.COM_val, arg_bearing.COM_val, arg_granularity.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_ellipse(self, centralBody:str, center:list, majorAxisRadius:float, minorAxisRadius:float, bearing:float) -> "ISurfaceShapesResult":
        """Computes boundary positions for an ellipse on the specified centralBody This is equivalent to calling ComputeEllipse with a granularity of 1 degree."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(center) as arg_center, \
             agmarshall.DOUBLE_arg(majorAxisRadius) as arg_majorAxisRadius, \
             agmarshall.DOUBLE_arg(minorAxisRadius) as arg_minorAxisRadius, \
             agmarshall.DOUBLE_arg(bearing) as arg_bearing, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_ellipse"](arg_centralBody.COM_val, byref(arg_center.COM_val), arg_majorAxisRadius.COM_val, arg_minorAxisRadius.COM_val, arg_bearing.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_ellipse_cartographic_with_granularity(self, centralBody:str, center:list, majorAxisRadius:float, minorAxisRadius:float, bearing:float, granularity:float) -> "ISurfaceShapesResult":
        """For convenience. Computes boundary positions for an ellipse on the specified centralBody using a cartographic center. This is equivalent to converting center to cartesian and calling ComputeEllipse"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(center) as arg_center, \
             agmarshall.DOUBLE_arg(majorAxisRadius) as arg_majorAxisRadius, \
             agmarshall.DOUBLE_arg(minorAxisRadius) as arg_minorAxisRadius, \
             agmarshall.DOUBLE_arg(bearing) as arg_bearing, \
             agmarshall.DOUBLE_arg(granularity) as arg_granularity, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_ellipse_cartographic_with_granularity"](arg_centralBody.COM_val, byref(arg_center.COM_val), arg_majorAxisRadius.COM_val, arg_minorAxisRadius.COM_val, arg_bearing.COM_val, arg_granularity.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_ellipse_cartographic(self, centralBody:str, center:list, majorAxisRadius:float, minorAxisRadius:float, bearing:float) -> "ISurfaceShapesResult":
        """For convenience. Computes boundary positions for an ellipse on the specified centralBody using a cartographic center. This is equivalent to converting center to cartesian and calling ComputeEllipse"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(center) as arg_center, \
             agmarshall.DOUBLE_arg(majorAxisRadius) as arg_majorAxisRadius, \
             agmarshall.DOUBLE_arg(minorAxisRadius) as arg_minorAxisRadius, \
             agmarshall.DOUBLE_arg(bearing) as arg_bearing, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_ellipse_cartographic"](arg_centralBody.COM_val, byref(arg_center.COM_val), arg_majorAxisRadius.COM_val, arg_minorAxisRadius.COM_val, arg_bearing.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_sector_with_granularity(self, centralBody:str, center:list, innerRadius:float, outerRadius:float, startBearing:float, endBearing:float, granularity:float) -> "ISurfaceShapesResult":
        """Computes boundary positions for a sector on the specified centralBody."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(center) as arg_center, \
             agmarshall.DOUBLE_arg(innerRadius) as arg_innerRadius, \
             agmarshall.DOUBLE_arg(outerRadius) as arg_outerRadius, \
             agmarshall.DOUBLE_arg(startBearing) as arg_startBearing, \
             agmarshall.DOUBLE_arg(endBearing) as arg_endBearing, \
             agmarshall.DOUBLE_arg(granularity) as arg_granularity, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_sector_with_granularity"](arg_centralBody.COM_val, byref(arg_center.COM_val), arg_innerRadius.COM_val, arg_outerRadius.COM_val, arg_startBearing.COM_val, arg_endBearing.COM_val, arg_granularity.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_sector(self, centralBody:str, center:list, innerRadius:float, outerRadius:float, startBearing:float, endBearing:float) -> "ISurfaceShapesResult":
        """Computes boundary positions for a sector on the specified centralBody This is equivalent to calling ComputeSector with a granularity of 1 degree."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(center) as arg_center, \
             agmarshall.DOUBLE_arg(innerRadius) as arg_innerRadius, \
             agmarshall.DOUBLE_arg(outerRadius) as arg_outerRadius, \
             agmarshall.DOUBLE_arg(startBearing) as arg_startBearing, \
             agmarshall.DOUBLE_arg(endBearing) as arg_endBearing, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_sector"](arg_centralBody.COM_val, byref(arg_center.COM_val), arg_innerRadius.COM_val, arg_outerRadius.COM_val, arg_startBearing.COM_val, arg_endBearing.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_sector_cartographic_with_granularity(self, centralBody:str, center:list, innerRadius:float, outerRadius:float, startBearing:float, endBearing:float, granularity:float) -> "ISurfaceShapesResult":
        """For convenience. Computes boundary positions for a sector on the specified centralBody using a cartographic center. This is equivalent to converting center to cartesian and calling ComputeSector"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(center) as arg_center, \
             agmarshall.DOUBLE_arg(innerRadius) as arg_innerRadius, \
             agmarshall.DOUBLE_arg(outerRadius) as arg_outerRadius, \
             agmarshall.DOUBLE_arg(startBearing) as arg_startBearing, \
             agmarshall.DOUBLE_arg(endBearing) as arg_endBearing, \
             agmarshall.DOUBLE_arg(granularity) as arg_granularity, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_sector_cartographic_with_granularity"](arg_centralBody.COM_val, byref(arg_center.COM_val), arg_innerRadius.COM_val, arg_outerRadius.COM_val, arg_startBearing.COM_val, arg_endBearing.COM_val, arg_granularity.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def compute_sector_cartographic(self, centralBody:str, center:list, innerRadius:float, outerRadius:float, startBearing:float, endBearing:float) -> "ISurfaceShapesResult":
        """For convenience. Computes boundary positions for a sector on the specified centralBody using a cartographic center. This is equivalent to converting center to cartesian and calling ComputeSector"""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.SAFEARRAY_arg(center) as arg_center, \
             agmarshall.DOUBLE_arg(innerRadius) as arg_innerRadius, \
             agmarshall.DOUBLE_arg(outerRadius) as arg_outerRadius, \
             agmarshall.DOUBLE_arg(startBearing) as arg_startBearing, \
             agmarshall.DOUBLE_arg(endBearing) as arg_endBearing, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_compute_sector_cartographic"](arg_centralBody.COM_val, byref(arg_center.COM_val), arg_innerRadius.COM_val, arg_outerRadius.COM_val, arg_startBearing.COM_val, arg_endBearing.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8b711790-8bc2-4e20-8795-89a4863a0566}", ISurfaceShapesInitializer)
agcls.AgTypeNameMap["ISurfaceShapesInitializer"] = ISurfaceShapesInitializer

class IAGICustomTerrainOverlayFactory(object):
    """A terrain overlay for handling AGI Cesium Terrain."""
    _uuid = "{1af28259-1c26-45f4-8156-079012d5bce3}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize_with_string"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAGICustomTerrainOverlayFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAGICustomTerrainOverlayFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAGICustomTerrainOverlayFactory = agcom.GUID(IAGICustomTerrainOverlayFactory._uuid)
        vtable_offset_local = IAGICustomTerrainOverlayFactory._vtable_offset - 1
        self.__dict__["_initialize_with_string"] = IAGFUNCTYPE(pUnk, IID_IAGICustomTerrainOverlayFactory, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAGICustomTerrainOverlayFactory.__dict__ and type(IAGICustomTerrainOverlayFactory.__dict__[attrname]) == property:
            return IAGICustomTerrainOverlayFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAGICustomTerrainOverlayFactory.")
    
    def initialize_with_string(self, uri:str) -> "IAGICustomTerrainOverlay":
        """Initializes an agi custom terrain overlay with the provided values."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_string"](arg_uri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1af28259-1c26-45f4-8156-079012d5bce3}", IAGICustomTerrainOverlayFactory)
agcls.AgTypeNameMap["IAGICustomTerrainOverlayFactory"] = IAGICustomTerrainOverlayFactory

class IAGIProcessedImageGlobeOverlayFactory(object):
    """A globe image overlay for handling AGI Processed Image (PDTTX) files."""
    _uuid = "{0d8e18a4-cda4-4b24-9ab0-2f25c83eb32e}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize_with_string"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAGIProcessedImageGlobeOverlayFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAGIProcessedImageGlobeOverlayFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAGIProcessedImageGlobeOverlayFactory = agcom.GUID(IAGIProcessedImageGlobeOverlayFactory._uuid)
        vtable_offset_local = IAGIProcessedImageGlobeOverlayFactory._vtable_offset - 1
        self.__dict__["_initialize_with_string"] = IAGFUNCTYPE(pUnk, IID_IAGIProcessedImageGlobeOverlayFactory, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAGIProcessedImageGlobeOverlayFactory.__dict__ and type(IAGIProcessedImageGlobeOverlayFactory.__dict__[attrname]) == property:
            return IAGIProcessedImageGlobeOverlayFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAGIProcessedImageGlobeOverlayFactory.")
    
    def initialize_with_string(self, uri:str) -> "IAGIProcessedImageGlobeOverlay":
        """Initializes an agi processed image globe overlay with the provided values."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_string"](arg_uri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{0d8e18a4-cda4-4b24-9ab0-2f25c83eb32e}", IAGIProcessedImageGlobeOverlayFactory)
agcls.AgTypeNameMap["IAGIProcessedImageGlobeOverlayFactory"] = IAGIProcessedImageGlobeOverlayFactory

class IAGIProcessedTerrainOverlayFactory(object):
    """A terrain overlay for handling AGI Processed Terrain (PDTT) files."""
    _uuid = "{dfeee7d8-cd40-43a5-b168-843f26b027ea}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize_with_string"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAGIProcessedTerrainOverlayFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAGIProcessedTerrainOverlayFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAGIProcessedTerrainOverlayFactory = agcom.GUID(IAGIProcessedTerrainOverlayFactory._uuid)
        vtable_offset_local = IAGIProcessedTerrainOverlayFactory._vtable_offset - 1
        self.__dict__["_initialize_with_string"] = IAGFUNCTYPE(pUnk, IID_IAGIProcessedTerrainOverlayFactory, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAGIProcessedTerrainOverlayFactory.__dict__ and type(IAGIProcessedTerrainOverlayFactory.__dict__[attrname]) == property:
            return IAGIProcessedTerrainOverlayFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAGIProcessedTerrainOverlayFactory.")
    
    def initialize_with_string(self, uri:str) -> "IAGIProcessedTerrainOverlay":
        """Initializes an agi processed terrain overlay with the provided values."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_string"](arg_uri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{dfeee7d8-cd40-43a5-b168-843f26b027ea}", IAGIProcessedTerrainOverlayFactory)
agcls.AgTypeNameMap["IAGIProcessedTerrainOverlayFactory"] = IAGIProcessedTerrainOverlayFactory

class IAGIRoamImageGlobeOverlayFactory(object):
    """A globe image overlay for handling ROAM (TXM/TXB) files."""
    _uuid = "{709d626f-1b45-448d-ad5c-1ff3cb17410e}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize_with_string"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAGIRoamImageGlobeOverlayFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAGIRoamImageGlobeOverlayFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAGIRoamImageGlobeOverlayFactory = agcom.GUID(IAGIRoamImageGlobeOverlayFactory._uuid)
        vtable_offset_local = IAGIRoamImageGlobeOverlayFactory._vtable_offset - 1
        self.__dict__["_initialize_with_string"] = IAGFUNCTYPE(pUnk, IID_IAGIRoamImageGlobeOverlayFactory, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAGIRoamImageGlobeOverlayFactory.__dict__ and type(IAGIRoamImageGlobeOverlayFactory.__dict__[attrname]) == property:
            return IAGIRoamImageGlobeOverlayFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAGIRoamImageGlobeOverlayFactory.")
    
    def initialize_with_string(self, uri:str) -> "IAGIRoamImageGlobeOverlay":
        """Initializes an agi roam image globe overlay with the provided values."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_string"](arg_uri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{709d626f-1b45-448d-ad5c-1ff3cb17410e}", IAGIRoamImageGlobeOverlayFactory)
agcls.AgTypeNameMap["IAGIRoamImageGlobeOverlayFactory"] = IAGIRoamImageGlobeOverlayFactory

class ICustomImageGlobeOverlayPluginActivatorFactory(object):
    """The Activator class provides methods to load COM plugins that implement custom image globe overlays. For more information about custom image globe overlays, see the STK Programming Interface."""
    _uuid = "{c80d1ae6-db35-4f55-a9a4-131260022535}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICustomImageGlobeOverlayPluginActivatorFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICustomImageGlobeOverlayPluginActivatorFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICustomImageGlobeOverlayPluginActivatorFactory = agcom.GUID(ICustomImageGlobeOverlayPluginActivatorFactory._uuid)
        vtable_offset_local = ICustomImageGlobeOverlayPluginActivatorFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ICustomImageGlobeOverlayPluginActivatorFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICustomImageGlobeOverlayPluginActivatorFactory.__dict__ and type(ICustomImageGlobeOverlayPluginActivatorFactory.__dict__[attrname]) == property:
            return ICustomImageGlobeOverlayPluginActivatorFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICustomImageGlobeOverlayPluginActivatorFactory.")
    
    def initialize(self) -> "ICustomImageGlobeOverlayPluginActivator":
        """Initializes a new instance of the Activator type."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{c80d1ae6-db35-4f55-a9a4-131260022535}", ICustomImageGlobeOverlayPluginActivatorFactory)
agcls.AgTypeNameMap["ICustomImageGlobeOverlayPluginActivatorFactory"] = ICustomImageGlobeOverlayPluginActivatorFactory

class IGeospatialImageGlobeOverlayFactory(object):
    """A globe image overlay for handling `JPEG 2000 <https://jpeg.org/jpeg2000/>`_ (.jp2), ECW (.ecw), ECWP, and MrSid (.sid) image formats in the WGS84 geographic projection."""
    _uuid = "{77060b41-7b24-4118-ab48-22efb3007c76}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize_with_string"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGeospatialImageGlobeOverlayFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGeospatialImageGlobeOverlayFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGeospatialImageGlobeOverlayFactory = agcom.GUID(IGeospatialImageGlobeOverlayFactory._uuid)
        vtable_offset_local = IGeospatialImageGlobeOverlayFactory._vtable_offset - 1
        self.__dict__["_initialize_with_string"] = IAGFUNCTYPE(pUnk, IID_IGeospatialImageGlobeOverlayFactory, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGeospatialImageGlobeOverlayFactory.__dict__ and type(IGeospatialImageGlobeOverlayFactory.__dict__[attrname]) == property:
            return IGeospatialImageGlobeOverlayFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGeospatialImageGlobeOverlayFactory.")
    
    def initialize_with_string(self, uri:str) -> "IGeospatialImageGlobeOverlay":
        """Initializes a geospatial image globe overlay with the provided values."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_string"](arg_uri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{77060b41-7b24-4118-ab48-22efb3007c76}", IGeospatialImageGlobeOverlayFactory)
agcls.AgTypeNameMap["IGeospatialImageGlobeOverlayFactory"] = IGeospatialImageGlobeOverlayFactory

class IProjectedRasterOverlayFactory(object):
    """A globe image overlay which projects a raster onto the terrain or surface of the central body. You can also enable projection onto models by setting projected raster model projection to true for a Scene..."""
    _uuid = "{616abf78-55f7-41a7-a6b7-2da4ae822856}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_get_supported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProjectedRasterOverlayFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProjectedRasterOverlayFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProjectedRasterOverlayFactory = agcom.GUID(IProjectedRasterOverlayFactory._uuid)
        vtable_offset_local = IProjectedRasterOverlayFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlayFactory, vtable_offset_local+1, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_get_supported"] = IAGFUNCTYPE(pUnk, IID_IProjectedRasterOverlayFactory, vtable_offset_local+2, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProjectedRasterOverlayFactory.__dict__ and type(IProjectedRasterOverlayFactory.__dict__[attrname]) == property:
            return IProjectedRasterOverlayFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProjectedRasterOverlayFactory.")
    
    def initialize(self, raster:"IRaster", projection:"IProjection") -> "IProjectedRasterOverlay":
        """Initializes a new instance."""
        with agmarshall.AgInterface_in_arg(raster, IRaster) as arg_raster, \
             agmarshall.AgInterface_in_arg(projection, IProjection) as arg_projection, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](arg_raster.COM_val, arg_projection.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def supported(self) -> bool:
        """Gets whether or not the video card supports the projected raster overlay."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{616abf78-55f7-41a7-a6b7-2da4ae822856}", IProjectedRasterOverlayFactory)
agcls.AgTypeNameMap["IProjectedRasterOverlayFactory"] = IProjectedRasterOverlayFactory

class IProjectionFactory(object):
    """A projection represents a simplified camera with a position, orientation, and field of view horizontal and field of view vertical..."""
    _uuid = "{db047d3d-5afd-4b64-b396-034fd95ec57a}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_data"] = _raise_uninitialized_error
        self.__dict__["_initialize_from_projection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProjectionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProjectionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProjectionFactory = agcom.GUID(IProjectionFactory._uuid)
        vtable_offset_local = IProjectionFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IProjectionFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_data"] = IAGFUNCTYPE(pUnk, IID_IProjectionFactory, vtable_offset_local+2, POINTER(agcom.SAFEARRAY), agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_initialize_from_projection"] = IAGFUNCTYPE(pUnk, IID_IProjectionFactory, vtable_offset_local+3, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProjectionFactory.__dict__ and type(IProjectionFactory.__dict__[attrname]) == property:
            return IProjectionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProjectionFactory.")
    
    def initialize(self) -> "IProjection":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_data(self, position:list, orientation:"IOrientation", fieldOfViewHorizontal:float, fieldOfViewVertical:float, nearPlane:float, farPlane:float) -> "IProjection":
        """Initializes a new instance."""
        with agmarshall.SAFEARRAY_arg(position) as arg_position, \
             agmarshall.AgInterface_in_arg(orientation, IOrientation) as arg_orientation, \
             agmarshall.DOUBLE_arg(fieldOfViewHorizontal) as arg_fieldOfViewHorizontal, \
             agmarshall.DOUBLE_arg(fieldOfViewVertical) as arg_fieldOfViewVertical, \
             agmarshall.DOUBLE_arg(nearPlane) as arg_nearPlane, \
             agmarshall.DOUBLE_arg(farPlane) as arg_farPlane, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_data"](byref(arg_position.COM_val), arg_orientation.COM_val, arg_fieldOfViewHorizontal.COM_val, arg_fieldOfViewVertical.COM_val, arg_nearPlane.COM_val, arg_farPlane.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_from_projection(self, projection:"IProjection") -> "IProjection":
        """Initializes a new instance from another projection."""
        with agmarshall.AgInterface_in_arg(projection, IProjection) as arg_projection, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_from_projection"](arg_projection.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{db047d3d-5afd-4b64-b396-034fd95ec57a}", IProjectionFactory)
agcls.AgTypeNameMap["IProjectionFactory"] = IProjectionFactory

class IAltitudeDisplayConditionFactory(object):
    """Defines an inclusive altitude interval that determines when an object is rendered based on the camera's altitude relative to a central body."""
    _uuid = "{ee1efbf0-ddbf-41ff-9257-ff73e164d27a}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_altitudes"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_central_body_and_altitudes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAltitudeDisplayConditionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAltitudeDisplayConditionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAltitudeDisplayConditionFactory = agcom.GUID(IAltitudeDisplayConditionFactory._uuid)
        vtable_offset_local = IAltitudeDisplayConditionFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IAltitudeDisplayConditionFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_altitudes"] = IAGFUNCTYPE(pUnk, IID_IAltitudeDisplayConditionFactory, vtable_offset_local+2, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_central_body_and_altitudes"] = IAGFUNCTYPE(pUnk, IID_IAltitudeDisplayConditionFactory, vtable_offset_local+3, agcom.BSTR, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAltitudeDisplayConditionFactory.__dict__ and type(IAltitudeDisplayConditionFactory.__dict__[attrname]) == property:
            return IAltitudeDisplayConditionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAltitudeDisplayConditionFactory.")
    
    def initialize(self) -> "IAltitudeDisplayCondition":
        """Initializes a default altitude display condition. With this constructor, an object is always rendered regardless of the camera's altitude."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_altitudes(self, minimumAltitude:float, maximumAltitude:float) -> "IAltitudeDisplayCondition":
        """Initializes an altitude display condition with the inclusive altitude interval [minimumAltitude, maximumAltitude]..."""
        with agmarshall.DOUBLE_arg(minimumAltitude) as arg_minimumAltitude, \
             agmarshall.DOUBLE_arg(maximumAltitude) as arg_maximumAltitude, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_altitudes"](arg_minimumAltitude.COM_val, arg_maximumAltitude.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_central_body_and_altitudes(self, centralBody:str, minimumAltitude:float, maximumAltitude:float) -> "IAltitudeDisplayCondition":
        """Initializes an altitude display condition with the inclusive altitude interval [minimumAltitude, maximumAltitude]..."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.DOUBLE_arg(minimumAltitude) as arg_minimumAltitude, \
             agmarshall.DOUBLE_arg(maximumAltitude) as arg_maximumAltitude, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_central_body_and_altitudes"](arg_centralBody.COM_val, arg_minimumAltitude.COM_val, arg_maximumAltitude.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{ee1efbf0-ddbf-41ff-9257-ff73e164d27a}", IAltitudeDisplayConditionFactory)
agcls.AgTypeNameMap["IAltitudeDisplayConditionFactory"] = IAltitudeDisplayConditionFactory

class IAxesPrimitiveFactory(object):
    """Renders an axes in the 3D scene."""
    _uuid = "{ff0a767c-8a84-47f9-a108-32cc0bff8366}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize_with_direction"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesPrimitiveFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesPrimitiveFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesPrimitiveFactory = agcom.GUID(IAxesPrimitiveFactory._uuid)
        vtable_offset_local = IAxesPrimitiveFactory._vtable_offset - 1
        self.__dict__["_initialize_with_direction"] = IAGFUNCTYPE(pUnk, IID_IAxesPrimitiveFactory, vtable_offset_local+1, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesPrimitiveFactory.__dict__ and type(IAxesPrimitiveFactory.__dict__[attrname]) == property:
            return IAxesPrimitiveFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesPrimitiveFactory.")
    
    def initialize_with_direction(self, sys:"IVectorGeometryToolSystem", axes:"IVectorGeometryToolAxes", font:"IGraphicsFont") -> "IAxesPrimitive":
        """Initializes an axes primitive with the specified ISystem sys as its source."""
        with agmarshall.AgInterface_in_arg(sys, IVectorGeometryToolSystem) as arg_sys, \
             agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_in_arg(font, IGraphicsFont) as arg_font, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_direction"](arg_sys.COM_val, arg_axes.COM_val, arg_font.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{ff0a767c-8a84-47f9-a108-32cc0bff8366}", IAxesPrimitiveFactory)
agcls.AgTypeNameMap["IAxesPrimitiveFactory"] = IAxesPrimitiveFactory

class ICompositeDisplayConditionFactory(object):
    """A composite of display conditions combined using a binary logic operation. For example, several time interval display condition objects can be added to a composite..."""
    _uuid = "{a2ca541e-a860-4e47-b0e9-f0e973733e67}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICompositeDisplayConditionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICompositeDisplayConditionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICompositeDisplayConditionFactory = agcom.GUID(ICompositeDisplayConditionFactory._uuid)
        vtable_offset_local = ICompositeDisplayConditionFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ICompositeDisplayConditionFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICompositeDisplayConditionFactory.__dict__ and type(ICompositeDisplayConditionFactory.__dict__[attrname]) == property:
            return ICompositeDisplayConditionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICompositeDisplayConditionFactory.")
    
    def initialize(self) -> "ICompositeDisplayCondition":
        """Initializes an empty composite display condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{a2ca541e-a860-4e47-b0e9-f0e973733e67}", ICompositeDisplayConditionFactory)
agcls.AgTypeNameMap["ICompositeDisplayConditionFactory"] = ICompositeDisplayConditionFactory

class ICompositePrimitiveFactory(object):
    """ A primitive that is composed of multiple other primitives. Since composites can contain other composites, they are commonly used to build hierarchies of primitives to efficiently evaluate display conditions..."""
    _uuid = "{6828c6a1-7018-4b65-90af-8bb36f478a6d}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICompositePrimitiveFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICompositePrimitiveFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICompositePrimitiveFactory = agcom.GUID(ICompositePrimitiveFactory._uuid)
        vtable_offset_local = ICompositePrimitiveFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ICompositePrimitiveFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICompositePrimitiveFactory.__dict__ and type(ICompositePrimitiveFactory.__dict__[attrname]) == property:
            return ICompositePrimitiveFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICompositePrimitiveFactory.")
    
    def initialize(self) -> "ICompositePrimitive":
        """Initializes a default composite primitive."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6828c6a1-7018-4b65-90af-8bb36f478a6d}", ICompositePrimitiveFactory)
agcls.AgTypeNameMap["ICompositePrimitiveFactory"] = ICompositePrimitiveFactory

class IConstantDisplayConditionFactory(object):
    """A display condition that evaluates to a user-defined value. This is commonly used to hide primitives by assigning to a primitive a display condition that always returns false."""
    _uuid = "{4c5226f9-a98e-4af0-a9a4-1e5926908d4c}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_display"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConstantDisplayConditionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConstantDisplayConditionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConstantDisplayConditionFactory = agcom.GUID(IConstantDisplayConditionFactory._uuid)
        vtable_offset_local = IConstantDisplayConditionFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IConstantDisplayConditionFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_display"] = IAGFUNCTYPE(pUnk, IID_IConstantDisplayConditionFactory, vtable_offset_local+2, agcom.VARIANT_BOOL, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConstantDisplayConditionFactory.__dict__ and type(IConstantDisplayConditionFactory.__dict__[attrname]) == property:
            return IConstantDisplayConditionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConstantDisplayConditionFactory.")
    
    def initialize(self) -> "IConstantDisplayCondition":
        """Initializes a default constant display condition. display is set to false so when this display condition is assigned to an object, such as a primitive, the object is not rendered."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_display(self, display:bool) -> "IConstantDisplayCondition":
        """Initializes a constant display condition with the value the display condition evaluates to."""
        with agmarshall.VARIANT_BOOL_arg(display) as arg_display, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_display"](arg_display.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4c5226f9-a98e-4af0-a9a4-1e5926908d4c}", IConstantDisplayConditionFactory)
agcls.AgTypeNameMap["IConstantDisplayConditionFactory"] = IConstantDisplayConditionFactory

class IDistanceDisplayConditionFactory(object):
    """Defines an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the object."""
    _uuid = "{d7dda546-31d2-4bbd-a44d-b9dc413a2412}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_distances"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDistanceDisplayConditionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDistanceDisplayConditionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDistanceDisplayConditionFactory = agcom.GUID(IDistanceDisplayConditionFactory._uuid)
        vtable_offset_local = IDistanceDisplayConditionFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IDistanceDisplayConditionFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_distances"] = IAGFUNCTYPE(pUnk, IID_IDistanceDisplayConditionFactory, vtable_offset_local+2, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDistanceDisplayConditionFactory.__dict__ and type(IDistanceDisplayConditionFactory.__dict__[attrname]) == property:
            return IDistanceDisplayConditionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDistanceDisplayConditionFactory.")
    
    def initialize(self) -> "IDistanceDisplayCondition":
        """Initializes a default distance display condition. minimum distance is set to 0 and maximum distance is set to Double.MaxValue. With this interval, an object is always rendered regardless of its distance to the camera."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_distances(self, minimumDistance:float, maximumDistance:float) -> "IDistanceDisplayCondition":
        """Initializes a distance display condition with the inclusive distance interval [minimumDistance, maximumDistance]..."""
        with agmarshall.DOUBLE_arg(minimumDistance) as arg_minimumDistance, \
             agmarshall.DOUBLE_arg(maximumDistance) as arg_maximumDistance, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_distances"](arg_minimumDistance.COM_val, arg_maximumDistance.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{d7dda546-31d2-4bbd-a44d-b9dc413a2412}", IDistanceDisplayConditionFactory)
agcls.AgTypeNameMap["IDistanceDisplayConditionFactory"] = IDistanceDisplayConditionFactory

class IDistanceToGlobeOverlayDisplayConditionFactory(object):
    """Defines an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the globe overlay..."""
    _uuid = "{05bc2dbc-8533-467a-85d2-720c583f1c7e}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_distances"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDistanceToGlobeOverlayDisplayConditionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDistanceToGlobeOverlayDisplayConditionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDistanceToGlobeOverlayDisplayConditionFactory = agcom.GUID(IDistanceToGlobeOverlayDisplayConditionFactory._uuid)
        vtable_offset_local = IDistanceToGlobeOverlayDisplayConditionFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IDistanceToGlobeOverlayDisplayConditionFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_distances"] = IAGFUNCTYPE(pUnk, IID_IDistanceToGlobeOverlayDisplayConditionFactory, vtable_offset_local+2, agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDistanceToGlobeOverlayDisplayConditionFactory.__dict__ and type(IDistanceToGlobeOverlayDisplayConditionFactory.__dict__[attrname]) == property:
            return IDistanceToGlobeOverlayDisplayConditionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDistanceToGlobeOverlayDisplayConditionFactory.")
    
    def initialize(self) -> "IDistanceToGlobeOverlayDisplayCondition":
        """Initializes a default distance to globe overlay display condition. With this constructor, an object is always rendered regardless of the camera's distance to the globe overlay."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_distances(self, globeOverlay:"IGlobeOverlay", minimumDistance:float, maximumDistance:float) -> "IDistanceToGlobeOverlayDisplayCondition":
        """Initializes a distance display condition with the globe overlay and the inclusive distance interval [minimumDistance, maximumDistance]..."""
        with agmarshall.AgInterface_in_arg(globeOverlay, IGlobeOverlay) as arg_globeOverlay, \
             agmarshall.DOUBLE_arg(minimumDistance) as arg_minimumDistance, \
             agmarshall.DOUBLE_arg(maximumDistance) as arg_maximumDistance, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_distances"](arg_globeOverlay.COM_val, arg_minimumDistance.COM_val, arg_maximumDistance.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{05bc2dbc-8533-467a-85d2-720c583f1c7e}", IDistanceToGlobeOverlayDisplayConditionFactory)
agcls.AgTypeNameMap["IDistanceToGlobeOverlayDisplayConditionFactory"] = IDistanceToGlobeOverlayDisplayConditionFactory

class IDistanceToPositionDisplayConditionFactory(object):
    """Defines an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to a position defined in the given reference frame."""
    _uuid = "{913dd9f7-a91b-4346-b233-180126a8d1bd}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_distances"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_reference_frame_and_distances"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDistanceToPositionDisplayConditionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDistanceToPositionDisplayConditionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDistanceToPositionDisplayConditionFactory = agcom.GUID(IDistanceToPositionDisplayConditionFactory._uuid)
        vtable_offset_local = IDistanceToPositionDisplayConditionFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPositionDisplayConditionFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_distances"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPositionDisplayConditionFactory, vtable_offset_local+2, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_reference_frame_and_distances"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPositionDisplayConditionFactory, vtable_offset_local+3, agcom.PVOID, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDistanceToPositionDisplayConditionFactory.__dict__ and type(IDistanceToPositionDisplayConditionFactory.__dict__[attrname]) == property:
            return IDistanceToPositionDisplayConditionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDistanceToPositionDisplayConditionFactory.")
    
    def initialize(self) -> "IDistanceToPositionDisplayCondition":
        """Initializes a default distance to position display condition. With this constructor, an object is always rendered regardless of the camera's distance to the position."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_distances(self, position:list, minimumDistance:float, maximumDistance:float) -> "IDistanceToPositionDisplayCondition":
        """Initializes a distance display condition with the inclusive distance interval [minimumDistance, maximumDistance]..."""
        with agmarshall.SAFEARRAY_arg(position) as arg_position, \
             agmarshall.DOUBLE_arg(minimumDistance) as arg_minimumDistance, \
             agmarshall.DOUBLE_arg(maximumDistance) as arg_maximumDistance, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_distances"](byref(arg_position.COM_val), arg_minimumDistance.COM_val, arg_maximumDistance.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_reference_frame_and_distances(self, referenceFrame:"IVectorGeometryToolSystem", position:list, minimumDistance:float, maximumDistance:float) -> "IDistanceToPositionDisplayCondition":
        """Initializes a distance display condition with the inclusive distance interval [minimumDistance, maximumDistance]..."""
        with agmarshall.AgInterface_in_arg(referenceFrame, IVectorGeometryToolSystem) as arg_referenceFrame, \
             agmarshall.SAFEARRAY_arg(position) as arg_position, \
             agmarshall.DOUBLE_arg(minimumDistance) as arg_minimumDistance, \
             agmarshall.DOUBLE_arg(maximumDistance) as arg_maximumDistance, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_reference_frame_and_distances"](arg_referenceFrame.COM_val, byref(arg_position.COM_val), arg_minimumDistance.COM_val, arg_maximumDistance.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{913dd9f7-a91b-4346-b233-180126a8d1bd}", IDistanceToPositionDisplayConditionFactory)
agcls.AgTypeNameMap["IDistanceToPositionDisplayConditionFactory"] = IDistanceToPositionDisplayConditionFactory

class IDistanceToPrimitiveDisplayConditionFactory(object):
    """Defines an inclusive distance interval that determines when an object, such as a screen overlay, is rendered based on the distance from the camera to the primitive..."""
    _uuid = "{f103b596-f16c-4ad6-8242-bef8ecb83383}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_distances"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDistanceToPrimitiveDisplayConditionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDistanceToPrimitiveDisplayConditionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDistanceToPrimitiveDisplayConditionFactory = agcom.GUID(IDistanceToPrimitiveDisplayConditionFactory._uuid)
        vtable_offset_local = IDistanceToPrimitiveDisplayConditionFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPrimitiveDisplayConditionFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_distances"] = IAGFUNCTYPE(pUnk, IID_IDistanceToPrimitiveDisplayConditionFactory, vtable_offset_local+2, agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDistanceToPrimitiveDisplayConditionFactory.__dict__ and type(IDistanceToPrimitiveDisplayConditionFactory.__dict__[attrname]) == property:
            return IDistanceToPrimitiveDisplayConditionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDistanceToPrimitiveDisplayConditionFactory.")
    
    def initialize(self) -> "IDistanceToPrimitiveDisplayCondition":
        """Initializes a default distance to primitive display condition. With this constructor, an object is always rendered regardless of the camera's distance to the primitive."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_distances(self, primitive:"IPrimitive", minimumDistance:float, maximumDistance:float) -> "IDistanceToPrimitiveDisplayCondition":
        """Initializes a distance to primitive display condition with the inclusive distance interval [minimumDistance, maximumDistance]..."""
        with agmarshall.AgInterface_in_arg(primitive, IPrimitive) as arg_primitive, \
             agmarshall.DOUBLE_arg(minimumDistance) as arg_minimumDistance, \
             agmarshall.DOUBLE_arg(maximumDistance) as arg_maximumDistance, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_distances"](arg_primitive.COM_val, arg_minimumDistance.COM_val, arg_maximumDistance.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{f103b596-f16c-4ad6-8242-bef8ecb83383}", IDistanceToPrimitiveDisplayConditionFactory)
agcls.AgTypeNameMap["IDistanceToPrimitiveDisplayConditionFactory"] = IDistanceToPrimitiveDisplayConditionFactory

class IDurationPathPrimitiveUpdatePolicyFactory(object):
    """path primitive update policy that removes points from remove location after a given duration."""
    _uuid = "{4ea0bb3e-5620-4a74-b721-6b0000eafdc2}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_parameters"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDurationPathPrimitiveUpdatePolicyFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDurationPathPrimitiveUpdatePolicyFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDurationPathPrimitiveUpdatePolicyFactory = agcom.GUID(IDurationPathPrimitiveUpdatePolicyFactory._uuid)
        vtable_offset_local = IDurationPathPrimitiveUpdatePolicyFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IDurationPathPrimitiveUpdatePolicyFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_parameters"] = IAGFUNCTYPE(pUnk, IID_IDurationPathPrimitiveUpdatePolicyFactory, vtable_offset_local+2, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDurationPathPrimitiveUpdatePolicyFactory.__dict__ and type(IDurationPathPrimitiveUpdatePolicyFactory.__dict__[attrname]) == property:
            return IDurationPathPrimitiveUpdatePolicyFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDurationPathPrimitiveUpdatePolicyFactory.")
    
    def initialize(self) -> "IDurationPathPrimitiveUpdatePolicy":
        """Constructs a default update policy. This is equivalent to constructing a policy with duration set to 0 and a remove location of Front."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_parameters(self, duration:float, removeLocation:"AgEStkGraphicsPathPrimitiveRemoveLocation") -> "IDurationPathPrimitiveUpdatePolicy":
        """Initializes a policy with the specified duration and removeLocation."""
        with agmarshall.DOUBLE_arg(duration) as arg_duration, \
             agmarshall.AgEnum_arg(AgEStkGraphicsPathPrimitiveRemoveLocation, removeLocation) as arg_removeLocation, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_parameters"](arg_duration.COM_val, arg_removeLocation.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4ea0bb3e-5620-4a74-b721-6b0000eafdc2}", IDurationPathPrimitiveUpdatePolicyFactory)
agcls.AgTypeNameMap["IDurationPathPrimitiveUpdatePolicyFactory"] = IDurationPathPrimitiveUpdatePolicyFactory

class IGlobeImageOverlayInitializer(object):
    """A globe overlay that shows an image."""
    _uuid = "{cf06dc51-75ad-45a2-a1ff-9e3b550be24f}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_more_than_one_image_globe_overlay_supported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGlobeImageOverlayInitializer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGlobeImageOverlayInitializer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGlobeImageOverlayInitializer = agcom.GUID(IGlobeImageOverlayInitializer._uuid)
        vtable_offset_local = IGlobeImageOverlayInitializer._vtable_offset - 1
        self.__dict__["_get_more_than_one_image_globe_overlay_supported"] = IAGFUNCTYPE(pUnk, IID_IGlobeImageOverlayInitializer, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGlobeImageOverlayInitializer.__dict__ and type(IGlobeImageOverlayInitializer.__dict__[attrname]) == property:
            return IGlobeImageOverlayInitializer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGlobeImageOverlayInitializer.")
    
    @property
    def more_than_one_image_globe_overlay_supported(self) -> bool:
        """Gets whether or not the video card allows for more than one image globe overlay globe image overlay to be added."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_more_than_one_image_globe_overlay_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{cf06dc51-75ad-45a2-a1ff-9e3b550be24f}", IGlobeImageOverlayInitializer)
agcls.AgTypeNameMap["IGlobeImageOverlayInitializer"] = IGlobeImageOverlayInitializer

class IGraphicsFontFactory(object):
    """A font that is suitable for use with the text batch primitive. For best performance, avoid creating duplicate font objects. Instead assign the same font object to several text batch primitives."""
    _uuid = "{1a87aeee-c00b-462b-bf99-90cb94ae1eb7}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize_with_name_size_font_style_outline"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_name_size"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGraphicsFontFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGraphicsFontFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGraphicsFontFactory = agcom.GUID(IGraphicsFontFactory._uuid)
        vtable_offset_local = IGraphicsFontFactory._vtable_offset - 1
        self.__dict__["_initialize_with_name_size_font_style_outline"] = IAGFUNCTYPE(pUnk, IID_IGraphicsFontFactory, vtable_offset_local+1, agcom.BSTR, agcom.INT, agcom.LONG, agcom.VARIANT_BOOL, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_name_size"] = IAGFUNCTYPE(pUnk, IID_IGraphicsFontFactory, vtable_offset_local+2, agcom.BSTR, agcom.INT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGraphicsFontFactory.__dict__ and type(IGraphicsFontFactory.__dict__[attrname]) == property:
            return IGraphicsFontFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGraphicsFontFactory.")
    
    def initialize_with_name_size_font_style_outline(self, name:str, size:int, fontStyle:"AgEStkGraphicsFontStyle", outline:bool) -> "IGraphicsFont":
        """Initializes a graphics font with the given arguments."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.INT_arg(size) as arg_size, \
             agmarshall.AgEnum_arg(AgEStkGraphicsFontStyle, fontStyle) as arg_fontStyle, \
             agmarshall.VARIANT_BOOL_arg(outline) as arg_outline, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_name_size_font_style_outline"](arg_name.COM_val, arg_size.COM_val, arg_fontStyle.COM_val, arg_outline.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_name_size(self, name:str, size:int) -> "IGraphicsFont":
        """Initializes a graphics font with the typeface name and size."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.INT_arg(size) as arg_size, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_name_size"](arg_name.COM_val, arg_size.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1a87aeee-c00b-462b-bf99-90cb94ae1eb7}", IGraphicsFontFactory)
agcls.AgTypeNameMap["IGraphicsFontFactory"] = IGraphicsFontFactory

class IGreatArcInterpolatorFactory(object):
    """The great arc interpolator computes interpolated positions along a great arc. A great arc is the shortest path between two positions on an ellipsoid."""
    _uuid = "{35afb348-117f-4db0-87ec-643b4b0364dd}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_central_body"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_central_body_and_granularity"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGreatArcInterpolatorFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGreatArcInterpolatorFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGreatArcInterpolatorFactory = agcom.GUID(IGreatArcInterpolatorFactory._uuid)
        vtable_offset_local = IGreatArcInterpolatorFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IGreatArcInterpolatorFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_central_body"] = IAGFUNCTYPE(pUnk, IID_IGreatArcInterpolatorFactory, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_central_body_and_granularity"] = IAGFUNCTYPE(pUnk, IID_IGreatArcInterpolatorFactory, vtable_offset_local+3, agcom.BSTR, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGreatArcInterpolatorFactory.__dict__ and type(IGreatArcInterpolatorFactory.__dict__[attrname]) == property:
            return IGreatArcInterpolatorFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGreatArcInterpolatorFactory.")
    
    def initialize(self) -> "IGreatArcInterpolator":
        """Initializes a default great arc interpolator. This is equivalent to constructing a great arc interpolator with a central body equal to an instance of earth central body and a granularity of 1 degree."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_central_body(self, centralBody:str) -> "IGreatArcInterpolator":
        """Initializes a great arc interpolator with the specified centralBody and a granularity of 1 degree."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_central_body"](arg_centralBody.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_central_body_and_granularity(self, centralBody:str, granularity:float) -> "IGreatArcInterpolator":
        """Initializes a great arc interpolator with the specified centralBody and granularity."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.DOUBLE_arg(granularity) as arg_granularity, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_central_body_and_granularity"](arg_centralBody.COM_val, arg_granularity.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{35afb348-117f-4db0-87ec-643b4b0364dd}", IGreatArcInterpolatorFactory)
agcls.AgTypeNameMap["IGreatArcInterpolatorFactory"] = IGreatArcInterpolatorFactory

class IAlphaFromLuminanceFilterFactory(object):
    """Adds an alpha band to the source raster derived from the luminance of the raster's color bands."""
    _uuid = "{2317f609-231f-4266-b38c-f4fa812a0306}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAlphaFromLuminanceFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAlphaFromLuminanceFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAlphaFromLuminanceFilterFactory = agcom.GUID(IAlphaFromLuminanceFilterFactory._uuid)
        vtable_offset_local = IAlphaFromLuminanceFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IAlphaFromLuminanceFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAlphaFromLuminanceFilterFactory.__dict__ and type(IAlphaFromLuminanceFilterFactory.__dict__[attrname]) == property:
            return IAlphaFromLuminanceFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAlphaFromLuminanceFilterFactory.")
    
    def initialize(self) -> "IAlphaFromLuminanceFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2317f609-231f-4266-b38c-f4fa812a0306}", IAlphaFromLuminanceFilterFactory)
agcls.AgTypeNameMap["IAlphaFromLuminanceFilterFactory"] = IAlphaFromLuminanceFilterFactory

class IAlphaFromPixelFilterFactory(object):
    """Adds an alpha band to the source raster based on the value of its first pixel. All pixels in the source raster that are the same color as the first pixel will be made transparent."""
    _uuid = "{f9802000-aea6-453d-b797-d68fae4a491b}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAlphaFromPixelFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAlphaFromPixelFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAlphaFromPixelFilterFactory = agcom.GUID(IAlphaFromPixelFilterFactory._uuid)
        vtable_offset_local = IAlphaFromPixelFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IAlphaFromPixelFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAlphaFromPixelFilterFactory.__dict__ and type(IAlphaFromPixelFilterFactory.__dict__[attrname]) == property:
            return IAlphaFromPixelFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAlphaFromPixelFilterFactory.")
    
    def initialize(self) -> "IAlphaFromPixelFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{f9802000-aea6-453d-b797-d68fae4a491b}", IAlphaFromPixelFilterFactory)
agcls.AgTypeNameMap["IAlphaFromPixelFilterFactory"] = IAlphaFromPixelFilterFactory

class IAlphaFromRasterFilterFactory(object):
    """Adds an alpha band to the source raster derived from the color bands or alpha of another raster. This filter can be used to apply an alpha mask to the source raster."""
    _uuid = "{f7139fc1-f8f8-4bd2-a33f-9e06fdb4f63c}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_raster"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAlphaFromRasterFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAlphaFromRasterFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAlphaFromRasterFilterFactory = agcom.GUID(IAlphaFromRasterFilterFactory._uuid)
        vtable_offset_local = IAlphaFromRasterFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IAlphaFromRasterFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_raster"] = IAGFUNCTYPE(pUnk, IID_IAlphaFromRasterFilterFactory, vtable_offset_local+2, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAlphaFromRasterFilterFactory.__dict__ and type(IAlphaFromRasterFilterFactory.__dict__[attrname]) == property:
            return IAlphaFromRasterFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAlphaFromRasterFilterFactory.")
    
    def initialize(self) -> "IAlphaFromRasterFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_raster(self, raster:"IRaster") -> "IAlphaFromRasterFilter":
        """Initializes a new instance with the raster that the source raster will use to derive an alpha band."""
        with agmarshall.AgInterface_in_arg(raster, IRaster) as arg_raster, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_raster"](arg_raster.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{f7139fc1-f8f8-4bd2-a33f-9e06fdb4f63c}", IAlphaFromRasterFilterFactory)
agcls.AgTypeNameMap["IAlphaFromRasterFilterFactory"] = IAlphaFromRasterFilterFactory

class IBandExtractFilterFactory(object):
    """Extracts a band or set of bands from the source raster. The extract format property specifies the bands and the order of the bands that will be extracted."""
    _uuid = "{76a65e3a-1868-4312-8a66-8e16a525effd}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_band"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_format"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBandExtractFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBandExtractFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBandExtractFilterFactory = agcom.GUID(IBandExtractFilterFactory._uuid)
        vtable_offset_local = IBandExtractFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IBandExtractFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_band"] = IAGFUNCTYPE(pUnk, IID_IBandExtractFilterFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_format"] = IAGFUNCTYPE(pUnk, IID_IBandExtractFilterFactory, vtable_offset_local+3, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBandExtractFilterFactory.__dict__ and type(IBandExtractFilterFactory.__dict__[attrname]) == property:
            return IBandExtractFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBandExtractFilterFactory.")
    
    def initialize(self) -> "IBandExtractFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_band(self, rasterBand:"AgEStkGraphicsRasterBand") -> "IBandExtractFilter":
        """Initializes a new instance with the raster band to be extracted from the source raster."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsRasterBand, rasterBand) as arg_rasterBand, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_band"](arg_rasterBand.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_format(self, rasterFormat:"AgEStkGraphicsRasterFormat") -> "IBandExtractFilter":
        """Initializes a new instance with the raster format containing the bands to be extracted from the source raster."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsRasterFormat, rasterFormat) as arg_rasterFormat, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_format"](arg_rasterFormat.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{76a65e3a-1868-4312-8a66-8e16a525effd}", IBandExtractFilterFactory)
agcls.AgTypeNameMap["IBandExtractFilterFactory"] = IBandExtractFilterFactory

class IBandOrderFilterFactory(object):
    """Reorders or swizzles the bands of the source raster to match the band order of the raster format specified by the band order property. When maintain raster format is true, the source raster's format is maintained after swizzling."""
    _uuid = "{1bfcf1dd-1ada-47b7-829b-ea60fc04b61d}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_order"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_order_and_bool"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBandOrderFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBandOrderFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBandOrderFilterFactory = agcom.GUID(IBandOrderFilterFactory._uuid)
        vtable_offset_local = IBandOrderFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IBandOrderFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_order"] = IAGFUNCTYPE(pUnk, IID_IBandOrderFilterFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_order_and_bool"] = IAGFUNCTYPE(pUnk, IID_IBandOrderFilterFactory, vtable_offset_local+3, agcom.LONG, agcom.VARIANT_BOOL, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBandOrderFilterFactory.__dict__ and type(IBandOrderFilterFactory.__dict__[attrname]) == property:
            return IBandOrderFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBandOrderFilterFactory.")
    
    def initialize(self) -> "IBandOrderFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_order(self, bandOrder:"AgEStkGraphicsRasterFormat") -> "IBandOrderFilter":
        """Initializes a new instance with a raster format indicating the desired order of the bands in the source raster."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsRasterFormat, bandOrder) as arg_bandOrder, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_order"](arg_bandOrder.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_order_and_bool(self, bandOrder:"AgEStkGraphicsRasterFormat", maintainImageFormat:bool) -> "IBandOrderFilter":
        """Initializes a new instance with a raster format indicating the desired order of the bands in the source raster, and whether to maintain the source raster's format after swizzling."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsRasterFormat, bandOrder) as arg_bandOrder, \
             agmarshall.VARIANT_BOOL_arg(maintainImageFormat) as arg_maintainImageFormat, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_order_and_bool"](arg_bandOrder.COM_val, arg_maintainImageFormat.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1bfcf1dd-1ada-47b7-829b-ea60fc04b61d}", IBandOrderFilterFactory)
agcls.AgTypeNameMap["IBandOrderFilterFactory"] = IBandOrderFilterFactory

class IBlurFilterFactory(object):
    """Applies a convolution filter to blur or smooth the source raster. Can be used to reduce noise in the raster."""
    _uuid = "{99188b11-f0f6-4452-b2e9-c53472860aa1}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_method"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBlurFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBlurFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBlurFilterFactory = agcom.GUID(IBlurFilterFactory._uuid)
        vtable_offset_local = IBlurFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IBlurFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_method"] = IAGFUNCTYPE(pUnk, IID_IBlurFilterFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBlurFilterFactory.__dict__ and type(IBlurFilterFactory.__dict__[attrname]) == property:
            return IBlurFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBlurFilterFactory.")
    
    def initialize(self) -> "IBlurFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_method(self, method:"AgEStkGraphicsBlurMethod") -> "IBlurFilter":
        """Initialize a new instance with the specified blur method."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsBlurMethod, method) as arg_method, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_method"](arg_method.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{99188b11-f0f6-4452-b2e9-c53472860aa1}", IBlurFilterFactory)
agcls.AgTypeNameMap["IBlurFilterFactory"] = IBlurFilterFactory

class IBrightnessFilterFactory(object):
    """Adjusts the brightness of the source raster's color bands. The adjustment to brightness is a value between -1 and 1, corresponding to least bright to most bright."""
    _uuid = "{85e2696a-638c-4151-8ba4-e1fdef462598}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_adjustment"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBrightnessFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBrightnessFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBrightnessFilterFactory = agcom.GUID(IBrightnessFilterFactory._uuid)
        vtable_offset_local = IBrightnessFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IBrightnessFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_adjustment"] = IAGFUNCTYPE(pUnk, IID_IBrightnessFilterFactory, vtable_offset_local+2, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBrightnessFilterFactory.__dict__ and type(IBrightnessFilterFactory.__dict__[attrname]) == property:
            return IBrightnessFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBrightnessFilterFactory.")
    
    def initialize(self) -> "IBrightnessFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_adjustment(self, adjustment:float) -> "IBrightnessFilter":
        """Initializes a new instance with the adjustment to brightness."""
        with agmarshall.DOUBLE_arg(adjustment) as arg_adjustment, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_adjustment"](arg_adjustment.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{85e2696a-638c-4151-8ba4-e1fdef462598}", IBrightnessFilterFactory)
agcls.AgTypeNameMap["IBrightnessFilterFactory"] = IBrightnessFilterFactory

class IColorToLuminanceFilterFactory(object):
    """Extracts a luminance band derived from the color bands of the source raster."""
    _uuid = "{361263b5-d7ef-468a-9804-c1c9342ffeb8}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IColorToLuminanceFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IColorToLuminanceFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IColorToLuminanceFilterFactory = agcom.GUID(IColorToLuminanceFilterFactory._uuid)
        vtable_offset_local = IColorToLuminanceFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IColorToLuminanceFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IColorToLuminanceFilterFactory.__dict__ and type(IColorToLuminanceFilterFactory.__dict__[attrname]) == property:
            return IColorToLuminanceFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IColorToLuminanceFilterFactory.")
    
    def initialize(self) -> "IColorToLuminanceFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{361263b5-d7ef-468a-9804-c1c9342ffeb8}", IColorToLuminanceFilterFactory)
agcls.AgTypeNameMap["IColorToLuminanceFilterFactory"] = IColorToLuminanceFilterFactory

class IContrastFilterFactory(object):
    """Adjusts the contrast of the source raster. The adjustment to contrast is a value between -1 and 1, corresponding to least contrast to most contrast."""
    _uuid = "{d78a7285-c3ff-47b5-b5af-ea67faffae92}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_adjustment"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IContrastFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IContrastFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IContrastFilterFactory = agcom.GUID(IContrastFilterFactory._uuid)
        vtable_offset_local = IContrastFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IContrastFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_adjustment"] = IAGFUNCTYPE(pUnk, IID_IContrastFilterFactory, vtable_offset_local+2, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IContrastFilterFactory.__dict__ and type(IContrastFilterFactory.__dict__[attrname]) == property:
            return IContrastFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IContrastFilterFactory.")
    
    def initialize(self) -> "IContrastFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_adjustment(self, adjustment:float) -> "IContrastFilter":
        """Initializes a new instance with the adjustment to contrast."""
        with agmarshall.DOUBLE_arg(adjustment) as arg_adjustment, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_adjustment"](arg_adjustment.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{d78a7285-c3ff-47b5-b5af-ea67faffae92}", IContrastFilterFactory)
agcls.AgTypeNameMap["IContrastFilterFactory"] = IContrastFilterFactory

class IConvolutionFilterFactory(object):
    """Applies convolution to the source raster. Convolution is the modification of a pixel's value based on the values of its surrounding pixels. The kernel is the numerical matrix that is applied to each pixel in this process..."""
    _uuid = "{f262f8e7-74a5-440e-9754-d3c8a4196abf}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_kernel"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_kernel_and_divisor"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_kernel_divisor_and_offset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConvolutionFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConvolutionFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConvolutionFilterFactory = agcom.GUID(IConvolutionFilterFactory._uuid)
        vtable_offset_local = IConvolutionFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IConvolutionFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_kernel"] = IAGFUNCTYPE(pUnk, IID_IConvolutionFilterFactory, vtable_offset_local+2, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_kernel_and_divisor"] = IAGFUNCTYPE(pUnk, IID_IConvolutionFilterFactory, vtable_offset_local+3, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_kernel_divisor_and_offset"] = IAGFUNCTYPE(pUnk, IID_IConvolutionFilterFactory, vtable_offset_local+4, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConvolutionFilterFactory.__dict__ and type(IConvolutionFilterFactory.__dict__[attrname]) == property:
            return IConvolutionFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConvolutionFilterFactory.")
    
    def initialize(self) -> "IConvolutionFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_kernel(self, kernel:list) -> "IConvolutionFilter":
        """Initializes a new instance with the specified kernel."""
        with agmarshall.SAFEARRAY_arg(kernel) as arg_kernel, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_kernel"](byref(arg_kernel.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_kernel_and_divisor(self, kernel:list, divisor:float) -> "IConvolutionFilter":
        """Initializes a new instance with the specified kernel and divisor."""
        with agmarshall.SAFEARRAY_arg(kernel) as arg_kernel, \
             agmarshall.DOUBLE_arg(divisor) as arg_divisor, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_kernel_and_divisor"](byref(arg_kernel.COM_val), arg_divisor.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_kernel_divisor_and_offset(self, kernel:list, divisor:float, offset:float) -> "IConvolutionFilter":
        """Initializes a new instance with the specified kernel, divisor, and offset."""
        with agmarshall.SAFEARRAY_arg(kernel) as arg_kernel, \
             agmarshall.DOUBLE_arg(divisor) as arg_divisor, \
             agmarshall.DOUBLE_arg(offset) as arg_offset, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_kernel_divisor_and_offset"](byref(arg_kernel.COM_val), arg_divisor.COM_val, arg_offset.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{f262f8e7-74a5-440e-9754-d3c8a4196abf}", IConvolutionFilterFactory)
agcls.AgTypeNameMap["IConvolutionFilterFactory"] = IConvolutionFilterFactory

class IEdgeDetectFilterFactory(object):
    """Applies a convolution filter to detect edges in the source raster."""
    _uuid = "{d471ae80-2bf6-40d7-9c5b-48c08d0e3819}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_method"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEdgeDetectFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEdgeDetectFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEdgeDetectFilterFactory = agcom.GUID(IEdgeDetectFilterFactory._uuid)
        vtable_offset_local = IEdgeDetectFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IEdgeDetectFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_method"] = IAGFUNCTYPE(pUnk, IID_IEdgeDetectFilterFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEdgeDetectFilterFactory.__dict__ and type(IEdgeDetectFilterFactory.__dict__[attrname]) == property:
            return IEdgeDetectFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEdgeDetectFilterFactory.")
    
    def initialize(self) -> "IEdgeDetectFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_method(self, method:"AgEStkGraphicsEdgeDetectMethod") -> "IEdgeDetectFilter":
        """Initializes a new instance with the specified edge detect method."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsEdgeDetectMethod, method) as arg_method, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_method"](arg_method.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{d471ae80-2bf6-40d7-9c5b-48c08d0e3819}", IEdgeDetectFilterFactory)
agcls.AgTypeNameMap["IEdgeDetectFilterFactory"] = IEdgeDetectFilterFactory

class IFilteringRasterStreamFactory(object):
    """A class decorator for applying a raster filter to each update of a raster stream. Can be used to apply filters to videos and other raster streams as they are updated."""
    _uuid = "{3c0a84bb-9330-422b-808e-6f9cf0aa3055}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IFilteringRasterStreamFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IFilteringRasterStreamFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IFilteringRasterStreamFactory = agcom.GUID(IFilteringRasterStreamFactory._uuid)
        vtable_offset_local = IFilteringRasterStreamFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IFilteringRasterStreamFactory, vtable_offset_local+1, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFilteringRasterStreamFactory.__dict__ and type(IFilteringRasterStreamFactory.__dict__[attrname]) == property:
            return IFilteringRasterStreamFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFilteringRasterStreamFactory.")
    
    def initialize(self, rasterStream:"IRasterStream", filter:"IRasterFilter") -> "IFilteringRasterStream":
        """Initializes a new instance with a raster stream and the raster filter that will be applied to each update of that stream."""
        with agmarshall.AgInterface_in_arg(rasterStream, IRasterStream) as arg_rasterStream, \
             agmarshall.AgInterface_in_arg(filter, IRasterFilter) as arg_filter, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](arg_rasterStream.COM_val, arg_filter.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{3c0a84bb-9330-422b-808e-6f9cf0aa3055}", IFilteringRasterStreamFactory)
agcls.AgTypeNameMap["IFilteringRasterStreamFactory"] = IFilteringRasterStreamFactory

class IFlipFilterFactory(object):
    """Flips the source raster along the given flip axis."""
    _uuid = "{0f7bc6a1-42ac-41f0-8f42-d915fba6b859}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_flip_axis"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IFlipFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IFlipFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IFlipFilterFactory = agcom.GUID(IFlipFilterFactory._uuid)
        vtable_offset_local = IFlipFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IFlipFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_flip_axis"] = IAGFUNCTYPE(pUnk, IID_IFlipFilterFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFlipFilterFactory.__dict__ and type(IFlipFilterFactory.__dict__[attrname]) == property:
            return IFlipFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFlipFilterFactory.")
    
    def initialize(self) -> "IFlipFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_flip_axis(self, flipAxis:"AgEStkGraphicsFlipAxis") -> "IFlipFilter":
        """Initializes a new instance with the specified flip axis."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsFlipAxis, flipAxis) as arg_flipAxis, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_flip_axis"](arg_flipAxis.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{0f7bc6a1-42ac-41f0-8f42-d915fba6b859}", IFlipFilterFactory)
agcls.AgTypeNameMap["IFlipFilterFactory"] = IFlipFilterFactory

class IGammaCorrectionFilterFactory(object):
    """Applies gamma correction to the source raster. The gamma is a value between .2 and 5. The default gamma value is 2.2."""
    _uuid = "{4e0be3d1-f9ca-47b6-bc7b-31fd98c824a6}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_gamma"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGammaCorrectionFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGammaCorrectionFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGammaCorrectionFilterFactory = agcom.GUID(IGammaCorrectionFilterFactory._uuid)
        vtable_offset_local = IGammaCorrectionFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IGammaCorrectionFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_gamma"] = IAGFUNCTYPE(pUnk, IID_IGammaCorrectionFilterFactory, vtable_offset_local+2, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGammaCorrectionFilterFactory.__dict__ and type(IGammaCorrectionFilterFactory.__dict__[attrname]) == property:
            return IGammaCorrectionFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGammaCorrectionFilterFactory.")
    
    def initialize(self) -> "IGammaCorrectionFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_gamma(self, gamma:float) -> "IGammaCorrectionFilter":
        """Initializes a new instance with the specified gamma."""
        with agmarshall.DOUBLE_arg(gamma) as arg_gamma, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_gamma"](arg_gamma.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4e0be3d1-f9ca-47b6-bc7b-31fd98c824a6}", IGammaCorrectionFilterFactory)
agcls.AgTypeNameMap["IGammaCorrectionFilterFactory"] = IGammaCorrectionFilterFactory

class IGaussianBlurFilterFactory(object):
    """Applies a convolution filter to blur the source raster using the Gaussian function."""
    _uuid = "{c4f3b576-0d25-4b06-9a79-773821d5c97b}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGaussianBlurFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGaussianBlurFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGaussianBlurFilterFactory = agcom.GUID(IGaussianBlurFilterFactory._uuid)
        vtable_offset_local = IGaussianBlurFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IGaussianBlurFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGaussianBlurFilterFactory.__dict__ and type(IGaussianBlurFilterFactory.__dict__[attrname]) == property:
            return IGaussianBlurFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGaussianBlurFilterFactory.")
    
    def initialize(self) -> "IGaussianBlurFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{c4f3b576-0d25-4b06-9a79-773821d5c97b}", IGaussianBlurFilterFactory)
agcls.AgTypeNameMap["IGaussianBlurFilterFactory"] = IGaussianBlurFilterFactory

class IGradientDetectFilterFactory(object):
    """Applies a convolution filter to detect gradients in the source raster."""
    _uuid = "{ab421e7c-80f3-4503-a29c-5becb2178d44}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_method"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGradientDetectFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGradientDetectFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGradientDetectFilterFactory = agcom.GUID(IGradientDetectFilterFactory._uuid)
        vtable_offset_local = IGradientDetectFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IGradientDetectFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_method"] = IAGFUNCTYPE(pUnk, IID_IGradientDetectFilterFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGradientDetectFilterFactory.__dict__ and type(IGradientDetectFilterFactory.__dict__[attrname]) == property:
            return IGradientDetectFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGradientDetectFilterFactory.")
    
    def initialize(self) -> "IGradientDetectFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_method(self, method:"AgEStkGraphicsGradientDetectMethod") -> "IGradientDetectFilter":
        """Initializes a new instance with specified gradient detect method."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsGradientDetectMethod, method) as arg_method, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_method"](arg_method.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{ab421e7c-80f3-4503-a29c-5becb2178d44}", IGradientDetectFilterFactory)
agcls.AgTypeNameMap["IGradientDetectFilterFactory"] = IGradientDetectFilterFactory

class IJpeg2000WriterInitializer(object):
    """Converts an image, such as a BMP, to a GeoJP2 file that can be used as an image globe overlay."""
    _uuid = "{e2227905-c4e6-46ab-a89f-6d53e201e1a3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_write_string"] = _raise_uninitialized_error
        self.__dict__["_write_extent_string"] = _raise_uninitialized_error
        self.__dict__["_write_extent_and_sub_extent_string"] = _raise_uninitialized_error
        self.__dict__["_write_extent_and_sub_extent_transparent_color_string"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IJpeg2000WriterInitializer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IJpeg2000WriterInitializer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IJpeg2000WriterInitializer = agcom.GUID(IJpeg2000WriterInitializer._uuid)
        vtable_offset_local = IJpeg2000WriterInitializer._vtable_offset - 1
        self.__dict__["_write_string"] = IAGFUNCTYPE(pUnk, IID_IJpeg2000WriterInitializer, vtable_offset_local+1, agcom.BSTR, agcom.LONG, agcom.INT, agcom.BSTR, agcom.VARIANT_BOOL)
        self.__dict__["_write_extent_string"] = IAGFUNCTYPE(pUnk, IID_IJpeg2000WriterInitializer, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.SAFEARRAY), agcom.LONG, agcom.INT, agcom.BSTR, agcom.VARIANT_BOOL)
        self.__dict__["_write_extent_and_sub_extent_string"] = IAGFUNCTYPE(pUnk, IID_IJpeg2000WriterInitializer, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG, agcom.INT, agcom.BSTR, agcom.VARIANT_BOOL)
        self.__dict__["_write_extent_and_sub_extent_transparent_color_string"] = IAGFUNCTYPE(pUnk, IID_IJpeg2000WriterInitializer, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), agcom.LONG, agcom.INT, agcom.BSTR, agcom.VARIANT_BOOL, agcom.OLE_COLOR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IJpeg2000WriterInitializer.__dict__ and type(IJpeg2000WriterInitializer.__dict__[attrname]) == property:
            return IJpeg2000WriterInitializer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IJpeg2000WriterInitializer.")
    
    def write_string(self, imageUri:str, compressionProfile:"AgEStkGraphicsJpeg2000CompressionProfile", compressionRate:int, jpeg2000Uri:str, overwriteExistingFile:bool) -> None:
        """Converts an image, such as a BMP, to a GeoJP2 file that can be used as an image globe overlay. The extent of the image must be in the image, as in a GeoTIFF."""
        with agmarshall.BSTR_arg(imageUri) as arg_imageUri, \
             agmarshall.AgEnum_arg(AgEStkGraphicsJpeg2000CompressionProfile, compressionProfile) as arg_compressionProfile, \
             agmarshall.INT_arg(compressionRate) as arg_compressionRate, \
             agmarshall.BSTR_arg(jpeg2000Uri) as arg_jpeg2000Uri, \
             agmarshall.VARIANT_BOOL_arg(overwriteExistingFile) as arg_overwriteExistingFile:
            agcls.evaluate_hresult(self.__dict__["_write_string"](arg_imageUri.COM_val, arg_compressionProfile.COM_val, arg_compressionRate.COM_val, arg_jpeg2000Uri.COM_val, arg_overwriteExistingFile.COM_val))

    def write_extent_string(self, imageUri:str, extent:list, compressionProfile:"AgEStkGraphicsJpeg2000CompressionProfile", compressionRate:int, jpeg2000Uri:str, overwriteExistingFile:bool) -> None:
        """Converts an image, such as a BMP, to a GeoJP2 file that can be used as an image globe overlay. The extent of the image can be defined as an input parameter if necessary."""
        with agmarshall.BSTR_arg(imageUri) as arg_imageUri, \
             agmarshall.SAFEARRAY_arg(extent) as arg_extent, \
             agmarshall.AgEnum_arg(AgEStkGraphicsJpeg2000CompressionProfile, compressionProfile) as arg_compressionProfile, \
             agmarshall.INT_arg(compressionRate) as arg_compressionRate, \
             agmarshall.BSTR_arg(jpeg2000Uri) as arg_jpeg2000Uri, \
             agmarshall.VARIANT_BOOL_arg(overwriteExistingFile) as arg_overwriteExistingFile:
            agcls.evaluate_hresult(self.__dict__["_write_extent_string"](arg_imageUri.COM_val, byref(arg_extent.COM_val), arg_compressionProfile.COM_val, arg_compressionRate.COM_val, arg_jpeg2000Uri.COM_val, arg_overwriteExistingFile.COM_val))

    def write_extent_and_sub_extent_string(self, imageUri:str, extent:list, subExtent:list, compressionProfile:"AgEStkGraphicsJpeg2000CompressionProfile", compressionRate:int, jpeg2000Uri:str, overwriteExistingFile:bool) -> None:
        """Converts an image, such as a BMP, to a GeoJP2 file that can be used as an image globe overlay. The extent of the image can be defined as an input parameter if necessary."""
        with agmarshall.BSTR_arg(imageUri) as arg_imageUri, \
             agmarshall.SAFEARRAY_arg(extent) as arg_extent, \
             agmarshall.SAFEARRAY_arg(subExtent) as arg_subExtent, \
             agmarshall.AgEnum_arg(AgEStkGraphicsJpeg2000CompressionProfile, compressionProfile) as arg_compressionProfile, \
             agmarshall.INT_arg(compressionRate) as arg_compressionRate, \
             agmarshall.BSTR_arg(jpeg2000Uri) as arg_jpeg2000Uri, \
             agmarshall.VARIANT_BOOL_arg(overwriteExistingFile) as arg_overwriteExistingFile:
            agcls.evaluate_hresult(self.__dict__["_write_extent_and_sub_extent_string"](arg_imageUri.COM_val, byref(arg_extent.COM_val), byref(arg_subExtent.COM_val), arg_compressionProfile.COM_val, arg_compressionRate.COM_val, arg_jpeg2000Uri.COM_val, arg_overwriteExistingFile.COM_val))

    def write_extent_and_sub_extent_transparent_color_string(self, imageUri:str, extent:list, subExtent:list, compressionProfile:"AgEStkGraphicsJpeg2000CompressionProfile", compressionRate:int, jpeg2000Uri:str, overwriteExistingFile:bool, transparentColor:agcolor.Color) -> None:
        """Converts an image, such as a BMP, to a GeoJP2 file that can be used as an image globe overlay. The extent of the image can be defined as an input parameter if necessary."""
        with agmarshall.BSTR_arg(imageUri) as arg_imageUri, \
             agmarshall.SAFEARRAY_arg(extent) as arg_extent, \
             agmarshall.SAFEARRAY_arg(subExtent) as arg_subExtent, \
             agmarshall.AgEnum_arg(AgEStkGraphicsJpeg2000CompressionProfile, compressionProfile) as arg_compressionProfile, \
             agmarshall.INT_arg(compressionRate) as arg_compressionRate, \
             agmarshall.BSTR_arg(jpeg2000Uri) as arg_jpeg2000Uri, \
             agmarshall.VARIANT_BOOL_arg(overwriteExistingFile) as arg_overwriteExistingFile, \
             agmarshall.OLE_COLOR_arg(transparentColor) as arg_transparentColor:
            agcls.evaluate_hresult(self.__dict__["_write_extent_and_sub_extent_transparent_color_string"](arg_imageUri.COM_val, byref(arg_extent.COM_val), byref(arg_subExtent.COM_val), arg_compressionProfile.COM_val, arg_compressionRate.COM_val, arg_jpeg2000Uri.COM_val, arg_overwriteExistingFile.COM_val, arg_transparentColor.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{e2227905-c4e6-46ab-a89f-6d53e201e1a3}", IJpeg2000WriterInitializer)
agcls.AgTypeNameMap["IJpeg2000WriterInitializer"] = IJpeg2000WriterInitializer

class ILevelsFilterFactory(object):
    """Adjusts the band levels of the source raster linearly."""
    _uuid = "{30236afe-b593-4e6c-9e61-099216f14db1}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ILevelsFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ILevelsFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ILevelsFilterFactory = agcom.GUID(ILevelsFilterFactory._uuid)
        vtable_offset_local = ILevelsFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ILevelsFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ILevelsFilterFactory.__dict__ and type(ILevelsFilterFactory.__dict__[attrname]) == property:
            return ILevelsFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ILevelsFilterFactory.")
    
    def initialize(self) -> "ILevelsFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{30236afe-b593-4e6c-9e61-099216f14db1}", ILevelsFilterFactory)
agcls.AgTypeNameMap["ILevelsFilterFactory"] = ILevelsFilterFactory

class IProjectionRasterStreamPluginActivatorFactory(object):
    """The Activator class provides methods to load COM plugins that implement projection and raster streaming. For more information about the projection and raster plugins, see the STK Programming Interface."""
    _uuid = "{d7df6203-7dc8-4f07-8211-78e6d3c268a1}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProjectionRasterStreamPluginActivatorFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProjectionRasterStreamPluginActivatorFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProjectionRasterStreamPluginActivatorFactory = agcom.GUID(IProjectionRasterStreamPluginActivatorFactory._uuid)
        vtable_offset_local = IProjectionRasterStreamPluginActivatorFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IProjectionRasterStreamPluginActivatorFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProjectionRasterStreamPluginActivatorFactory.__dict__ and type(IProjectionRasterStreamPluginActivatorFactory.__dict__[attrname]) == property:
            return IProjectionRasterStreamPluginActivatorFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProjectionRasterStreamPluginActivatorFactory.")
    
    def initialize(self) -> "IProjectionRasterStreamPluginActivator":
        """Initializes a new instance of the Activator type."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{d7df6203-7dc8-4f07-8211-78e6d3c268a1}", IProjectionRasterStreamPluginActivatorFactory)
agcls.AgTypeNameMap["IProjectionRasterStreamPluginActivatorFactory"] = IProjectionRasterStreamPluginActivatorFactory

class IRasterFactory(object):
    """A raster dataset. A raster consists of one or more bands, or sets of values, which are most commonly associated with colors when the raster represents an image..."""
    _uuid = "{b4777c93-7685-452a-87df-8fd8bfd10e6f}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize_with_string_uri"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_string_uri_xy_width_and_height"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_raster"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRasterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRasterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRasterFactory = agcom.GUID(IRasterFactory._uuid)
        vtable_offset_local = IRasterFactory._vtable_offset - 1
        self.__dict__["_initialize_with_string_uri"] = IAGFUNCTYPE(pUnk, IID_IRasterFactory, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_string_uri_xy_width_and_height"] = IAGFUNCTYPE(pUnk, IID_IRasterFactory, vtable_offset_local+2, agcom.BSTR, agcom.INT, agcom.INT, agcom.INT, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_raster"] = IAGFUNCTYPE(pUnk, IID_IRasterFactory, vtable_offset_local+3, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRasterFactory.__dict__ and type(IRasterFactory.__dict__[attrname]) == property:
            return IRasterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRasterFactory.")
    
    def initialize_with_string_uri(self, uri:str) -> "IRaster":
        """Initializes a raster from a Uri, which can be a file, HTTP, HTTPS, or FTP source. See raster for a list of supported formats."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_string_uri"](arg_uri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_string_uri_xy_width_and_height(self, uri:str, x:int, y:int, width:int, height:int) -> "IRaster":
        """Initializes a raster from a Uri. Only the specified subsection of the raster is read. See raster for a list of supported formats."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.INT_arg(x) as arg_x, \
             agmarshall.INT_arg(y) as arg_y, \
             agmarshall.INT_arg(width) as arg_width, \
             agmarshall.INT_arg(height) as arg_height, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_string_uri_xy_width_and_height"](arg_uri.COM_val, arg_x.COM_val, arg_y.COM_val, arg_width.COM_val, arg_height.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_raster(self, raster:"IRaster") -> "IRaster":
        """Initializes a raster from another raster."""
        with agmarshall.AgInterface_in_arg(raster, IRaster) as arg_raster, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_raster"](arg_raster.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{b4777c93-7685-452a-87df-8fd8bfd10e6f}", IRasterFactory)
agcls.AgTypeNameMap["IRasterFactory"] = IRasterFactory

class IRasterAttributesFactory(object):
    """The attributes describing a raster dataset. raster attributes define the memory layout of a raster, and includes properties defining the order of each raster band that the raster contains, as specified by the raster format..."""
    _uuid = "{5e2aeff9-22ff-4a0f-984d-dc0d92d738c9}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize_with_format"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_format_and_type"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_format_type_and_orientation"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_format_type_orientation_and_alignment"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_format_type_orientation_alignment_and_ratio"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_raster"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRasterAttributesFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRasterAttributesFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRasterAttributesFactory = agcom.GUID(IRasterAttributesFactory._uuid)
        vtable_offset_local = IRasterAttributesFactory._vtable_offset - 1
        self.__dict__["_initialize_with_format"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributesFactory, vtable_offset_local+1, agcom.INT, agcom.INT, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_format_and_type"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributesFactory, vtable_offset_local+2, agcom.INT, agcom.INT, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_format_type_and_orientation"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributesFactory, vtable_offset_local+3, agcom.INT, agcom.INT, agcom.LONG, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_format_type_orientation_and_alignment"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributesFactory, vtable_offset_local+4, agcom.INT, agcom.INT, agcom.LONG, agcom.LONG, agcom.LONG, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_format_type_orientation_alignment_and_ratio"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributesFactory, vtable_offset_local+5, agcom.INT, agcom.INT, agcom.LONG, agcom.LONG, agcom.LONG, agcom.INT, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_raster"] = IAGFUNCTYPE(pUnk, IID_IRasterAttributesFactory, vtable_offset_local+6, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRasterAttributesFactory.__dict__ and type(IRasterAttributesFactory.__dict__[attrname]) == property:
            return IRasterAttributesFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRasterAttributesFactory.")
    
    def initialize_with_format(self, width:int, height:int, rasterFormat:"AgEStkGraphicsRasterFormat") -> "IRasterAttributes":
        """Initializes a new instance with the width and height of the raster in pixels, and the given raster format."""
        with agmarshall.INT_arg(width) as arg_width, \
             agmarshall.INT_arg(height) as arg_height, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRasterFormat, rasterFormat) as arg_rasterFormat, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_format"](arg_width.COM_val, arg_height.COM_val, arg_rasterFormat.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_format_and_type(self, width:int, height:int, rasterFormat:"AgEStkGraphicsRasterFormat", rasterType:"AgEStkGraphicsRasterType") -> "IRasterAttributes":
        """Initializes a new instance with the width and height of the raster in pixels, and the given raster format and raster type."""
        with agmarshall.INT_arg(width) as arg_width, \
             agmarshall.INT_arg(height) as arg_height, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRasterFormat, rasterFormat) as arg_rasterFormat, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRasterType, rasterType) as arg_rasterType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_format_and_type"](arg_width.COM_val, arg_height.COM_val, arg_rasterFormat.COM_val, arg_rasterType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_format_type_and_orientation(self, width:int, height:int, rasterFormat:"AgEStkGraphicsRasterFormat", rasterType:"AgEStkGraphicsRasterType", rasterOrientation:"AgEStkGraphicsRasterOrientation") -> "IRasterAttributes":
        """Initializes a new instance with the width and height of the raster in pixels, and the given raster format, raster type, and raster orientation."""
        with agmarshall.INT_arg(width) as arg_width, \
             agmarshall.INT_arg(height) as arg_height, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRasterFormat, rasterFormat) as arg_rasterFormat, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRasterType, rasterType) as arg_rasterType, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRasterOrientation, rasterOrientation) as arg_rasterOrientation, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_format_type_and_orientation"](arg_width.COM_val, arg_height.COM_val, arg_rasterFormat.COM_val, arg_rasterType.COM_val, arg_rasterOrientation.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_format_type_orientation_and_alignment(self, width:int, height:int, rasterFormat:"AgEStkGraphicsRasterFormat", rasterType:"AgEStkGraphicsRasterType", rasterOrientation:"AgEStkGraphicsRasterOrientation", rowAlignment:int) -> "IRasterAttributes":
        """Initializes a new instance with the width and height of the raster in pixels, and the given raster format, raster type, raster orientation, and row alignment."""
        with agmarshall.INT_arg(width) as arg_width, \
             agmarshall.INT_arg(height) as arg_height, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRasterFormat, rasterFormat) as arg_rasterFormat, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRasterType, rasterType) as arg_rasterType, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRasterOrientation, rasterOrientation) as arg_rasterOrientation, \
             agmarshall.INT_arg(rowAlignment) as arg_rowAlignment, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_format_type_orientation_and_alignment"](arg_width.COM_val, arg_height.COM_val, arg_rasterFormat.COM_val, arg_rasterType.COM_val, arg_rasterOrientation.COM_val, arg_rowAlignment.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_format_type_orientation_alignment_and_ratio(self, width:int, height:int, rasterFormat:"AgEStkGraphicsRasterFormat", rasterType:"AgEStkGraphicsRasterType", rasterOrientation:"AgEStkGraphicsRasterOrientation", rowAlignment:int, pixelAspectRatio:float) -> "IRasterAttributes":
        """Initializes a new instance with the width and height of the raster in pixels, and the given raster format, raster type, raster orientation, row alignment, and pixel aspect ratio."""
        with agmarshall.INT_arg(width) as arg_width, \
             agmarshall.INT_arg(height) as arg_height, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRasterFormat, rasterFormat) as arg_rasterFormat, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRasterType, rasterType) as arg_rasterType, \
             agmarshall.AgEnum_arg(AgEStkGraphicsRasterOrientation, rasterOrientation) as arg_rasterOrientation, \
             agmarshall.INT_arg(rowAlignment) as arg_rowAlignment, \
             agmarshall.DOUBLE_arg(pixelAspectRatio) as arg_pixelAspectRatio, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_format_type_orientation_alignment_and_ratio"](arg_width.COM_val, arg_height.COM_val, arg_rasterFormat.COM_val, arg_rasterType.COM_val, arg_rasterOrientation.COM_val, arg_rowAlignment.COM_val, arg_pixelAspectRatio.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_raster(self, raster:"IRaster") -> "IRasterAttributes":
        """Initializes a new instance with the attributes of the specified raster"""
        with agmarshall.AgInterface_in_arg(raster, IRaster) as arg_raster, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_raster"](arg_raster.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5e2aeff9-22ff-4a0f-984d-dc0d92d738c9}", IRasterAttributesFactory)
agcls.AgTypeNameMap["IRasterAttributesFactory"] = IRasterAttributesFactory

class IRotateFilterFactory(object):
    """Rotates the source raster clockwise by the specified angle."""
    _uuid = "{413b5f7f-9fa5-48ba-bb49-d57948acc6ed}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_angle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRotateFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRotateFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRotateFilterFactory = agcom.GUID(IRotateFilterFactory._uuid)
        vtable_offset_local = IRotateFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IRotateFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_angle"] = IAGFUNCTYPE(pUnk, IID_IRotateFilterFactory, vtable_offset_local+2, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRotateFilterFactory.__dict__ and type(IRotateFilterFactory.__dict__[attrname]) == property:
            return IRotateFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRotateFilterFactory.")
    
    def initialize(self) -> "IRotateFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_angle(self, rotateAngle:float) -> "IRotateFilter":
        """Initializes a new instance with a counterclockwise rotation angle."""
        with agmarshall.DOUBLE_arg(rotateAngle) as arg_rotateAngle, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_angle"](arg_rotateAngle.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{413b5f7f-9fa5-48ba-bb49-d57948acc6ed}", IRotateFilterFactory)
agcls.AgTypeNameMap["IRotateFilterFactory"] = IRotateFilterFactory

class ISequenceFilterFactory(object):
    """Applies a sequence of filters to the source raster in the order in which they were added. When continue on failure is set to true, subsequent filters will still be applied to the source raster even if one or more filters in the sequence cannot be applied."""
    _uuid = "{b3f075e4-7de5-4d8c-adbe-89862537e530}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISequenceFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISequenceFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISequenceFilterFactory = agcom.GUID(ISequenceFilterFactory._uuid)
        vtable_offset_local = ISequenceFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ISequenceFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISequenceFilterFactory.__dict__ and type(ISequenceFilterFactory.__dict__[attrname]) == property:
            return ISequenceFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISequenceFilterFactory.")
    
    def initialize(self) -> "ISequenceFilter":
        """Initializes a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{b3f075e4-7de5-4d8c-adbe-89862537e530}", ISequenceFilterFactory)
agcls.AgTypeNameMap["ISequenceFilterFactory"] = ISequenceFilterFactory

class ISharpenFilterFactory(object):
    """Applies a convolution filter to increase the sharpness of the source raster."""
    _uuid = "{953f907c-8223-40fa-9827-cb08278d5af4}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_method"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISharpenFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISharpenFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISharpenFilterFactory = agcom.GUID(ISharpenFilterFactory._uuid)
        vtable_offset_local = ISharpenFilterFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ISharpenFilterFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_method"] = IAGFUNCTYPE(pUnk, IID_ISharpenFilterFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISharpenFilterFactory.__dict__ and type(ISharpenFilterFactory.__dict__[attrname]) == property:
            return ISharpenFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISharpenFilterFactory.")
    
    def initialize(self) -> "ISharpenFilter":
        """Initialize a new instance."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_method(self, method:"AgEStkGraphicsSharpenMethod") -> "ISharpenFilter":
        """Initialize a new instance with the specified sharpen method."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSharpenMethod, method) as arg_method, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_method"](arg_method.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{953f907c-8223-40fa-9827-cb08278d5af4}", ISharpenFilterFactory)
agcls.AgTypeNameMap["ISharpenFilterFactory"] = ISharpenFilterFactory

class IVideoStreamFactory(object):
    """A raster stream that streams from a video. The video can be read from a file, or streamed from an HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""
    _uuid = "{fbde7847-ccff-4c4e-83cf-5f7b05468709}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize_with_string_uri"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_string_uri_and_audio"] = _raise_uninitialized_error
        self.__dict__["_initialize_audio_video_with_string_uri"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVideoStreamFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVideoStreamFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVideoStreamFactory = agcom.GUID(IVideoStreamFactory._uuid)
        vtable_offset_local = IVideoStreamFactory._vtable_offset - 1
        self.__dict__["_initialize_with_string_uri"] = IAGFUNCTYPE(pUnk, IID_IVideoStreamFactory, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_string_uri_and_audio"] = IAGFUNCTYPE(pUnk, IID_IVideoStreamFactory, vtable_offset_local+2, agcom.BSTR, agcom.VARIANT_BOOL, POINTER(agcom.PVOID))
        self.__dict__["_initialize_audio_video_with_string_uri"] = IAGFUNCTYPE(pUnk, IID_IVideoStreamFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVideoStreamFactory.__dict__ and type(IVideoStreamFactory.__dict__[attrname]) == property:
            return IVideoStreamFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVideoStreamFactory.")
    
    def initialize_with_string_uri(self, uri:str) -> "IVideoStream":
        """Initializes the video stream from a Uri, which can be a file, HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_string_uri"](arg_uri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_string_uri_and_audio(self, uri:str, loadAudio:bool) -> "IVideoStream":
        """Initializes the video stream from a Uri, which can be a file, HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.VARIANT_BOOL_arg(loadAudio) as arg_loadAudio, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_string_uri_and_audio"](arg_uri.COM_val, arg_loadAudio.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_audio_video_with_string_uri(self, uri:str, audioUri:str) -> "IVideoStream":
        """Initializes the video stream from a Uri, which can be a file, HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.BSTR_arg(audioUri) as arg_audioUri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_audio_video_with_string_uri"](arg_uri.COM_val, arg_audioUri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{fbde7847-ccff-4c4e-83cf-5f7b05468709}", IVideoStreamFactory)
agcls.AgTypeNameMap["IVideoStreamFactory"] = IVideoStreamFactory

class IMarkerBatchPrimitiveFactory(object):
    """ Renders one or more markers in the 3D scene. Markers are 2D images that always face the viewer which can be sized in pixels or meters. Markers are also referred to as sprites or billboards..."""
    _uuid = "{02a33d9e-cfb3-41c8-be66-e452ae1b7ac3}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_set_hint"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_size_source"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_size_source_and_sort_order"] = _raise_uninitialized_error
        self.__dict__["_initialize_size_source_sort_order_and_set_hint"] = _raise_uninitialized_error
        self.__dict__["_initialize_size_source_sort_order_set_hint_and_rendering_method"] = _raise_uninitialized_error
        self.__dict__["_supported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMarkerBatchPrimitiveFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMarkerBatchPrimitiveFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMarkerBatchPrimitiveFactory = agcom.GUID(IMarkerBatchPrimitiveFactory._uuid)
        vtable_offset_local = IMarkerBatchPrimitiveFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_set_hint"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_size_source"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveFactory, vtable_offset_local+3, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_size_source_and_sort_order"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveFactory, vtable_offset_local+4, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_size_source_sort_order_and_set_hint"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveFactory, vtable_offset_local+5, agcom.LONG, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_size_source_sort_order_set_hint_and_rendering_method"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveFactory, vtable_offset_local+6, agcom.LONG, agcom.LONG, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_supported"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveFactory, vtable_offset_local+7, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMarkerBatchPrimitiveFactory.__dict__ and type(IMarkerBatchPrimitiveFactory.__dict__[attrname]) == property:
            return IMarkerBatchPrimitiveFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMarkerBatchPrimitiveFactory.")
    
    def initialize(self) -> "IMarkerBatchPrimitive":
        """Initializes a default marker batch primitive..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_set_hint(self, setHint:"AgEStkGraphicsSetHint") -> "IMarkerBatchPrimitive":
        """Initializes a marker batch primitive with the specified setHint..."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSetHint, setHint) as arg_setHint, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_set_hint"](arg_setHint.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_size_source(self, sizeSource:"AgEStkGraphicsMarkerBatchSizeSource") -> "IMarkerBatchPrimitive":
        """Initializes a marker batch primitive with the specified sizeSource..."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchSizeSource, sizeSource) as arg_sizeSource, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_size_source"](arg_sizeSource.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_size_source_and_sort_order(self, sizeSource:"AgEStkGraphicsMarkerBatchSizeSource", sortOrder:"AgEStkGraphicsMarkerBatchSortOrder") -> "IMarkerBatchPrimitive":
        """Initializes a marker batch primitive with the specified sizeSource and sortOrder..."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchSizeSource, sizeSource) as arg_sizeSource, \
             agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchSortOrder, sortOrder) as arg_sortOrder, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_size_source_and_sort_order"](arg_sizeSource.COM_val, arg_sortOrder.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_size_source_sort_order_and_set_hint(self, sizeSource:"AgEStkGraphicsMarkerBatchSizeSource", sortOrder:"AgEStkGraphicsMarkerBatchSortOrder", setHint:"AgEStkGraphicsSetHint") -> "IMarkerBatchPrimitive":
        """Initializes a marker batch primitive with the specified sizeSource, sortOrder, and setHint. This is equivalent to constructing a marker batch with the specified arguments and a marker batch rendering method of Automatic."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchSizeSource, sizeSource) as arg_sizeSource, \
             agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchSortOrder, sortOrder) as arg_sortOrder, \
             agmarshall.AgEnum_arg(AgEStkGraphicsSetHint, setHint) as arg_setHint, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_size_source_sort_order_and_set_hint"](arg_sizeSource.COM_val, arg_sortOrder.COM_val, arg_setHint.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_size_source_sort_order_set_hint_and_rendering_method(self, sizeSource:"AgEStkGraphicsMarkerBatchSizeSource", sortOrder:"AgEStkGraphicsMarkerBatchSortOrder", setHint:"AgEStkGraphicsSetHint", renderingMethod:"AgEStkGraphicsMarkerBatchRenderingMethod") -> "IMarkerBatchPrimitive":
        """Initializes a marker batch primitive with the specified arguments."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchSizeSource, sizeSource) as arg_sizeSource, \
             agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchSortOrder, sortOrder) as arg_sortOrder, \
             agmarshall.AgEnum_arg(AgEStkGraphicsSetHint, setHint) as arg_setHint, \
             agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchRenderingMethod, renderingMethod) as arg_renderingMethod, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_size_source_sort_order_set_hint_and_rendering_method"](arg_sizeSource.COM_val, arg_sortOrder.COM_val, arg_setHint.COM_val, arg_renderingMethod.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def supported(self, renderingMethod:"AgEStkGraphicsMarkerBatchRenderingMethod") -> bool:
        """Determines whether or not the video card supports the marker batch primitive with the given renderingMethod."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsMarkerBatchRenderingMethod, renderingMethod) as arg_renderingMethod, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_supported"](arg_renderingMethod.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{02a33d9e-cfb3-41c8-be66-e452ae1b7ac3}", IMarkerBatchPrimitiveFactory)
agcls.AgTypeNameMap["IMarkerBatchPrimitiveFactory"] = IMarkerBatchPrimitiveFactory

class IMarkerBatchPrimitiveOptionalParametersFactory(object):
    """Optional per-marker parameters for marker batch primitive that overrides the marker batch's per-batch parameters..."""
    _uuid = "{9b29c9ab-8fd6-4f2b-8183-b504e319617e}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMarkerBatchPrimitiveOptionalParametersFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMarkerBatchPrimitiveOptionalParametersFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMarkerBatchPrimitiveOptionalParametersFactory = agcom.GUID(IMarkerBatchPrimitiveOptionalParametersFactory._uuid)
        vtable_offset_local = IMarkerBatchPrimitiveOptionalParametersFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IMarkerBatchPrimitiveOptionalParametersFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMarkerBatchPrimitiveOptionalParametersFactory.__dict__ and type(IMarkerBatchPrimitiveOptionalParametersFactory.__dict__[attrname]) == property:
            return IMarkerBatchPrimitiveOptionalParametersFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMarkerBatchPrimitiveOptionalParametersFactory.")
    
    def initialize(self) -> "IMarkerBatchPrimitiveOptionalParameters":
        """Initializes default marker batch primitive optional parameters. All per-marker parameters are initially empty."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{9b29c9ab-8fd6-4f2b-8183-b504e319617e}", IMarkerBatchPrimitiveOptionalParametersFactory)
agcls.AgTypeNameMap["IMarkerBatchPrimitiveOptionalParametersFactory"] = IMarkerBatchPrimitiveOptionalParametersFactory

class IMaximumCountPathPrimitiveUpdatePolicyFactory(object):
    """path primitive update policy that removes points from remove location when the number of points in the path exceeds maximum count."""
    _uuid = "{046383cc-b5b9-4ff5-b662-701e694170ba}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_parameters"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMaximumCountPathPrimitiveUpdatePolicyFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMaximumCountPathPrimitiveUpdatePolicyFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMaximumCountPathPrimitiveUpdatePolicyFactory = agcom.GUID(IMaximumCountPathPrimitiveUpdatePolicyFactory._uuid)
        vtable_offset_local = IMaximumCountPathPrimitiveUpdatePolicyFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IMaximumCountPathPrimitiveUpdatePolicyFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_parameters"] = IAGFUNCTYPE(pUnk, IID_IMaximumCountPathPrimitiveUpdatePolicyFactory, vtable_offset_local+2, agcom.INT, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMaximumCountPathPrimitiveUpdatePolicyFactory.__dict__ and type(IMaximumCountPathPrimitiveUpdatePolicyFactory.__dict__[attrname]) == property:
            return IMaximumCountPathPrimitiveUpdatePolicyFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMaximumCountPathPrimitiveUpdatePolicyFactory.")
    
    def initialize(self) -> "IMaximumCountPathPrimitiveUpdatePolicy":
        """Constructs a default update policy. This is equivalent to constructing a policy with maximum count set to 0 and a remove location of Front."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_parameters(self, maximumCount:int, removeLocation:"AgEStkGraphicsPathPrimitiveRemoveLocation") -> "IMaximumCountPathPrimitiveUpdatePolicy":
        """Initializes a policy with the specified maximumCount and removeLocation."""
        with agmarshall.INT_arg(maximumCount) as arg_maximumCount, \
             agmarshall.AgEnum_arg(AgEStkGraphicsPathPrimitiveRemoveLocation, removeLocation) as arg_removeLocation, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_parameters"](arg_maximumCount.COM_val, arg_removeLocation.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{046383cc-b5b9-4ff5-b662-701e694170ba}", IMaximumCountPathPrimitiveUpdatePolicyFactory)
agcls.AgTypeNameMap["IMaximumCountPathPrimitiveUpdatePolicyFactory"] = IMaximumCountPathPrimitiveUpdatePolicyFactory

class IModelPrimitiveFactory(object):
    """The model primitive loads and renders `COLLADA <https://www.khronos.org/collada/>`_ (DAE) and AGI `MDL <https://support.agi.com/3d-models>`_ (MDL) models."""
    _uuid = "{93ea79ef-8da7-4992-b8fa-81d372d4258a}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_string_uri"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_string_uri_and_up_axis"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IModelPrimitiveFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IModelPrimitiveFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IModelPrimitiveFactory = agcom.GUID(IModelPrimitiveFactory._uuid)
        vtable_offset_local = IModelPrimitiveFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IModelPrimitiveFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_string_uri"] = IAGFUNCTYPE(pUnk, IID_IModelPrimitiveFactory, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_string_uri_and_up_axis"] = IAGFUNCTYPE(pUnk, IID_IModelPrimitiveFactory, vtable_offset_local+3, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IModelPrimitiveFactory.__dict__ and type(IModelPrimitiveFactory.__dict__[attrname]) == property:
            return IModelPrimitiveFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IModelPrimitiveFactory.")
    
    def initialize(self) -> "IModelPrimitive":
        """Initializes a default model primitive."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_string_uri(self, uri:str) -> "IModelPrimitive":
        """For convenience. Initializes a model primitive with the specified file path."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_string_uri"](arg_uri.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_string_uri_and_up_axis(self, uri:str, upAxis:"AgEStkGraphicsModelUpAxis") -> "IModelPrimitive":
        """For convenience. Initializes a model primitive with the specified file path and up axis."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.AgEnum_arg(AgEStkGraphicsModelUpAxis, upAxis) as arg_upAxis, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_string_uri_and_up_axis"](arg_uri.COM_val, arg_upAxis.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{93ea79ef-8da7-4992-b8fa-81d372d4258a}", IModelPrimitiveFactory)
agcls.AgTypeNameMap["IModelPrimitiveFactory"] = IModelPrimitiveFactory

class IPathPrimitiveFactory(object):
    """Renders a line to the 3D scene. Similar to the polyline primitive; however, the PathPrimitive was designed for the efficient addition/removal of points to/from the front or back of the line."""
    _uuid = "{2b9b98c4-17d2-4b72-a6cf-c9bc87eb11e8}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_capacity"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_width_supported"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_width_supported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPathPrimitiveFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPathPrimitiveFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPathPrimitiveFactory = agcom.GUID(IPathPrimitiveFactory._uuid)
        vtable_offset_local = IPathPrimitiveFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitiveFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_capacity"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitiveFactory, vtable_offset_local+2, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_minimum_width_supported"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitiveFactory, vtable_offset_local+3, POINTER(agcom.FLOAT))
        self.__dict__["_get_maximum_width_supported"] = IAGFUNCTYPE(pUnk, IID_IPathPrimitiveFactory, vtable_offset_local+4, POINTER(agcom.FLOAT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPathPrimitiveFactory.__dict__ and type(IPathPrimitiveFactory.__dict__[attrname]) == property:
            return IPathPrimitiveFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPathPrimitiveFactory.")
    
    def initialize(self) -> "IPathPrimitive":
        """Initializes a default path primitive. This is equivalent to constructing a path primitive with an initial capacity of 16."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_capacity(self, capacity:int) -> "IPathPrimitive":
        """Initializes a path primitive with the specified capacity."""
        with agmarshall.INT_arg(capacity) as arg_capacity, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_capacity"](arg_capacity.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def minimum_width_supported(self) -> float:
        """Gets the minimum width, in pixels, supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_width_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def maximum_width_supported(self) -> float:
        """Gets the maximum width, in pixels, supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_width_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2b9b98c4-17d2-4b72-a6cf-c9bc87eb11e8}", IPathPrimitiveFactory)
agcls.AgTypeNameMap["IPathPrimitiveFactory"] = IPathPrimitiveFactory

class IPixelSizeDisplayConditionFactory(object):
    """Defines an inclusive interval, in pixels, that determines when an object, such as a primitive, is rendered based on the number of pixels the object's bounding sphere (or in the case of screen overlays, bounding rectangle) covers on the screen..."""
    _uuid = "{2c7bb493-89f9-40f9-b562-feed771d08b7}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_pixel_sizes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPixelSizeDisplayConditionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPixelSizeDisplayConditionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPixelSizeDisplayConditionFactory = agcom.GUID(IPixelSizeDisplayConditionFactory._uuid)
        vtable_offset_local = IPixelSizeDisplayConditionFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IPixelSizeDisplayConditionFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_pixel_sizes"] = IAGFUNCTYPE(pUnk, IID_IPixelSizeDisplayConditionFactory, vtable_offset_local+2, agcom.INT, agcom.INT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPixelSizeDisplayConditionFactory.__dict__ and type(IPixelSizeDisplayConditionFactory.__dict__[attrname]) == property:
            return IPixelSizeDisplayConditionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPixelSizeDisplayConditionFactory.")
    
    def initialize(self) -> "IPixelSizeDisplayCondition":
        """Initializes a default pixel size display condition. minimum pixel size is set to 0 and maximum pixel size is set to Int32.MaxValue. With this interval, an object is always rendered regardless of how many pixels its bounding sphere or rectangle covers."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_pixel_sizes(self, minimumPixelSize:int, maximumPixelSize:int) -> "IPixelSizeDisplayCondition":
        """Initializes a pixel size display condition with the inclusive interval [minimumPixelSize, maximumPixelSize]..."""
        with agmarshall.INT_arg(minimumPixelSize) as arg_minimumPixelSize, \
             agmarshall.INT_arg(maximumPixelSize) as arg_maximumPixelSize, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_pixel_sizes"](arg_minimumPixelSize.COM_val, arg_maximumPixelSize.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2c7bb493-89f9-40f9-b562-feed771d08b7}", IPixelSizeDisplayConditionFactory)
agcls.AgTypeNameMap["IPixelSizeDisplayConditionFactory"] = IPixelSizeDisplayConditionFactory

class IPointBatchPrimitiveFactory(object):
    """ Renders one or more points in the 3D scene. Each point in the batch has a unique position and an optional color. All points in the batch share the same pixel size. For best performance, avoid creating lots of batches with only a few points each..."""
    _uuid = "{5dd03481-3541-486c-973f-f079eb35973c}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_set_hint"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_pixel_size_supported"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_pixel_size_supported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointBatchPrimitiveFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointBatchPrimitiveFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointBatchPrimitiveFactory = agcom.GUID(IPointBatchPrimitiveFactory._uuid)
        vtable_offset_local = IPointBatchPrimitiveFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitiveFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_set_hint"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitiveFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get_minimum_pixel_size_supported"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitiveFactory, vtable_offset_local+3, POINTER(agcom.FLOAT))
        self.__dict__["_get_maximum_pixel_size_supported"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitiveFactory, vtable_offset_local+4, POINTER(agcom.FLOAT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointBatchPrimitiveFactory.__dict__ and type(IPointBatchPrimitiveFactory.__dict__[attrname]) == property:
            return IPointBatchPrimitiveFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointBatchPrimitiveFactory.")
    
    def initialize(self) -> "IPointBatchPrimitive":
        """Initializes a default point batch primitive. This is equivalent to constructing a point batch with a set hint of Frequent."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_set_hint(self, setHint:"AgEStkGraphicsSetHint") -> "IPointBatchPrimitive":
        """Initializes a new instance of a point batch primitive with the specified set hint."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSetHint, setHint) as arg_setHint, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_set_hint"](arg_setHint.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def minimum_pixel_size_supported(self) -> float:
        """Gets the minimum pixel size supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_pixel_size_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def maximum_pixel_size_supported(self) -> float:
        """Gets the maximum pixel size supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_pixel_size_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5dd03481-3541-486c-973f-f079eb35973c}", IPointBatchPrimitiveFactory)
agcls.AgTypeNameMap["IPointBatchPrimitiveFactory"] = IPointBatchPrimitiveFactory

class IPointBatchPrimitiveOptionalParametersFactory(object):
    """Optional per-point parameters for point batch primitive that overrides the point batch primitive's global parameters..."""
    _uuid = "{b108564a-969c-43cb-97ce-e96dc0c7001c}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointBatchPrimitiveOptionalParametersFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointBatchPrimitiveOptionalParametersFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointBatchPrimitiveOptionalParametersFactory = agcom.GUID(IPointBatchPrimitiveOptionalParametersFactory._uuid)
        vtable_offset_local = IPointBatchPrimitiveOptionalParametersFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IPointBatchPrimitiveOptionalParametersFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointBatchPrimitiveOptionalParametersFactory.__dict__ and type(IPointBatchPrimitiveOptionalParametersFactory.__dict__[attrname]) == property:
            return IPointBatchPrimitiveOptionalParametersFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointBatchPrimitiveOptionalParametersFactory.")
    
    def initialize(self) -> "IPointBatchPrimitiveOptionalParameters":
        """Initializes a default point batch primitive optional parameters object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{b108564a-969c-43cb-97ce-e96dc0c7001c}", IPointBatchPrimitiveOptionalParametersFactory)
agcls.AgTypeNameMap["IPointBatchPrimitiveOptionalParametersFactory"] = IPointBatchPrimitiveOptionalParametersFactory

class IPolylinePrimitiveFactory(object):
    """Renders a polyline in the 3D scene. Each line segment may have a different color. A polyline can be constructed with a position interpolator to render great arcs or rhumb lines."""
    _uuid = "{16a27023-42d5-4994-9ace-165e027e72d8}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_interpolator_and_set_hint"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_type_and_hint"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_interpolator"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_hint"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_type"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_width_supported"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_width_supported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPolylinePrimitiveFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPolylinePrimitiveFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPolylinePrimitiveFactory = agcom.GUID(IPolylinePrimitiveFactory._uuid)
        vtable_offset_local = IPolylinePrimitiveFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitiveFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_interpolator_and_set_hint"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitiveFactory, vtable_offset_local+2, agcom.PVOID, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_type_and_hint"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitiveFactory, vtable_offset_local+3, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_interpolator"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitiveFactory, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_hint"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitiveFactory, vtable_offset_local+5, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_type"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitiveFactory, vtable_offset_local+6, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get_minimum_width_supported"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitiveFactory, vtable_offset_local+7, POINTER(agcom.FLOAT))
        self.__dict__["_get_maximum_width_supported"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitiveFactory, vtable_offset_local+8, POINTER(agcom.FLOAT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPolylinePrimitiveFactory.__dict__ and type(IPolylinePrimitiveFactory.__dict__[attrname]) == property:
            return IPolylinePrimitiveFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPolylinePrimitiveFactory.")
    
    def initialize(self) -> "IPolylinePrimitive":
        """Initializes a default polyline primitive. This is equivalent to constructing a polyline with a set hint of Frequent and a polyline type of LineStrip."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_interpolator_and_set_hint(self, interpolator:"IPositionInterpolator", setHint:"AgEStkGraphicsSetHint") -> "IPolylinePrimitive":
        """Initializes a polyline primitive with the specified interpolator and setHint."""
        with agmarshall.AgInterface_in_arg(interpolator, IPositionInterpolator) as arg_interpolator, \
             agmarshall.AgEnum_arg(AgEStkGraphicsSetHint, setHint) as arg_setHint, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_interpolator_and_set_hint"](arg_interpolator.COM_val, arg_setHint.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_type_and_hint(self, polylineType:"AgEStkGraphicsPolylineType", setHint:"AgEStkGraphicsSetHint") -> "IPolylinePrimitive":
        """Initializes a new instance of a polyline primitive with the specified polylineType and setHint."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsPolylineType, polylineType) as arg_polylineType, \
             agmarshall.AgEnum_arg(AgEStkGraphicsSetHint, setHint) as arg_setHint, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_type_and_hint"](arg_polylineType.COM_val, arg_setHint.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_interpolator(self, interpolator:"IPositionInterpolator") -> "IPolylinePrimitive":
        """Initializes a polyline primitive with the specified interpolator. This is equivalent to constructing a polyline with the specified interpolator and a set hint of Frequent."""
        with agmarshall.AgInterface_in_arg(interpolator, IPositionInterpolator) as arg_interpolator, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_interpolator"](arg_interpolator.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_hint(self, setHint:"AgEStkGraphicsSetHint") -> "IPolylinePrimitive":
        """Initializes a new instance of a polyline primitive with the specified set hint. This is equivalent to constructing a polyline with a polyline type of LineStrip and the specified set hint."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSetHint, setHint) as arg_setHint, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_hint"](arg_setHint.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_type(self, polylineType:"AgEStkGraphicsPolylineType") -> "IPolylinePrimitive":
        """Initializes a polyline primitive with the specified polylineType. This is equivalent to constructing a polyline with the specified polylineType and a set hint of Frequent."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsPolylineType, polylineType) as arg_polylineType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_type"](arg_polylineType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def minimum_width_supported(self) -> float:
        """Gets the minimum width, in pixels, supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_width_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def maximum_width_supported(self) -> float:
        """Gets the maximum width, in pixels, supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_width_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{16a27023-42d5-4994-9ace-165e027e72d8}", IPolylinePrimitiveFactory)
agcls.AgTypeNameMap["IPolylinePrimitiveFactory"] = IPolylinePrimitiveFactory

class IPolylinePrimitiveOptionalParametersFactory(object):
    """Optional per-point or per-segment parameters for polyline primitive that overrides the polyline primitive's global parameters..."""
    _uuid = "{7f416edb-d9ac-41bd-8216-893ca9ccc16b}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPolylinePrimitiveOptionalParametersFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPolylinePrimitiveOptionalParametersFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPolylinePrimitiveOptionalParametersFactory = agcom.GUID(IPolylinePrimitiveOptionalParametersFactory._uuid)
        vtable_offset_local = IPolylinePrimitiveOptionalParametersFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IPolylinePrimitiveOptionalParametersFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPolylinePrimitiveOptionalParametersFactory.__dict__ and type(IPolylinePrimitiveOptionalParametersFactory.__dict__[attrname]) == property:
            return IPolylinePrimitiveOptionalParametersFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPolylinePrimitiveOptionalParametersFactory.")
    
    def initialize(self) -> "IPolylinePrimitiveOptionalParameters":
        """Initializes default polyline primitive optional parameters. All per-segment parameters are initially empty."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7f416edb-d9ac-41bd-8216-893ca9ccc16b}", IPolylinePrimitiveOptionalParametersFactory)
agcls.AgTypeNameMap["IPolylinePrimitiveOptionalParametersFactory"] = IPolylinePrimitiveOptionalParametersFactory

class IRasterImageGlobeOverlayFactory(object):
    """A globe image overlay for handling rasters."""
    _uuid = "{00a01c47-a9d0-4020-a469-fd874b219713}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize_with_string"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_color"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_raster"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRasterImageGlobeOverlayFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRasterImageGlobeOverlayFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRasterImageGlobeOverlayFactory = agcom.GUID(IRasterImageGlobeOverlayFactory._uuid)
        vtable_offset_local = IRasterImageGlobeOverlayFactory._vtable_offset - 1
        self.__dict__["_initialize_with_string"] = IAGFUNCTYPE(pUnk, IID_IRasterImageGlobeOverlayFactory, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_color"] = IAGFUNCTYPE(pUnk, IID_IRasterImageGlobeOverlayFactory, vtable_offset_local+2, agcom.OLE_COLOR, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_raster"] = IAGFUNCTYPE(pUnk, IID_IRasterImageGlobeOverlayFactory, vtable_offset_local+3, agcom.PVOID, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRasterImageGlobeOverlayFactory.__dict__ and type(IRasterImageGlobeOverlayFactory.__dict__[attrname]) == property:
            return IRasterImageGlobeOverlayFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRasterImageGlobeOverlayFactory.")
    
    def initialize_with_string(self, uri:str, extent:list) -> "IRasterImageGlobeOverlay":
        """Initializes a raster image globe overlay with the provided values."""
        with agmarshall.BSTR_arg(uri) as arg_uri, \
             agmarshall.SAFEARRAY_arg(extent) as arg_extent, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_string"](arg_uri.COM_val, byref(arg_extent.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_color(self, color:agcolor.Color, extent:list) -> "IRasterImageGlobeOverlay":
        """Initializes a raster image globe overlay with the provided values."""
        with agmarshall.OLE_COLOR_arg(color) as arg_color, \
             agmarshall.SAFEARRAY_arg(extent) as arg_extent, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_color"](arg_color.COM_val, byref(arg_extent.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_raster(self, raster:"IRaster", extent:list) -> "IRasterImageGlobeOverlay":
        """Initializes a raster image globe overlay with the provided values."""
        with agmarshall.AgInterface_in_arg(raster, IRaster) as arg_raster, \
             agmarshall.SAFEARRAY_arg(extent) as arg_extent, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_raster"](arg_raster.COM_val, byref(arg_extent.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{00a01c47-a9d0-4020-a469-fd874b219713}", IRasterImageGlobeOverlayFactory)
agcls.AgTypeNameMap["IRasterImageGlobeOverlayFactory"] = IRasterImageGlobeOverlayFactory

class IRhumbLineInterpolatorFactory(object):
    """The rhumb line interpolator computes interpolated positions along a rhumb line. Rhumb lines are lines of constant bearing. They appear as straight lines on a Mercator 2D map projection and are well suited to navigation."""
    _uuid = "{1cf08578-668b-431a-9df2-8bb329e3fdf5}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_central_body"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_central_body_and_granularity"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRhumbLineInterpolatorFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRhumbLineInterpolatorFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRhumbLineInterpolatorFactory = agcom.GUID(IRhumbLineInterpolatorFactory._uuid)
        vtable_offset_local = IRhumbLineInterpolatorFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IRhumbLineInterpolatorFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_central_body"] = IAGFUNCTYPE(pUnk, IID_IRhumbLineInterpolatorFactory, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_central_body_and_granularity"] = IAGFUNCTYPE(pUnk, IID_IRhumbLineInterpolatorFactory, vtable_offset_local+3, agcom.BSTR, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRhumbLineInterpolatorFactory.__dict__ and type(IRhumbLineInterpolatorFactory.__dict__[attrname]) == property:
            return IRhumbLineInterpolatorFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRhumbLineInterpolatorFactory.")
    
    def initialize(self) -> "IRhumbLineInterpolator":
        """Initializes a default rhumb line interpolator. This is equivalent to constructing a rhumb line interpolator with a central body equal to an instance of earth central body and a granularity of 1 degree."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_central_body(self, centralBody:str) -> "IRhumbLineInterpolator":
        """Initializes a rhumb line interpolator with the specified centralBody and a granularity of 1 degree."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_central_body"](arg_centralBody.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_central_body_and_granularity(self, centralBody:str, granularity:float) -> "IRhumbLineInterpolator":
        """Initializes a rhumb line interpolator with the specified centralBody and granularity."""
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody, \
             agmarshall.DOUBLE_arg(granularity) as arg_granularity, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_central_body_and_granularity"](arg_centralBody.COM_val, arg_granularity.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1cf08578-668b-431a-9df2-8bb329e3fdf5}", IRhumbLineInterpolatorFactory)
agcls.AgTypeNameMap["IRhumbLineInterpolatorFactory"] = IRhumbLineInterpolatorFactory

class ISceneDisplayConditionFactory(object):
    """A display condition used to control what scene or scenes an object, such as a primitive, is rendered in. This is used to show an object in some scenes and hide it in others."""
    _uuid = "{930929f7-1d93-4575-a18f-b376e9a16cf7}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISceneDisplayConditionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISceneDisplayConditionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISceneDisplayConditionFactory = agcom.GUID(ISceneDisplayConditionFactory._uuid)
        vtable_offset_local = ISceneDisplayConditionFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ISceneDisplayConditionFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISceneDisplayConditionFactory.__dict__ and type(ISceneDisplayConditionFactory.__dict__[attrname]) == property:
            return ISceneDisplayConditionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISceneDisplayConditionFactory.")
    
    def initialize(self) -> "ISceneDisplayCondition":
        """Initializes a default scene display condition. When this display condition is assigned to an object, such as a primitive, the object can be restricted to only render in certain scenes. Call set display in scene or display only in scene to limit the scenes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{930929f7-1d93-4575-a18f-b376e9a16cf7}", ISceneDisplayConditionFactory)
agcls.AgTypeNameMap["ISceneDisplayConditionFactory"] = ISceneDisplayConditionFactory

class ISceneManagerInitializer(object):
    """The static scene manager class provides global properties and functionality that apply to all scenes and thus affect the rendering of every globe control..."""
    _uuid = "{dd3adf22-21f0-4220-8f3f-bda974157d48}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_primitives"] = _raise_uninitialized_error
        self.__dict__["_get_screen_overlays"] = _raise_uninitialized_error
        self.__dict__["_get_textures"] = _raise_uninitialized_error
        self.__dict__["_get_globe_overlay_settings"] = _raise_uninitialized_error
        self.__dict__["_get_scenes"] = _raise_uninitialized_error
        self.__dict__["_render"] = _raise_uninitialized_error
        self.__dict__["_get_frame_rate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISceneManagerInitializer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISceneManagerInitializer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISceneManagerInitializer = agcom.GUID(ISceneManagerInitializer._uuid)
        vtable_offset_local = ISceneManagerInitializer._vtable_offset - 1
        self.__dict__["_get_primitives"] = IAGFUNCTYPE(pUnk, IID_ISceneManagerInitializer, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_screen_overlays"] = IAGFUNCTYPE(pUnk, IID_ISceneManagerInitializer, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_textures"] = IAGFUNCTYPE(pUnk, IID_ISceneManagerInitializer, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_globe_overlay_settings"] = IAGFUNCTYPE(pUnk, IID_ISceneManagerInitializer, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_scenes"] = IAGFUNCTYPE(pUnk, IID_ISceneManagerInitializer, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_render"] = IAGFUNCTYPE(pUnk, IID_ISceneManagerInitializer, vtable_offset_local+6, )
        self.__dict__["_get_frame_rate"] = IAGFUNCTYPE(pUnk, IID_ISceneManagerInitializer, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISceneManagerInitializer.__dict__ and type(ISceneManagerInitializer.__dict__[attrname]) == property:
            return ISceneManagerInitializer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISceneManagerInitializer.")
    
    @property
    def primitives(self) -> "IPrimitiveManager":
        """Gets the primitive manager, which is used to add primitives to your scenes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_primitives"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def screen_overlays(self) -> "IScreenOverlayManager":
        """Gets the screen overlay manager, which is used to add screen overlays to your scenes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_screen_overlays"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def textures(self) -> "ITexture2DFactory":
        """Gets the texture 2d factory, which can be used to create textures from various sources."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_textures"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def globe_overlay_settings(self) -> "IGlobeOverlaySettings":
        """Gets the globe overlay settings, which are used to set global settings for all globe overlays."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_globe_overlay_settings"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def scenes(self) -> "ISceneCollection":
        """Gets a read-only collection of scenes that are associated with the scene manager."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scenes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def render(self) -> None:
        """Renders all scenes within an application. To render a specific scene, use the Render method."""
        agcls.evaluate_hresult(self.__dict__["_render"]())

    @property
    def frame_rate(self) -> "IFrameRate":
        """Gets the frame rate class, which can be used to keep track of how fast scenes are being <see ref='Render'>rendered</see>."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_frame_rate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{dd3adf22-21f0-4220-8f3f-bda974157d48}", ISceneManagerInitializer)
agcls.AgTypeNameMap["ISceneManagerInitializer"] = ISceneManagerInitializer

class IScreenOverlayFactory(object):
    """A visible element drawn in screen space. Overlays are useful for floating logos, heads up displays, and integrating user interfaces into the 3D window."""
    _uuid = "{45754d2a-e83f-4c32-9792-c90d9620a83a}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_pos_and_size"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScreenOverlayFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScreenOverlayFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScreenOverlayFactory = agcom.GUID(IScreenOverlayFactory._uuid)
        vtable_offset_local = IScreenOverlayFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayFactory, vtable_offset_local+1, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_pos_and_size"] = IAGFUNCTYPE(pUnk, IID_IScreenOverlayFactory, vtable_offset_local+2, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScreenOverlayFactory.__dict__ and type(IScreenOverlayFactory.__dict__[attrname]) == property:
            return IScreenOverlayFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScreenOverlayFactory.")
    
    def initialize(self, xPixels:float, yPixels:float, widthPixels:float, heightPixels:float) -> "IScreenOverlay":
        """Initializes the overlay with the specified x position, y position, width, and height, all specified in pixels."""
        with agmarshall.DOUBLE_arg(xPixels) as arg_xPixels, \
             agmarshall.DOUBLE_arg(yPixels) as arg_yPixels, \
             agmarshall.DOUBLE_arg(widthPixels) as arg_widthPixels, \
             agmarshall.DOUBLE_arg(heightPixels) as arg_heightPixels, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](arg_xPixels.COM_val, arg_yPixels.COM_val, arg_widthPixels.COM_val, arg_heightPixels.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_pos_and_size(self, position:list, size:list) -> "IScreenOverlay":
        """Initializes the overlay with the specified position and size."""
        with agmarshall.SAFEARRAY_arg(position) as arg_position, \
             agmarshall.SAFEARRAY_arg(size) as arg_size, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_pos_and_size"](byref(arg_position.COM_val), byref(arg_size.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{45754d2a-e83f-4c32-9792-c90d9620a83a}", IScreenOverlayFactory)
agcls.AgTypeNameMap["IScreenOverlayFactory"] = IScreenOverlayFactory

class ISolidPrimitiveFactory(object):
    """Renders filled solid objects and their outlines. Example solids include boxes and ellipsoids. Various effects are supported, such as displaying the solid's silhouette, and hiding the outline of the backside of the solid..."""
    _uuid = "{b76858bc-4b6c-41c0-928a-2ae8fe8d6e03}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_hint"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_silhouette_width_supported"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_silhouette_width_supported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISolidPrimitiveFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISolidPrimitiveFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISolidPrimitiveFactory = agcom.GUID(ISolidPrimitiveFactory._uuid)
        vtable_offset_local = ISolidPrimitiveFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitiveFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_hint"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitiveFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get_minimum_silhouette_width_supported"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitiveFactory, vtable_offset_local+3, POINTER(agcom.FLOAT))
        self.__dict__["_get_maximum_silhouette_width_supported"] = IAGFUNCTYPE(pUnk, IID_ISolidPrimitiveFactory, vtable_offset_local+4, POINTER(agcom.FLOAT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISolidPrimitiveFactory.__dict__ and type(ISolidPrimitiveFactory.__dict__[attrname]) == property:
            return ISolidPrimitiveFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISolidPrimitiveFactory.")
    
    def initialize(self) -> "ISolidPrimitive":
        """Initializes a default solid primitive. This is equivalent to constructing a solid primitive with a set hint of Frequent."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_hint(self, setHint:"AgEStkGraphicsSetHint") -> "ISolidPrimitive":
        """Initializes a solid primitive with the specified setHint."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSetHint, setHint) as arg_setHint, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_hint"](arg_setHint.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def minimum_silhouette_width_supported(self) -> float:
        """Gets the minimum silhouette width, in pixels, supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_silhouette_width_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def maximum_silhouette_width_supported(self) -> float:
        """Gets the maximum silhouette width, in pixels, supported by the video card."""
        with agmarshall.FLOAT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_silhouette_width_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{b76858bc-4b6c-41c0-928a-2ae8fe8d6e03}", ISolidPrimitiveFactory)
agcls.AgTypeNameMap["ISolidPrimitiveFactory"] = ISolidPrimitiveFactory

class ISurfaceMeshPrimitiveFactory(object):
    """A triangle mesh primitive for meshes on the surface that need to conform to terrain."""
    _uuid = "{08c3d10b-0cf0-41e9-93d0-e73b9d25e329}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_set_hint"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_set_hint_and_rendering_method"] = _raise_uninitialized_error
        self.__dict__["_supported"] = _raise_uninitialized_error
        self.__dict__["_supported_with_default_rendering_method"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISurfaceMeshPrimitiveFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISurfaceMeshPrimitiveFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISurfaceMeshPrimitiveFactory = agcom.GUID(ISurfaceMeshPrimitiveFactory._uuid)
        vtable_offset_local = ISurfaceMeshPrimitiveFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitiveFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_set_hint"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitiveFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_set_hint_and_rendering_method"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitiveFactory, vtable_offset_local+3, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_supported"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitiveFactory, vtable_offset_local+4, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_supported_with_default_rendering_method"] = IAGFUNCTYPE(pUnk, IID_ISurfaceMeshPrimitiveFactory, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISurfaceMeshPrimitiveFactory.__dict__ and type(ISurfaceMeshPrimitiveFactory.__dict__[attrname]) == property:
            return ISurfaceMeshPrimitiveFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISurfaceMeshPrimitiveFactory.")
    
    def initialize(self) -> "ISurfaceMeshPrimitive":
        """Initializes a default surface mesh primitive. This is equivalent to constructing a surface mesh with a set hint of Frequent and a surface mesh rendering method of Automatic."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_set_hint(self, setHint:"AgEStkGraphicsSetHint") -> "ISurfaceMeshPrimitive":
        """Initializes a surface mesh primitive with the specified setHint. This is equivalent to constructing a surface mesh with the specified setHint and a surface mesh rendering method of Automatic."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSetHint, setHint) as arg_setHint, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_set_hint"](arg_setHint.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_set_hint_and_rendering_method(self, setHint:"AgEStkGraphicsSetHint", renderingMethod:"AgEStkGraphicsSurfaceMeshRenderingMethod") -> "ISurfaceMeshPrimitive":
        """Initializes a surface mesh primitive with the specified setHint and renderingMethod."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSetHint, setHint) as arg_setHint, \
             agmarshall.AgEnum_arg(AgEStkGraphicsSurfaceMeshRenderingMethod, renderingMethod) as arg_renderingMethod, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_set_hint_and_rendering_method"](arg_setHint.COM_val, arg_renderingMethod.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def supported(self, renderingMethod:"AgEStkGraphicsSurfaceMeshRenderingMethod") -> bool:
        """Determines whether or not the video card supports the surface mesh primitive with the given renderingMethod."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSurfaceMeshRenderingMethod, renderingMethod) as arg_renderingMethod, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_supported"](arg_renderingMethod.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def supported_with_default_rendering_method(self) -> bool:
        """Determines whether or not the video card supports the surface mesh primitive. This is equivalent to calling Supported with automatic."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_supported_with_default_rendering_method"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{08c3d10b-0cf0-41e9-93d0-e73b9d25e329}", ISurfaceMeshPrimitiveFactory)
agcls.AgTypeNameMap["ISurfaceMeshPrimitiveFactory"] = ISurfaceMeshPrimitiveFactory

class ITerrainOverlayInitializer(object):
    """A globe overlay which shows terrain."""
    _uuid = "{74c0acde-8d75-49df-87c1-2c39e3240283}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_supported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITerrainOverlayInitializer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITerrainOverlayInitializer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITerrainOverlayInitializer = agcom.GUID(ITerrainOverlayInitializer._uuid)
        vtable_offset_local = ITerrainOverlayInitializer._vtable_offset - 1
        self.__dict__["_get_supported"] = IAGFUNCTYPE(pUnk, IID_ITerrainOverlayInitializer, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITerrainOverlayInitializer.__dict__ and type(ITerrainOverlayInitializer.__dict__[attrname]) == property:
            return ITerrainOverlayInitializer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITerrainOverlayInitializer.")
    
    @property
    def supported(self) -> bool:
        """Gets whether the video card supports adding terrain overlay objects. Video cards that support OpenGL 1.2 or higher support terrain overlay objects."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_supported"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{74c0acde-8d75-49df-87c1-2c39e3240283}", ITerrainOverlayInitializer)
agcls.AgTypeNameMap["ITerrainOverlayInitializer"] = ITerrainOverlayInitializer

class ITextBatchPrimitiveFactory(object):
    """ Renders one or more strings in the 3D scene.  For best performance, avoid creating lots of batches with only a few strings each. See the Batching Performance Overview. """
    _uuid = "{dfcc32bb-e95a-46c5-a1e4-ed3acf184d3a}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize_with_graphics_font"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_graphics_font_and_set_hint"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_graphics_font_and_set_hint2_d"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITextBatchPrimitiveFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITextBatchPrimitiveFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITextBatchPrimitiveFactory = agcom.GUID(ITextBatchPrimitiveFactory._uuid)
        vtable_offset_local = ITextBatchPrimitiveFactory._vtable_offset - 1
        self.__dict__["_initialize_with_graphics_font"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveFactory, vtable_offset_local+1, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_graphics_font_and_set_hint"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveFactory, vtable_offset_local+2, agcom.PVOID, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_graphics_font_and_set_hint2_d"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveFactory, vtable_offset_local+3, agcom.PVOID, agcom.LONG, agcom.VARIANT_BOOL, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITextBatchPrimitiveFactory.__dict__ and type(ITextBatchPrimitiveFactory.__dict__[attrname]) == property:
            return ITextBatchPrimitiveFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITextBatchPrimitiveFactory.")
    
    def initialize_with_graphics_font(self, font:"IGraphicsFont") -> "ITextBatchPrimitive":
        """Initializes a marker batch primitive with the specified font. This is equivalent to constructing a text batch with the specified font and a set hint of Frequent."""
        with agmarshall.AgInterface_in_arg(font, IGraphicsFont) as arg_font, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_graphics_font"](arg_font.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_graphics_font_and_set_hint(self, font:"IGraphicsFont", setHint:"AgEStkGraphicsSetHint") -> "ITextBatchPrimitive":
        """Initializes a marker batch primitive with the specified font and setHint."""
        with agmarshall.AgInterface_in_arg(font, IGraphicsFont) as arg_font, \
             agmarshall.AgEnum_arg(AgEStkGraphicsSetHint, setHint) as arg_setHint, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_graphics_font_and_set_hint"](arg_font.COM_val, arg_setHint.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_graphics_font_and_set_hint2_d(self, font:"IGraphicsFont", setHint:"AgEStkGraphicsSetHint", renderInScreenSpace:bool) -> "ITextBatchPrimitive":
        """Initializes a text batch primitive with the specified font and setHint, optimized for 2d screen space rendering."""
        with agmarshall.AgInterface_in_arg(font, IGraphicsFont) as arg_font, \
             agmarshall.AgEnum_arg(AgEStkGraphicsSetHint, setHint) as arg_setHint, \
             agmarshall.VARIANT_BOOL_arg(renderInScreenSpace) as arg_renderInScreenSpace, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_graphics_font_and_set_hint2_d"](arg_font.COM_val, arg_setHint.COM_val, arg_renderInScreenSpace.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{dfcc32bb-e95a-46c5-a1e4-ed3acf184d3a}", ITextBatchPrimitiveFactory)
agcls.AgTypeNameMap["ITextBatchPrimitiveFactory"] = ITextBatchPrimitiveFactory

class ITextBatchPrimitiveOptionalParametersFactory(object):
    """Optional per-string and per-batch parameters for text batch primitive..."""
    _uuid = "{03511893-3980-4c0e-9b99-7f86398acadf}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITextBatchPrimitiveOptionalParametersFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITextBatchPrimitiveOptionalParametersFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITextBatchPrimitiveOptionalParametersFactory = agcom.GUID(ITextBatchPrimitiveOptionalParametersFactory._uuid)
        vtable_offset_local = ITextBatchPrimitiveOptionalParametersFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ITextBatchPrimitiveOptionalParametersFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITextBatchPrimitiveOptionalParametersFactory.__dict__ and type(ITextBatchPrimitiveOptionalParametersFactory.__dict__[attrname]) == property:
            return ITextBatchPrimitiveOptionalParametersFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITextBatchPrimitiveOptionalParametersFactory.")
    
    def initialize(self) -> "ITextBatchPrimitiveOptionalParameters":
        """Initializes default text batch primitive optional parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{03511893-3980-4c0e-9b99-7f86398acadf}", ITextBatchPrimitiveOptionalParametersFactory)
agcls.AgTypeNameMap["ITextBatchPrimitiveOptionalParametersFactory"] = ITextBatchPrimitiveOptionalParametersFactory

class ITextOverlayFactory(object):
    """A rectangular overlay that contains text."""
    _uuid = "{183a48a5-a123-493a-9e6e-688775a7ca79}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_xy_width_height"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_position_size"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_width_height_units"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITextOverlayFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITextOverlayFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITextOverlayFactory = agcom.GUID(ITextOverlayFactory._uuid)
        vtable_offset_local = ITextOverlayFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ITextOverlayFactory, vtable_offset_local+1, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_xy_width_height"] = IAGFUNCTYPE(pUnk, IID_ITextOverlayFactory, vtable_offset_local+2, agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_position_size"] = IAGFUNCTYPE(pUnk, IID_ITextOverlayFactory, vtable_offset_local+3, agcom.PVOID, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_width_height_units"] = IAGFUNCTYPE(pUnk, IID_ITextOverlayFactory, vtable_offset_local+4, agcom.PVOID, agcom.DOUBLE, agcom.LONG, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITextOverlayFactory.__dict__ and type(ITextOverlayFactory.__dict__[attrname]) == property:
            return ITextOverlayFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITextOverlayFactory.")
    
    def initialize(self, font:"IGraphicsFont") -> "ITextOverlay":
        """Initializes the overlay with a position of (0, 0), a width of 100 pixels, and a height of 50 pixels. <param name='font'>The graphics font that defines how text is drawn.</param>"""
        with agmarshall.AgInterface_in_arg(font, IGraphicsFont) as arg_font, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](arg_font.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_xy_width_height(self, font:"IGraphicsFont", xPixels:float, yPixels:float, widthPixels:float, heightPixels:float) -> "ITextOverlay":
        """Initializes the overlay with the specified x position, y position, width, and height, all specified in pixels."""
        with agmarshall.AgInterface_in_arg(font, IGraphicsFont) as arg_font, \
             agmarshall.DOUBLE_arg(xPixels) as arg_xPixels, \
             agmarshall.DOUBLE_arg(yPixels) as arg_yPixels, \
             agmarshall.DOUBLE_arg(widthPixels) as arg_widthPixels, \
             agmarshall.DOUBLE_arg(heightPixels) as arg_heightPixels, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_xy_width_height"](arg_font.COM_val, arg_xPixels.COM_val, arg_yPixels.COM_val, arg_widthPixels.COM_val, arg_heightPixels.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_position_size(self, font:"IGraphicsFont", position:list, size:list) -> "ITextOverlay":
        """Initializes the overlay with the specified position and size."""
        with agmarshall.AgInterface_in_arg(font, IGraphicsFont) as arg_font, \
             agmarshall.SAFEARRAY_arg(position) as arg_position, \
             agmarshall.SAFEARRAY_arg(size) as arg_size, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_position_size"](arg_font.COM_val, byref(arg_position.COM_val), byref(arg_size.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_width_height_units(self, font:"IGraphicsFont", width:float, widthUnit:"AgEStkGraphicsScreenOverlayUnit", height:float, heightUnit:"AgEStkGraphicsScreenOverlayUnit") -> "ITextOverlay":
        """Initializes the overlay with the specified position and size."""
        with agmarshall.AgInterface_in_arg(font, IGraphicsFont) as arg_font, \
             agmarshall.DOUBLE_arg(width) as arg_width, \
             agmarshall.AgEnum_arg(AgEStkGraphicsScreenOverlayUnit, widthUnit) as arg_widthUnit, \
             agmarshall.DOUBLE_arg(height) as arg_height, \
             agmarshall.AgEnum_arg(AgEStkGraphicsScreenOverlayUnit, heightUnit) as arg_heightUnit, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_width_height_units"](arg_font.COM_val, arg_width.COM_val, arg_widthUnit.COM_val, arg_height.COM_val, arg_heightUnit.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{183a48a5-a123-493a-9e6e-688775a7ca79}", ITextOverlayFactory)
agcls.AgTypeNameMap["ITextOverlayFactory"] = ITextOverlayFactory

class ITextureMatrixFactory(object):
    """A 4 by 4 matrix applied to a texture coordinate."""
    _uuid = "{d4fcc6c9-d53a-4988-a09e-3edc080936d4}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_by_values"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_affine_transform"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_rectangles"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITextureMatrixFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITextureMatrixFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITextureMatrixFactory = agcom.GUID(ITextureMatrixFactory._uuid)
        vtable_offset_local = ITextureMatrixFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrixFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_by_values"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrixFactory, vtable_offset_local+2, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_affine_transform"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrixFactory, vtable_offset_local+3, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_rectangles"] = IAGFUNCTYPE(pUnk, IID_ITextureMatrixFactory, vtable_offset_local+4, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITextureMatrixFactory.__dict__ and type(ITextureMatrixFactory.__dict__[attrname]) == property:
            return ITextureMatrixFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITextureMatrixFactory.")
    
    def initialize(self) -> "ITextureMatrix":
        """Initializes a texture matrix to the identity matrix."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_by_values(self, m11:float, m12:float, m13:float, m14:float, m21:float, m22:float, m23:float, m24:float, m31:float, m32:float, m33:float, m34:float, m41:float, m42:float, m43:float, m44:float) -> "ITextureMatrix":
        """Initializes a texture matrix. The subscripts define [row][column]."""
        with agmarshall.FLOAT_arg(m11) as arg_m11, \
             agmarshall.FLOAT_arg(m12) as arg_m12, \
             agmarshall.FLOAT_arg(m13) as arg_m13, \
             agmarshall.FLOAT_arg(m14) as arg_m14, \
             agmarshall.FLOAT_arg(m21) as arg_m21, \
             agmarshall.FLOAT_arg(m22) as arg_m22, \
             agmarshall.FLOAT_arg(m23) as arg_m23, \
             agmarshall.FLOAT_arg(m24) as arg_m24, \
             agmarshall.FLOAT_arg(m31) as arg_m31, \
             agmarshall.FLOAT_arg(m32) as arg_m32, \
             agmarshall.FLOAT_arg(m33) as arg_m33, \
             agmarshall.FLOAT_arg(m34) as arg_m34, \
             agmarshall.FLOAT_arg(m41) as arg_m41, \
             agmarshall.FLOAT_arg(m42) as arg_m42, \
             agmarshall.FLOAT_arg(m43) as arg_m43, \
             agmarshall.FLOAT_arg(m44) as arg_m44, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_by_values"](arg_m11.COM_val, arg_m12.COM_val, arg_m13.COM_val, arg_m14.COM_val, arg_m21.COM_val, arg_m22.COM_val, arg_m23.COM_val, arg_m24.COM_val, arg_m31.COM_val, arg_m32.COM_val, arg_m33.COM_val, arg_m34.COM_val, arg_m41.COM_val, arg_m42.COM_val, arg_m43.COM_val, arg_m44.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_affine_transform(self, matrix:list) -> "ITextureMatrix":
        """Initializes a texture matrix from a matrix. The upper left 2x2 matrix defines rotation and scaling. The top two elements of the last column define translation."""
        with agmarshall.SAFEARRAY_arg(matrix) as arg_matrix, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_affine_transform"](byref(arg_matrix.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_rectangles(self, corner0:list, corner1:list, corner2:list, corner3:list) -> "ITextureMatrix":
        """Initializes a texture matrix from texture corner points. Normally, a texture is mapped such that the lower left corner is texture coordinate (0, 0), the lower right is (1, 0), the upper right is (1, 1), and the upper left is (0, 1)..."""
        with agmarshall.SAFEARRAY_arg(corner0) as arg_corner0, \
             agmarshall.SAFEARRAY_arg(corner1) as arg_corner1, \
             agmarshall.SAFEARRAY_arg(corner2) as arg_corner2, \
             agmarshall.SAFEARRAY_arg(corner3) as arg_corner3, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_rectangles"](byref(arg_corner0.COM_val), byref(arg_corner1.COM_val), byref(arg_corner2.COM_val), byref(arg_corner3.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{d4fcc6c9-d53a-4988-a09e-3edc080936d4}", ITextureMatrixFactory)
agcls.AgTypeNameMap["ITextureMatrixFactory"] = ITextureMatrixFactory

class ITextureScreenOverlayFactory(object):
    """A rectangular overlay that can be assigned a texture."""
    _uuid = "{d68b862b-50c5-4803-9a98-d404c0aa967a}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_xy_width_height"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_position_size"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_xy_texture"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_position_texture"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITextureScreenOverlayFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITextureScreenOverlayFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITextureScreenOverlayFactory = agcom.GUID(ITextureScreenOverlayFactory._uuid)
        vtable_offset_local = ITextureScreenOverlayFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ITextureScreenOverlayFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_xy_width_height"] = IAGFUNCTYPE(pUnk, IID_ITextureScreenOverlayFactory, vtable_offset_local+2, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_position_size"] = IAGFUNCTYPE(pUnk, IID_ITextureScreenOverlayFactory, vtable_offset_local+3, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_xy_texture"] = IAGFUNCTYPE(pUnk, IID_ITextureScreenOverlayFactory, vtable_offset_local+4, agcom.DOUBLE, agcom.DOUBLE, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_position_texture"] = IAGFUNCTYPE(pUnk, IID_ITextureScreenOverlayFactory, vtable_offset_local+5, POINTER(agcom.SAFEARRAY), agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITextureScreenOverlayFactory.__dict__ and type(ITextureScreenOverlayFactory.__dict__[attrname]) == property:
            return ITextureScreenOverlayFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITextureScreenOverlayFactory.")
    
    def initialize(self) -> "ITextureScreenOverlay":
        """Initializes the overlay with a position of (0, 0), a width of 100 pixels, and a height of 50 pixels."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_xy_width_height(self, xPixels:float, yPixels:float, widthPixels:float, heightPixels:float) -> "ITextureScreenOverlay":
        """Initializes the overlay with the specified x position, y position, width, and height, all specified in pixels."""
        with agmarshall.DOUBLE_arg(xPixels) as arg_xPixels, \
             agmarshall.DOUBLE_arg(yPixels) as arg_yPixels, \
             agmarshall.DOUBLE_arg(widthPixels) as arg_widthPixels, \
             agmarshall.DOUBLE_arg(heightPixels) as arg_heightPixels, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_xy_width_height"](arg_xPixels.COM_val, arg_yPixels.COM_val, arg_widthPixels.COM_val, arg_heightPixels.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_position_size(self, position:list, size:list) -> "ITextureScreenOverlay":
        """Initializes the overlay with the specified position and size."""
        with agmarshall.SAFEARRAY_arg(position) as arg_position, \
             agmarshall.SAFEARRAY_arg(size) as arg_size, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_position_size"](byref(arg_position.COM_val), byref(arg_size.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_xy_texture(self, xPixels:float, yPixels:float, texture:"IRendererTexture2D") -> "ITextureScreenOverlay":
        """Initializes the overlay with a specified background texture. The size of the overlay will be the same as the size of the texture."""
        with agmarshall.DOUBLE_arg(xPixels) as arg_xPixels, \
             agmarshall.DOUBLE_arg(yPixels) as arg_yPixels, \
             agmarshall.AgInterface_in_arg(texture, IRendererTexture2D) as arg_texture, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_xy_texture"](arg_xPixels.COM_val, arg_yPixels.COM_val, arg_texture.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_position_texture(self, position:list, texture:"IRendererTexture2D") -> "ITextureScreenOverlay":
        """Initializes the overlay with a specified background texture. The size of the overlay will be the same as the size of the texture."""
        with agmarshall.SAFEARRAY_arg(position) as arg_position, \
             agmarshall.AgInterface_in_arg(texture, IRendererTexture2D) as arg_texture, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_position_texture"](byref(arg_position.COM_val), arg_texture.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{d68b862b-50c5-4803-9a98-d404c0aa967a}", ITextureScreenOverlayFactory)
agcls.AgTypeNameMap["ITextureScreenOverlayFactory"] = ITextureScreenOverlayFactory

class ITimeIntervalDisplayConditionFactory(object):
    """Defines an inclusive time interval that determines when an object, such as a primitive, is rendered based on the current animation time ."""
    _uuid = "{99ca1422-3ae0-4620-9046-d0bc4ca2bee5}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_times"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_time_interval"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeIntervalDisplayConditionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeIntervalDisplayConditionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeIntervalDisplayConditionFactory = agcom.GUID(ITimeIntervalDisplayConditionFactory._uuid)
        vtable_offset_local = ITimeIntervalDisplayConditionFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ITimeIntervalDisplayConditionFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_times"] = IAGFUNCTYPE(pUnk, IID_ITimeIntervalDisplayConditionFactory, vtable_offset_local+2, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_time_interval"] = IAGFUNCTYPE(pUnk, IID_ITimeIntervalDisplayConditionFactory, vtable_offset_local+3, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeIntervalDisplayConditionFactory.__dict__ and type(ITimeIntervalDisplayConditionFactory.__dict__[attrname]) == property:
            return ITimeIntervalDisplayConditionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeIntervalDisplayConditionFactory.")
    
    def initialize(self) -> "ITimeIntervalDisplayCondition":
        """Initializes a default time display condition. minimum time is set to JulianDate.MinValue and maximum time is set to JulianDate.MaxValue. With this interval, an object is always rendered regardless of the current animation time."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_times(self, minimumTime:"IDate", maximumTime:"IDate") -> "ITimeIntervalDisplayCondition":
        """Initializes a time display condition with the inclusive time interval [minimumTime, maximumTime]..."""
        with agmarshall.AgInterface_in_arg(minimumTime, IDate) as arg_minimumTime, \
             agmarshall.AgInterface_in_arg(maximumTime, IDate) as arg_maximumTime, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_times"](arg_minimumTime.COM_val, arg_maximumTime.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_time_interval(self, timeInterval:list) -> "ITimeIntervalDisplayCondition":
        """Initializes a time display condition with a time interval."""
        with agmarshall.SAFEARRAY_arg(timeInterval) as arg_timeInterval, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_time_interval"](byref(arg_timeInterval.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{99ca1422-3ae0-4620-9046-d0bc4ca2bee5}", ITimeIntervalDisplayConditionFactory)
agcls.AgTypeNameMap["ITimeIntervalDisplayConditionFactory"] = ITimeIntervalDisplayConditionFactory

class ITriangleMeshPrimitiveFactory(object):
    """Renders a triangle mesh in the 3D scene. Examples of triangle meshes includes polygons on the globe (e.g. states or countries), terrain and imagery extents, ellipses, and extrusions."""
    _uuid = "{efd9ac8c-e2f0-4a06-9e92-15ebe59d5c38}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        self.__dict__["_initialize_with_set_hint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITriangleMeshPrimitiveFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITriangleMeshPrimitiveFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITriangleMeshPrimitiveFactory = agcom.GUID(ITriangleMeshPrimitiveFactory._uuid)
        vtable_offset_local = ITriangleMeshPrimitiveFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitiveFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_initialize_with_set_hint"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitiveFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITriangleMeshPrimitiveFactory.__dict__ and type(ITriangleMeshPrimitiveFactory.__dict__[attrname]) == property:
            return ITriangleMeshPrimitiveFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITriangleMeshPrimitiveFactory.")
    
    def initialize(self) -> "ITriangleMeshPrimitive":
        """Initializes a default triangle mesh primitive. This is equivalent to constructing a triangle mesh with a set hint of Frequent."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def initialize_with_set_hint(self, setHint:"AgEStkGraphicsSetHint") -> "ITriangleMeshPrimitive":
        """Initializes a triangle mesh primitive with the specified setHint ."""
        with agmarshall.AgEnum_arg(AgEStkGraphicsSetHint, setHint) as arg_setHint, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_set_hint"](arg_setHint.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{efd9ac8c-e2f0-4a06-9e92-15ebe59d5c38}", ITriangleMeshPrimitiveFactory)
agcls.AgTypeNameMap["ITriangleMeshPrimitiveFactory"] = ITriangleMeshPrimitiveFactory

class ITriangleMeshPrimitiveOptionalParametersFactory(object):
    """Optional parameters for triangle mesh primitive..."""
    _uuid = "{dab0d95c-d51e-4152-9f63-01441ca43ad9}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITriangleMeshPrimitiveOptionalParametersFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITriangleMeshPrimitiveOptionalParametersFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITriangleMeshPrimitiveOptionalParametersFactory = agcom.GUID(ITriangleMeshPrimitiveOptionalParametersFactory._uuid)
        vtable_offset_local = ITriangleMeshPrimitiveOptionalParametersFactory._vtable_offset - 1
        self.__dict__["_initialize"] = IAGFUNCTYPE(pUnk, IID_ITriangleMeshPrimitiveOptionalParametersFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITriangleMeshPrimitiveOptionalParametersFactory.__dict__ and type(ITriangleMeshPrimitiveOptionalParametersFactory.__dict__[attrname]) == property:
            return ITriangleMeshPrimitiveOptionalParametersFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITriangleMeshPrimitiveOptionalParametersFactory.")
    
    def initialize(self) -> "ITriangleMeshPrimitiveOptionalParameters":
        """Initializes default triangle mesh primitive optional parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{dab0d95c-d51e-4152-9f63-01441ca43ad9}", ITriangleMeshPrimitiveOptionalParametersFactory)
agcls.AgTypeNameMap["ITriangleMeshPrimitiveOptionalParametersFactory"] = ITriangleMeshPrimitiveOptionalParametersFactory

class IVectorPrimitiveFactory(object):
    """Renders a vector in the 3D scene. A vector is defined by a source (given by an ISystem) and a direction (given by an IVector or IPoint). Length is auto-calculated or can be set separately."""
    _uuid = "{a7013a6a-64ea-43b6-807f-4f789df05438}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_initialize_with_direction"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorPrimitiveFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorPrimitiveFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorPrimitiveFactory = agcom.GUID(IVectorPrimitiveFactory._uuid)
        vtable_offset_local = IVectorPrimitiveFactory._vtable_offset - 1
        self.__dict__["_initialize_with_direction"] = IAGFUNCTYPE(pUnk, IID_IVectorPrimitiveFactory, vtable_offset_local+1, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorPrimitiveFactory.__dict__ and type(IVectorPrimitiveFactory.__dict__[attrname]) == property:
            return IVectorPrimitiveFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorPrimitiveFactory.")
    
    def initialize_with_direction(self, sys:"IVectorGeometryToolSystem", dir:"IVectorGeometryToolVector", font:"IGraphicsFont") -> "IVectorPrimitive":
        """Initializes a vector primitive with the specified ISystem sys as its source and pointing in direction dir."""
        with agmarshall.AgInterface_in_arg(sys, IVectorGeometryToolSystem) as arg_sys, \
             agmarshall.AgInterface_in_arg(dir, IVectorGeometryToolVector) as arg_dir, \
             agmarshall.AgInterface_in_arg(font, IGraphicsFont) as arg_font, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_initialize_with_direction"](arg_sys.COM_val, arg_dir.COM_val, arg_font.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{a7013a6a-64ea-43b6-807f-4f789df05438}", IVectorPrimitiveFactory)
agcls.AgTypeNameMap["IVectorPrimitiveFactory"] = IVectorPrimitiveFactory



class PathPoint(IPathPoint):
    """Represents a path point used in conjunction with the Path Primitive."""
    def __init__(self, sourceObject=None):
        IPathPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPathPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPathPoint._get_property(self, attrname) is not None: found_prop = IPathPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PathPoint.")
        
agcls.AgClassCatalog.add_catalog_entry("{4C86EAB3-9C30-4D1B-9391-A27010590176}", PathPoint)


class PathPointFactory(IPathPointFactory):
    """Factory creates path points."""
    def __init__(self, sourceObject=None):
        IPathPointFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPathPointFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPathPointFactory._get_property(self, attrname) is not None: found_prop = IPathPointFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PathPointFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{997C56C5-C114-4C2E-A25A-4D4860FA913F}", PathPointFactory)


class BoundingSphere(IBoundingSphere):
    """A sphere that encapsulates an object."""
    def __init__(self, sourceObject=None):
        IBoundingSphere.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBoundingSphere._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBoundingSphere._get_property(self, attrname) is not None: found_prop = IBoundingSphere._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BoundingSphere.")
        
agcls.AgClassCatalog.add_catalog_entry("{40BA7967-5508-4D2C-9048-76EA16351F61}", BoundingSphere)


class BoundingSphereFactory(IBoundingSphereFactory):
    """Creates bounding spheres."""
    def __init__(self, sourceObject=None):
        IBoundingSphereFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBoundingSphereFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBoundingSphereFactory._get_property(self, attrname) is not None: found_prop = IBoundingSphereFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BoundingSphereFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{4CAEE1FD-33BB-4928-8363-39237A62C150}", BoundingSphereFactory)


class TextureFilter2D(ITextureFilter2D):
    """A texture filter."""
    def __init__(self, sourceObject=None):
        ITextureFilter2D.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITextureFilter2D._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITextureFilter2D._get_property(self, attrname) is not None: found_prop = ITextureFilter2D._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TextureFilter2D.")
        
agcls.AgClassCatalog.add_catalog_entry("{DAE13DA7-D678-4F1F-9F87-F584DF78B8FE}", TextureFilter2D)


class TextureFilter2DFactory(ITextureFilter2DFactory):
    """Create texture filters."""
    def __init__(self, sourceObject=None):
        ITextureFilter2DFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITextureFilter2DFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITextureFilter2DFactory._get_property(self, attrname) is not None: found_prop = ITextureFilter2DFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TextureFilter2DFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{C17EDE04-6594-4662-975E-795B7623414B}", TextureFilter2DFactory)


class RendererTexture2D(IRendererTexture2D):
    """A 2D Texture. A texture represents an image that is ready for use by objects such as primitives and overlays. Textures typically reside in video memory."""
    def __init__(self, sourceObject=None):
        IRendererTexture2D.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRendererTexture2D._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRendererTexture2D._get_property(self, attrname) is not None: found_prop = IRendererTexture2D._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RendererTexture2D.")
        
agcls.AgClassCatalog.add_catalog_entry("{295B9996-B4D8-4AAD-B612-CB0348444732}", RendererTexture2D)


class RendererTextureTemplate2D(IRendererTextureTemplate2D):
    """Template object containing attributes required to create a 2D texture."""
    def __init__(self, sourceObject=None):
        IRendererTextureTemplate2D.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRendererTextureTemplate2D._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRendererTextureTemplate2D._get_property(self, attrname) is not None: found_prop = IRendererTextureTemplate2D._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RendererTextureTemplate2D.")
        
agcls.AgClassCatalog.add_catalog_entry("{0192E348-0FD1-440D-881D-EF3B882D7190}", RendererTextureTemplate2D)


class PathPointCollection(IPathPointCollection):
    """A collection of path points."""
    def __init__(self, sourceObject=None):
        IPathPointCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPathPointCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPathPointCollection._get_property(self, attrname) is not None: found_prop = IPathPointCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PathPointCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{B1EBC1AA-0D8C-417B-BD4B-3A1489C8D39E}", PathPointCollection)


class ObjectCollection(IObjectCollection):
    """A collection of objects."""
    def __init__(self, sourceObject=None):
        IObjectCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IObjectCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IObjectCollection._get_property(self, attrname) is not None: found_prop = IObjectCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ObjectCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{EEFF034B-5D72-4EF4-A76D-A25AEBD04B1E}", ObjectCollection)


class SceneCollection(ISceneCollection):
    """A collection of scenes."""
    def __init__(self, sourceObject=None):
        ISceneCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISceneCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISceneCollection._get_property(self, attrname) is not None: found_prop = ISceneCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SceneCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{1F9129CC-D135-4993-8E14-0AA4B8402AC8}", SceneCollection)


class ScreenOverlayPickResultCollection(IScreenOverlayPickResultCollection):
    """A collection of pick results."""
    def __init__(self, sourceObject=None):
        IScreenOverlayPickResultCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScreenOverlayPickResultCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScreenOverlayPickResultCollection._get_property(self, attrname) is not None: found_prop = IScreenOverlayPickResultCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScreenOverlayPickResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{566B0B55-437E-40E9-BB0C-1119BC58C3A4}", ScreenOverlayPickResultCollection)


class GlobeImageOverlayAddCompleteEventArgs(IGlobeImageOverlayAddCompleteEventArgs):
    """The event is raised when the globe image overlay is displayed for the first time after being added using AddAsync."""
    def __init__(self, sourceObject=None):
        IGlobeImageOverlayAddCompleteEventArgs.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGlobeImageOverlayAddCompleteEventArgs._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGlobeImageOverlayAddCompleteEventArgs._get_property(self, attrname) is not None: found_prop = IGlobeImageOverlayAddCompleteEventArgs._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GlobeImageOverlayAddCompleteEventArgs.")
        
agcls.AgClassCatalog.add_catalog_entry("{817BEFE9-18ED-489B-952E-8088AF90331D}", GlobeImageOverlayAddCompleteEventArgs)


class TerrainOverlayAddCompleteEventArgs(ITerrainOverlayAddCompleteEventArgs):
    """The event is raised when the terrain overlay is displayed for the first time after having been added using AddAsync."""
    def __init__(self, sourceObject=None):
        ITerrainOverlayAddCompleteEventArgs.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITerrainOverlayAddCompleteEventArgs._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITerrainOverlayAddCompleteEventArgs._get_property(self, attrname) is not None: found_prop = ITerrainOverlayAddCompleteEventArgs._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TerrainOverlayAddCompleteEventArgs.")
        
agcls.AgClassCatalog.add_catalog_entry("{589B5FC6-D8FE-4387-8E3E-188F6C6704C8}", TerrainOverlayAddCompleteEventArgs)


class PickResultCollection(IPickResultCollection):
    """A collection of picked objects."""
    def __init__(self, sourceObject=None):
        IPickResultCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPickResultCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPickResultCollection._get_property(self, attrname) is not None: found_prop = IPickResultCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PickResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{E6DDBF58-AB3C-4F46-AA2F-4D9A2E0884F8}", PickResultCollection)


class RenderingEventArgs(IRenderingEventArgs):
    """The event is raised when the scene is rendered."""
    def __init__(self, sourceObject=None):
        IRenderingEventArgs.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRenderingEventArgs._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRenderingEventArgs._get_property(self, attrname) is not None: found_prop = IRenderingEventArgs._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RenderingEventArgs.")
        
agcls.AgClassCatalog.add_catalog_entry("{46B2FD61-672F-4AD5-8588-F635D1EFB00C}", RenderingEventArgs)


class BatchPrimitiveIndex(IBatchPrimitiveIndex):
    """Represents an individual item index that is associated with a batch primitive. Provides the Index of the individual item and the Primitive that contains that index..."""
    def __init__(self, sourceObject=None):
        IBatchPrimitiveIndex.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBatchPrimitiveIndex._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBatchPrimitiveIndex._get_property(self, attrname) is not None: found_prop = IBatchPrimitiveIndex._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BatchPrimitiveIndex.")
        
agcls.AgClassCatalog.add_catalog_entry("{1AC81969-B283-482A-89A3-AE66819F864E}", BatchPrimitiveIndex)


class KmlDocumentCollection(IKmlDocumentCollection):
    """A collection of KML documents."""
    def __init__(self, sourceObject=None):
        IKmlDocumentCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IKmlDocumentCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IKmlDocumentCollection._get_property(self, attrname) is not None: found_prop = IKmlDocumentCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in KmlDocumentCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{2FB2F974-55DD-4862-B78F-8D9AA8B9167C}", KmlDocumentCollection)


class KmlFeatureCollection(IKmlFeatureCollection):
    """A collection of KML features."""
    def __init__(self, sourceObject=None):
        IKmlFeatureCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IKmlFeatureCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IKmlFeatureCollection._get_property(self, attrname) is not None: found_prop = IKmlFeatureCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in KmlFeatureCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{11C36E9E-AB1B-4F7A-B5CD-75B5E1F9DCA7}", KmlFeatureCollection)


class KmlDocumentLoadedEventArgs(IKmlDocumentLoadedEventArgs):
    """The event is raised when a KML document has been loaded."""
    def __init__(self, sourceObject=None):
        IKmlDocumentLoadedEventArgs.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IKmlDocumentLoadedEventArgs._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IKmlDocumentLoadedEventArgs._get_property(self, attrname) is not None: found_prop = IKmlDocumentLoadedEventArgs._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in KmlDocumentLoadedEventArgs.")
        
agcls.AgClassCatalog.add_catalog_entry("{77E26868-F894-4E5D-AE27-3D259B9763E3}", KmlDocumentLoadedEventArgs)


class FactoryAndInitializers(IFactoryAndInitializers):
    """Methods and properties are used to initialize new primitives, display conditions, screen overlays, textures and many other types; compute and retrieve triangulator results and access global properties (what's known as static properties, static methods a..."""
    def __init__(self, sourceObject=None):
        IFactoryAndInitializers.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IFactoryAndInitializers._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFactoryAndInitializers._get_property(self, attrname) is not None: found_prop = IFactoryAndInitializers._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FactoryAndInitializers.")
        
agcls.AgClassCatalog.add_catalog_entry("{06756FC9-1EF3-45CD-8A1F-CE6652BEA6C1}", FactoryAndInitializers)


class ExtrudedPolylineTriangulatorResult(IExtrudedPolylineTriangulatorResult, ITriangulatorResult):
    """The result from extruded polyline triangulation: a triangle mesh defined using an indexed triangle list with top and bottom boundary positions. The mesh is commonly visualized with the triangle mesh primitive or surface mesh primitive..."""
    def __init__(self, sourceObject=None):
        IExtrudedPolylineTriangulatorResult.__init__(self, sourceObject)
        ITriangulatorResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IExtrudedPolylineTriangulatorResult._private_init(self, pUnk)
        ITriangulatorResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IExtrudedPolylineTriangulatorResult._get_property(self, attrname) is not None: found_prop = IExtrudedPolylineTriangulatorResult._get_property(self, attrname)
        if ITriangulatorResult._get_property(self, attrname) is not None: found_prop = ITriangulatorResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ExtrudedPolylineTriangulatorResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{BD7096DB-7447-43A4-B1D7-7E831565C909}", ExtrudedPolylineTriangulatorResult)


class SolidTriangulatorResult(ISolidTriangulatorResult, ITriangulatorResult):
    """The result from a triangulation of a solid: a triangle mesh defined using an indexed triangle list and positions outlining the solid. It is recommended to visualize the solid using a solid primitive..."""
    def __init__(self, sourceObject=None):
        ISolidTriangulatorResult.__init__(self, sourceObject)
        ITriangulatorResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISolidTriangulatorResult._private_init(self, pUnk)
        ITriangulatorResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISolidTriangulatorResult._get_property(self, attrname) is not None: found_prop = ISolidTriangulatorResult._get_property(self, attrname)
        if ITriangulatorResult._get_property(self, attrname) is not None: found_prop = ITriangulatorResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SolidTriangulatorResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{D97A5AF7-129F-4972-9DFB-B894D917B328}", SolidTriangulatorResult)


class SurfaceShapesResult(ISurfaceShapesResult):
    """Represents the boundary positions of a shape on the surface computed from by a surface shapes method."""
    def __init__(self, sourceObject=None):
        ISurfaceShapesResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISurfaceShapesResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISurfaceShapesResult._get_property(self, attrname) is not None: found_prop = ISurfaceShapesResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SurfaceShapesResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{627EC36E-26FE-4D33-81B1-3A4CE5955DED}", SurfaceShapesResult)


class SurfaceTriangulatorResult(ISurfaceTriangulatorResult, ITriangulatorResult):
    """The result from a triangulation on the surface of a central body: a triangle mesh defined using an indexed triangle list and boundary positions surrounding the mesh..."""
    def __init__(self, sourceObject=None):
        ISurfaceTriangulatorResult.__init__(self, sourceObject)
        ITriangulatorResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISurfaceTriangulatorResult._private_init(self, pUnk)
        ITriangulatorResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISurfaceTriangulatorResult._get_property(self, attrname) is not None: found_prop = ISurfaceTriangulatorResult._get_property(self, attrname)
        if ITriangulatorResult._get_property(self, attrname) is not None: found_prop = ITriangulatorResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SurfaceTriangulatorResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{484F03DF-F617-49CC-A3AD-6AB09C86C400}", SurfaceTriangulatorResult)


class TriangulatorResult(ITriangulatorResult):
    """The result from triangulation: a triangle mesh defined using an indexed triangle list. This is commonly visualized with the triangle mesh primitive or surface mesh primitive."""
    def __init__(self, sourceObject=None):
        ITriangulatorResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITriangulatorResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITriangulatorResult._get_property(self, attrname) is not None: found_prop = ITriangulatorResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TriangulatorResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{1981E859-F957-4752-9B11-76A77512222B}", TriangulatorResult)


class AGICustomTerrainOverlay(IAGICustomTerrainOverlay, ITerrainOverlay, IGlobeOverlay):
    """A terrain overlay for handling AGI Cesium Terrain."""
    def __init__(self, sourceObject=None):
        IAGICustomTerrainOverlay.__init__(self, sourceObject)
        ITerrainOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAGICustomTerrainOverlay._private_init(self, pUnk)
        ITerrainOverlay._private_init(self, pUnk)
        IGlobeOverlay._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAGICustomTerrainOverlay._get_property(self, attrname) is not None: found_prop = IAGICustomTerrainOverlay._get_property(self, attrname)
        if ITerrainOverlay._get_property(self, attrname) is not None: found_prop = ITerrainOverlay._get_property(self, attrname)
        if IGlobeOverlay._get_property(self, attrname) is not None: found_prop = IGlobeOverlay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AGICustomTerrainOverlay.")
        
agcls.AgClassCatalog.add_catalog_entry("{474FD730-8942-48A2-B5C1-F84E6E5B112E}", AGICustomTerrainOverlay)


class AGIProcessedImageGlobeOverlay(IAGIProcessedImageGlobeOverlay, IGlobeImageOverlay, IGlobeOverlay):
    """A globe image overlay for handling AGI Processed Image (PDTTX) files."""
    def __init__(self, sourceObject=None):
        IAGIProcessedImageGlobeOverlay.__init__(self, sourceObject)
        IGlobeImageOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAGIProcessedImageGlobeOverlay._private_init(self, pUnk)
        IGlobeImageOverlay._private_init(self, pUnk)
        IGlobeOverlay._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAGIProcessedImageGlobeOverlay._get_property(self, attrname) is not None: found_prop = IAGIProcessedImageGlobeOverlay._get_property(self, attrname)
        if IGlobeImageOverlay._get_property(self, attrname) is not None: found_prop = IGlobeImageOverlay._get_property(self, attrname)
        if IGlobeOverlay._get_property(self, attrname) is not None: found_prop = IGlobeOverlay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AGIProcessedImageGlobeOverlay.")
        
agcls.AgClassCatalog.add_catalog_entry("{26895086-F748-4134-8B1E-E51EF358363D}", AGIProcessedImageGlobeOverlay)


class AGIProcessedTerrainOverlay(IAGIProcessedTerrainOverlay, ITerrainOverlay, IGlobeOverlay):
    """A terrain overlay for handling AGI Processed Terrain (PDTT) files."""
    def __init__(self, sourceObject=None):
        IAGIProcessedTerrainOverlay.__init__(self, sourceObject)
        ITerrainOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAGIProcessedTerrainOverlay._private_init(self, pUnk)
        ITerrainOverlay._private_init(self, pUnk)
        IGlobeOverlay._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAGIProcessedTerrainOverlay._get_property(self, attrname) is not None: found_prop = IAGIProcessedTerrainOverlay._get_property(self, attrname)
        if ITerrainOverlay._get_property(self, attrname) is not None: found_prop = ITerrainOverlay._get_property(self, attrname)
        if IGlobeOverlay._get_property(self, attrname) is not None: found_prop = IGlobeOverlay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AGIProcessedTerrainOverlay.")
        
agcls.AgClassCatalog.add_catalog_entry("{8B835120-12BD-4D18-AD78-2C507068F582}", AGIProcessedTerrainOverlay)


class AGIRoamImageGlobeOverlay(IAGIRoamImageGlobeOverlay, IGlobeImageOverlay, IGlobeOverlay):
    """A globe image overlay for handling ROAM (TXM/TXB) files."""
    def __init__(self, sourceObject=None):
        IAGIRoamImageGlobeOverlay.__init__(self, sourceObject)
        IGlobeImageOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAGIRoamImageGlobeOverlay._private_init(self, pUnk)
        IGlobeImageOverlay._private_init(self, pUnk)
        IGlobeOverlay._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAGIRoamImageGlobeOverlay._get_property(self, attrname) is not None: found_prop = IAGIRoamImageGlobeOverlay._get_property(self, attrname)
        if IGlobeImageOverlay._get_property(self, attrname) is not None: found_prop = IGlobeImageOverlay._get_property(self, attrname)
        if IGlobeOverlay._get_property(self, attrname) is not None: found_prop = IGlobeOverlay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AGIRoamImageGlobeOverlay.")
        
agcls.AgClassCatalog.add_catalog_entry("{278C21A7-3D85-48C1-B934-BE89B25019CE}", AGIRoamImageGlobeOverlay)


class CameraSnapshot(ICameraSnapshot):
    """Takes snapshots of the 3D window."""
    def __init__(self, sourceObject=None):
        ICameraSnapshot.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICameraSnapshot._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICameraSnapshot._get_property(self, attrname) is not None: found_prop = ICameraSnapshot._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CameraSnapshot.")
        
agcls.AgClassCatalog.add_catalog_entry("{27A8C9DC-6AF7-436A-80B0-7B426D85EAB1}", CameraSnapshot)


class CameraVideoRecording(ICameraVideoRecording):
    """Records the 3D window to either a movie file or to consecutively ordered image files each time the scene is rendered."""
    def __init__(self, sourceObject=None):
        ICameraVideoRecording.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICameraVideoRecording._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICameraVideoRecording._get_property(self, attrname) is not None: found_prop = ICameraVideoRecording._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CameraVideoRecording.")
        
agcls.AgClassCatalog.add_catalog_entry("{BBACA9D4-20A3-44B1-BF0F-174652805D72}", CameraVideoRecording)


class CentralBodyGraphicsIndexer(ICentralBodyGraphicsIndexer):
    """An indexer into the central body graphics for a particular central body, which provides graphical properties such as showing or hiding the central body in the scene, and working with terrain and imagery for the specified central body."""
    def __init__(self, sourceObject=None):
        ICentralBodyGraphicsIndexer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyGraphicsIndexer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyGraphicsIndexer._get_property(self, attrname) is not None: found_prop = ICentralBodyGraphicsIndexer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyGraphicsIndexer.")
        
agcls.AgClassCatalog.add_catalog_entry("{55BA55ED-B236-40BB-9F77-F7C32F3679FD}", CentralBodyGraphicsIndexer)


class CustomImageGlobeOverlay(ICustomImageGlobeOverlay, IGlobeImageOverlay, IGlobeOverlay):
    """A globe image overlay that allows for a user defined image to be specified."""
    def __init__(self, sourceObject=None):
        ICustomImageGlobeOverlay.__init__(self, sourceObject)
        IGlobeImageOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICustomImageGlobeOverlay._private_init(self, pUnk)
        IGlobeImageOverlay._private_init(self, pUnk)
        IGlobeOverlay._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICustomImageGlobeOverlay._get_property(self, attrname) is not None: found_prop = ICustomImageGlobeOverlay._get_property(self, attrname)
        if IGlobeImageOverlay._get_property(self, attrname) is not None: found_prop = IGlobeImageOverlay._get_property(self, attrname)
        if IGlobeOverlay._get_property(self, attrname) is not None: found_prop = IGlobeOverlay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CustomImageGlobeOverlay.")
        
agcls.AgClassCatalog.add_catalog_entry("{FAFB3856-9989-4712-8355-8047D169B49F}", CustomImageGlobeOverlay)


class CustomImageGlobeOverlayPluginActivator(ICustomImageGlobeOverlayPluginActivator):
    """The Activator class provides methods to load COM plugins that implement custom image globe overlays. For more information about custom image globe overlays, see the STK Programming Interface."""
    def __init__(self, sourceObject=None):
        ICustomImageGlobeOverlayPluginActivator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICustomImageGlobeOverlayPluginActivator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICustomImageGlobeOverlayPluginActivator._get_property(self, attrname) is not None: found_prop = ICustomImageGlobeOverlayPluginActivator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CustomImageGlobeOverlayPluginActivator.")
        
agcls.AgClassCatalog.add_catalog_entry("{06EE5B12-485C-4AFE-8D16-B1516F3D6BFE}", CustomImageGlobeOverlayPluginActivator)


class CustomImageGlobeOverlayPluginProxy(ICustomImageGlobeOverlayPluginProxy):
    """A proxy class provides access to a custom image globe overlay implemented by a plugin. Proxies are instantiated using custom image globe overlay plugin activator."""
    def __init__(self, sourceObject=None):
        ICustomImageGlobeOverlayPluginProxy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICustomImageGlobeOverlayPluginProxy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICustomImageGlobeOverlayPluginProxy._get_property(self, attrname) is not None: found_prop = ICustomImageGlobeOverlayPluginProxy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CustomImageGlobeOverlayPluginProxy.")
        
agcls.AgClassCatalog.add_catalog_entry("{1A2C5F92-FEFD-4961-B840-D940D30D3637}", CustomImageGlobeOverlayPluginProxy)


class GeospatialImageGlobeOverlay(IGeospatialImageGlobeOverlay, IGlobeImageOverlay, IGlobeOverlay):
    """A globe image overlay for handling `JPEG 2000 <https://jpeg.org/jpeg2000/>`_ (.jp2), ECW (.ecw), ECWP, and MrSid (.sid) image formats in the WGS84 geographic projection."""
    def __init__(self, sourceObject=None):
        IGeospatialImageGlobeOverlay.__init__(self, sourceObject)
        IGlobeImageOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGeospatialImageGlobeOverlay._private_init(self, pUnk)
        IGlobeImageOverlay._private_init(self, pUnk)
        IGlobeOverlay._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGeospatialImageGlobeOverlay._get_property(self, attrname) is not None: found_prop = IGeospatialImageGlobeOverlay._get_property(self, attrname)
        if IGlobeImageOverlay._get_property(self, attrname) is not None: found_prop = IGlobeImageOverlay._get_property(self, attrname)
        if IGlobeOverlay._get_property(self, attrname) is not None: found_prop = IGlobeOverlay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GeospatialImageGlobeOverlay.")
        
agcls.AgClassCatalog.add_catalog_entry("{B2C72817-48CC-498A-BAF5-71CBDEEE4BD2}", GeospatialImageGlobeOverlay)


class GlobeOverlay(IGlobeOverlay):
    """The base class of all terrain overlay and globe image overlay objects."""
    def __init__(self, sourceObject=None):
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGlobeOverlay._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGlobeOverlay._get_property(self, attrname) is not None: found_prop = IGlobeOverlay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GlobeOverlay.")
        
agcls.AgClassCatalog.add_catalog_entry("{4D2E94A8-DE1F-4382-AF9D-5664313F3E49}", GlobeOverlay)


class GlobeOverlaySettings(IGlobeOverlaySettings):
    """Settings used by globe overlay objects. These setting affect all scenes."""
    def __init__(self, sourceObject=None):
        IGlobeOverlaySettings.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGlobeOverlaySettings._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGlobeOverlaySettings._get_property(self, attrname) is not None: found_prop = IGlobeOverlaySettings._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GlobeOverlaySettings.")
        
agcls.AgClassCatalog.add_catalog_entry("{0F326F62-7A92-46B9-8CD4-F73A14B32A42}", GlobeOverlaySettings)


class Lighting(ILighting):
    """Lighting in the 3D scene."""
    def __init__(self, sourceObject=None):
        ILighting.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ILighting._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ILighting._get_property(self, attrname) is not None: found_prop = ILighting._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Lighting.")
        
agcls.AgClassCatalog.add_catalog_entry("{29C20830-2D8B-4E6B-854A-FDE514F4396A}", Lighting)


class PathPrimitiveUpdatePolicy(IPathPrimitiveUpdatePolicy):
    """A class that encapsulates the update logic for a path primitive. Derived classes must implement the Update method."""
    def __init__(self, sourceObject=None):
        IPathPrimitiveUpdatePolicy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPathPrimitiveUpdatePolicy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPathPrimitiveUpdatePolicy._get_property(self, attrname) is not None: found_prop = IPathPrimitiveUpdatePolicy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PathPrimitiveUpdatePolicy.")
        
agcls.AgClassCatalog.add_catalog_entry("{E1D3DA5F-ABD5-4C2D-891B-AB5A0FCE78A6}", PathPrimitiveUpdatePolicy)


class ProjectedRasterOverlay(IProjectedRasterOverlay, IGlobeImageOverlay, IGlobeOverlay):
    """A globe image overlay which projects a raster onto the terrain or surface of the central body. You can also enable projection onto models by setting projected raster model projection to true for a Scene..."""
    def __init__(self, sourceObject=None):
        IProjectedRasterOverlay.__init__(self, sourceObject)
        IGlobeImageOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProjectedRasterOverlay._private_init(self, pUnk)
        IGlobeImageOverlay._private_init(self, pUnk)
        IGlobeOverlay._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProjectedRasterOverlay._get_property(self, attrname) is not None: found_prop = IProjectedRasterOverlay._get_property(self, attrname)
        if IGlobeImageOverlay._get_property(self, attrname) is not None: found_prop = IGlobeImageOverlay._get_property(self, attrname)
        if IGlobeOverlay._get_property(self, attrname) is not None: found_prop = IGlobeOverlay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProjectedRasterOverlay.")
        
agcls.AgClassCatalog.add_catalog_entry("{ED508BB0-4EF1-412D-BEC2-46CF8F9BC5E2}", ProjectedRasterOverlay)


class Projection(IProjection):
    """A projection represents a simplified camera with a position, orientation, and field of view horizontal and field of view vertical..."""
    def __init__(self, sourceObject=None):
        IProjection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProjection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProjection._get_property(self, attrname) is not None: found_prop = IProjection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Projection.")
        
agcls.AgClassCatalog.add_catalog_entry("{3C06C59D-E24C-4145-9634-15ABB16CF69F}", Projection)


class ProjectionStream(IProjectionStream, IProjection):
    """A projection that is updated dynamically at the specified update delta. The class can be used to stream projection data to projection clients, like projected raster overlay..."""
    def __init__(self, sourceObject=None):
        IProjectionStream.__init__(self, sourceObject)
        IProjection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProjectionStream._private_init(self, pUnk)
        IProjection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProjectionStream._get_property(self, attrname) is not None: found_prop = IProjectionStream._get_property(self, attrname)
        if IProjection._get_property(self, attrname) is not None: found_prop = IProjection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProjectionStream.")
        
agcls.AgClassCatalog.add_catalog_entry("{02371735-0B2F-48AA-A51E-53DAEC21903D}", ProjectionStream)


class SceneGlobeOverlaySettings(ISceneGlobeOverlaySettings):
    """Settings used by globe overlay objects. These settings only affect the scene."""
    def __init__(self, sourceObject=None):
        ISceneGlobeOverlaySettings.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISceneGlobeOverlaySettings._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISceneGlobeOverlaySettings._get_property(self, attrname) is not None: found_prop = ISceneGlobeOverlaySettings._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SceneGlobeOverlaySettings.")
        
agcls.AgClassCatalog.add_catalog_entry("{AA19929F-DE78-4CDB-90C5-12D89532D4C4}", SceneGlobeOverlaySettings)


class ScreenOverlayCollectionBase(IScreenOverlayCollectionBase):
    """The common base class for collections of overlays held by screen overlay and by screen overlay manager."""
    def __init__(self, sourceObject=None):
        IScreenOverlayCollectionBase.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScreenOverlayCollectionBase._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScreenOverlayCollectionBase._get_property(self, attrname) is not None: found_prop = IScreenOverlayCollectionBase._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScreenOverlayCollectionBase.")
        
agcls.AgClassCatalog.add_catalog_entry("{B1764146-8986-45CB-A5B9-426988A9F289}", ScreenOverlayCollectionBase)


class Texture2DFactory(ITexture2DFactory):
    """A factory for creating texture 2d objects from various sources."""
    def __init__(self, sourceObject=None):
        ITexture2DFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITexture2DFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITexture2DFactory._get_property(self, attrname) is not None: found_prop = ITexture2DFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Texture2DFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{1BA44C8C-0CFB-4A7C-B687-788BD4D49AB2}", Texture2DFactory)


class VisualEffects(IVisualEffects):
    """Controls various post processing effects that can be applied to the scene."""
    def __init__(self, sourceObject=None):
        IVisualEffects.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVisualEffects._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVisualEffects._get_property(self, attrname) is not None: found_prop = IVisualEffects._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VisualEffects.")
        
agcls.AgClassCatalog.add_catalog_entry("{901f26d9-644b-4513-a3e9-d4d1f4c3df48}", VisualEffects)


class AltitudeDisplayCondition(IAltitudeDisplayCondition, IDisplayCondition):
    """Defines an inclusive altitude interval that determines when an object is rendered based on the camera's altitude relative to a central body."""
    def __init__(self, sourceObject=None):
        IAltitudeDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAltitudeDisplayCondition._private_init(self, pUnk)
        IDisplayCondition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAltitudeDisplayCondition._get_property(self, attrname) is not None: found_prop = IAltitudeDisplayCondition._get_property(self, attrname)
        if IDisplayCondition._get_property(self, attrname) is not None: found_prop = IDisplayCondition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AltitudeDisplayCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{E5AFCA9A-2850-44C4-BE11-930BB559872B}", AltitudeDisplayCondition)


class AxesPrimitive(IAxesPrimitive, IPrimitive):
    """Renders an axes in the 3D scene."""
    def __init__(self, sourceObject=None):
        IAxesPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesPrimitive._private_init(self, pUnk)
        IPrimitive._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesPrimitive._get_property(self, attrname) is not None: found_prop = IAxesPrimitive._get_property(self, attrname)
        if IPrimitive._get_property(self, attrname) is not None: found_prop = IPrimitive._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesPrimitive.")
        
agcls.AgClassCatalog.add_catalog_entry("{AE8A4146-1A03-4D94-95E4-4D1C67D5501F}", AxesPrimitive)


class Camera(ICamera):
    """Implemented by the scene camera. Contains operations to manipulate the camera position, view direction and orientation in the scene."""
    def __init__(self, sourceObject=None):
        ICamera.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICamera._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICamera._get_property(self, attrname) is not None: found_prop = ICamera._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Camera.")
        
agcls.AgClassCatalog.add_catalog_entry("{B11DEE46-76FD-46E6-9476-AEA896C1E2AF}", Camera)


class CentralBodyGraphics(ICentralBodyGraphics):
    """The graphical properties associated with a particular central body. Changing the central body graphics will affect how the associated central body is rendered in a scene. For instance, to show or hide the central body, use the show property..."""
    def __init__(self, sourceObject=None):
        ICentralBodyGraphics.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyGraphics._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyGraphics._get_property(self, attrname) is not None: found_prop = ICentralBodyGraphics._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyGraphics.")
        
agcls.AgClassCatalog.add_catalog_entry("{47858749-2CF1-48AF-ADCA-426C6E87B7EB}", CentralBodyGraphics)


class Clouds(IClouds):
    """Load, show and hide clouds in the scene."""
    def __init__(self, sourceObject=None):
        IClouds.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IClouds._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IClouds._get_property(self, attrname) is not None: found_prop = IClouds._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Clouds.")
        
agcls.AgClassCatalog.add_catalog_entry("{a98d31c3-daf0-40dd-ba64-0ceb18f0e522}", Clouds)


class CompositeDisplayCondition(ICompositeDisplayCondition, IDisplayCondition):
    """A composite of display conditions combined using a binary logic operation. For example, several time interval display condition objects can be added to a composite..."""
    def __init__(self, sourceObject=None):
        ICompositeDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICompositeDisplayCondition._private_init(self, pUnk)
        IDisplayCondition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICompositeDisplayCondition._get_property(self, attrname) is not None: found_prop = ICompositeDisplayCondition._get_property(self, attrname)
        if IDisplayCondition._get_property(self, attrname) is not None: found_prop = IDisplayCondition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CompositeDisplayCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{B59D2316-7712-462C-BB2F-3C882D18388E}", CompositeDisplayCondition)


class CompositePrimitive(ICompositePrimitive, IPrimitive):
    """ A primitive that is composed of multiple other primitives. Since composites can contain other composites, they are commonly used to build hierarchies of primitives to efficiently evaluate display conditions..."""
    def __init__(self, sourceObject=None):
        ICompositePrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICompositePrimitive._private_init(self, pUnk)
        IPrimitive._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICompositePrimitive._get_property(self, attrname) is not None: found_prop = ICompositePrimitive._get_property(self, attrname)
        if IPrimitive._get_property(self, attrname) is not None: found_prop = IPrimitive._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CompositePrimitive.")
        
agcls.AgClassCatalog.add_catalog_entry("{8F6F69B8-80C9-40F2-BC5B-BCEE656C8917}", CompositePrimitive)


class ConstantDisplayCondition(IConstantDisplayCondition, IDisplayCondition):
    """A display condition that evaluates to a user-defined value. This is commonly used to hide primitives by assigning to a primitive a display condition that always returns false."""
    def __init__(self, sourceObject=None):
        IConstantDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConstantDisplayCondition._private_init(self, pUnk)
        IDisplayCondition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConstantDisplayCondition._get_property(self, attrname) is not None: found_prop = IConstantDisplayCondition._get_property(self, attrname)
        if IDisplayCondition._get_property(self, attrname) is not None: found_prop = IDisplayCondition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConstantDisplayCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{C21814A8-7591-412D-9390-A6CE73468CA3}", ConstantDisplayCondition)


class DisplayCondition(IDisplayCondition):
    """When assigned to objects, such as primitives or globe overlays, display conditions are evaluated to determine if the object should be rendered."""
    def __init__(self, sourceObject=None):
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDisplayCondition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDisplayCondition._get_property(self, attrname) is not None: found_prop = IDisplayCondition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DisplayCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{CEC5D5EB-5AF8-4CCD-BD3D-EFF95DC04F26}", DisplayCondition)


class DistanceDisplayCondition(IDistanceDisplayCondition, IDisplayCondition):
    """Defines an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the object."""
    def __init__(self, sourceObject=None):
        IDistanceDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDistanceDisplayCondition._private_init(self, pUnk)
        IDisplayCondition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDistanceDisplayCondition._get_property(self, attrname) is not None: found_prop = IDistanceDisplayCondition._get_property(self, attrname)
        if IDisplayCondition._get_property(self, attrname) is not None: found_prop = IDisplayCondition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DistanceDisplayCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{0B5589C8-51E7-4191-BD54-8326BFF56CE2}", DistanceDisplayCondition)


class DistanceToGlobeOverlayDisplayCondition(IDistanceToGlobeOverlayDisplayCondition, IDisplayCondition):
    """Defines an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the globe overlay..."""
    def __init__(self, sourceObject=None):
        IDistanceToGlobeOverlayDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDistanceToGlobeOverlayDisplayCondition._private_init(self, pUnk)
        IDisplayCondition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDistanceToGlobeOverlayDisplayCondition._get_property(self, attrname) is not None: found_prop = IDistanceToGlobeOverlayDisplayCondition._get_property(self, attrname)
        if IDisplayCondition._get_property(self, attrname) is not None: found_prop = IDisplayCondition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DistanceToGlobeOverlayDisplayCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{E9C27719-711F-4E36-9FF9-DEF15D35581E}", DistanceToGlobeOverlayDisplayCondition)


class DistanceToPositionDisplayCondition(IDistanceToPositionDisplayCondition, IDisplayCondition):
    """Defines an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to a position defined in the given reference frame."""
    def __init__(self, sourceObject=None):
        IDistanceToPositionDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDistanceToPositionDisplayCondition._private_init(self, pUnk)
        IDisplayCondition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDistanceToPositionDisplayCondition._get_property(self, attrname) is not None: found_prop = IDistanceToPositionDisplayCondition._get_property(self, attrname)
        if IDisplayCondition._get_property(self, attrname) is not None: found_prop = IDisplayCondition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DistanceToPositionDisplayCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{ACD2A88B-E930-4994-AA0A-D37AEDB51182}", DistanceToPositionDisplayCondition)


class DistanceToPrimitiveDisplayCondition(IDistanceToPrimitiveDisplayCondition, IDisplayCondition):
    """Defines an inclusive distance interval that determines when an object, such as a screen overlay, is rendered based on the distance from the camera to the primitive..."""
    def __init__(self, sourceObject=None):
        IDistanceToPrimitiveDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDistanceToPrimitiveDisplayCondition._private_init(self, pUnk)
        IDisplayCondition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDistanceToPrimitiveDisplayCondition._get_property(self, attrname) is not None: found_prop = IDistanceToPrimitiveDisplayCondition._get_property(self, attrname)
        if IDisplayCondition._get_property(self, attrname) is not None: found_prop = IDisplayCondition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DistanceToPrimitiveDisplayCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{90A5B7AD-6FE1-4387-96B1-66A17A54FDA2}", DistanceToPrimitiveDisplayCondition)


class DurationPathPrimitiveUpdatePolicy(IDurationPathPrimitiveUpdatePolicy, IPathPrimitiveUpdatePolicy):
    """path primitive update policy that removes points from remove location after a given duration."""
    def __init__(self, sourceObject=None):
        IDurationPathPrimitiveUpdatePolicy.__init__(self, sourceObject)
        IPathPrimitiveUpdatePolicy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDurationPathPrimitiveUpdatePolicy._private_init(self, pUnk)
        IPathPrimitiveUpdatePolicy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDurationPathPrimitiveUpdatePolicy._get_property(self, attrname) is not None: found_prop = IDurationPathPrimitiveUpdatePolicy._get_property(self, attrname)
        if IPathPrimitiveUpdatePolicy._get_property(self, attrname) is not None: found_prop = IPathPrimitiveUpdatePolicy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DurationPathPrimitiveUpdatePolicy.")
        
agcls.AgClassCatalog.add_catalog_entry("{8628CCF8-7803-4528-B013-66116C059454}", DurationPathPrimitiveUpdatePolicy)


class FrameRate(IFrameRate):
    """Keeps track of how many times the scenes are rendered per second."""
    def __init__(self, sourceObject=None):
        IFrameRate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IFrameRate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFrameRate._get_property(self, attrname) is not None: found_prop = IFrameRate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FrameRate.")
        
agcls.AgClassCatalog.add_catalog_entry("{EB82B58B-6E32-4E91-92A8-E8008A5C4B77}", FrameRate)


class GlobeImageOverlay(IGlobeImageOverlay, IGlobeOverlay):
    """A globe overlay that shows an image."""
    def __init__(self, sourceObject=None):
        IGlobeImageOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGlobeImageOverlay._private_init(self, pUnk)
        IGlobeOverlay._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGlobeImageOverlay._get_property(self, attrname) is not None: found_prop = IGlobeImageOverlay._get_property(self, attrname)
        if IGlobeOverlay._get_property(self, attrname) is not None: found_prop = IGlobeOverlay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GlobeImageOverlay.")
        
agcls.AgClassCatalog.add_catalog_entry("{5316E632-3018-4625-866F-E56F29FFBC05}", GlobeImageOverlay)


class GraphicsFont(IGraphicsFont):
    """A font that is suitable for use with the text batch primitive. For best performance, avoid creating duplicate font objects. Instead assign the same font object to several text batch primitives."""
    def __init__(self, sourceObject=None):
        IGraphicsFont.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGraphicsFont._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGraphicsFont._get_property(self, attrname) is not None: found_prop = IGraphicsFont._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GraphicsFont.")
        
agcls.AgClassCatalog.add_catalog_entry("{C48AD7DF-40C9-4A57-86CD-E7B0E4BFCF52}", GraphicsFont)


class GreatArcInterpolator(IGreatArcInterpolator, IPositionInterpolator):
    """The great arc interpolator computes interpolated positions along a great arc. A great arc is the shortest path between two positions on an ellipsoid."""
    def __init__(self, sourceObject=None):
        IGreatArcInterpolator.__init__(self, sourceObject)
        IPositionInterpolator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGreatArcInterpolator._private_init(self, pUnk)
        IPositionInterpolator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGreatArcInterpolator._get_property(self, attrname) is not None: found_prop = IGreatArcInterpolator._get_property(self, attrname)
        if IPositionInterpolator._get_property(self, attrname) is not None: found_prop = IPositionInterpolator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GreatArcInterpolator.")
        
agcls.AgClassCatalog.add_catalog_entry("{A91AC76D-7326-4103-996E-DE20EB349A61}", GreatArcInterpolator)


class ImageCollection(IImageCollection):
    """A collection of globe image overlay objects."""
    def __init__(self, sourceObject=None):
        IImageCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IImageCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IImageCollection._get_property(self, attrname) is not None: found_prop = IImageCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ImageCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{26812ED6-0AB2-4554-A01F-A1E52687763D}", ImageCollection)


class AlphaFromLuminanceFilter(IAlphaFromLuminanceFilter, IRasterFilter):
    """Adds an alpha band to the source raster derived from the luminance of the raster's color bands."""
    def __init__(self, sourceObject=None):
        IAlphaFromLuminanceFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAlphaFromLuminanceFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAlphaFromLuminanceFilter._get_property(self, attrname) is not None: found_prop = IAlphaFromLuminanceFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AlphaFromLuminanceFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{7D660FC7-F1D2-4189-A5C7-B2BFD97E1B4E}", AlphaFromLuminanceFilter)


class AlphaFromPixelFilter(IAlphaFromPixelFilter, IRasterFilter):
    """Adds an alpha band to the source raster based on the value of its first pixel. All pixels in the source raster that are the same color as the first pixel will be made transparent."""
    def __init__(self, sourceObject=None):
        IAlphaFromPixelFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAlphaFromPixelFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAlphaFromPixelFilter._get_property(self, attrname) is not None: found_prop = IAlphaFromPixelFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AlphaFromPixelFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{B2D2B3A3-9FA8-4B58-9CA5-89705663DEDB}", AlphaFromPixelFilter)


class AlphaFromRasterFilter(IAlphaFromRasterFilter, IRasterFilter):
    """Adds an alpha band to the source raster derived from the color bands or alpha of another raster. This filter can be used to apply an alpha mask to the source raster."""
    def __init__(self, sourceObject=None):
        IAlphaFromRasterFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAlphaFromRasterFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAlphaFromRasterFilter._get_property(self, attrname) is not None: found_prop = IAlphaFromRasterFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AlphaFromRasterFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{5E83A2AD-0A40-4CFC-823A-311AC8B034B3}", AlphaFromRasterFilter)


class BandExtractFilter(IBandExtractFilter, IRasterFilter):
    """Extracts a band or set of bands from the source raster. The extract format property specifies the bands and the order of the bands that will be extracted."""
    def __init__(self, sourceObject=None):
        IBandExtractFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBandExtractFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBandExtractFilter._get_property(self, attrname) is not None: found_prop = IBandExtractFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BandExtractFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{DC9176BE-3DBD-40D1-A0BC-CEDE39C747E2}", BandExtractFilter)


class BandOrderFilter(IBandOrderFilter, IRasterFilter):
    """Reorders or swizzles the bands of the source raster to match the band order of the raster format specified by the band order property. When maintain raster format is true, the source raster's format is maintained after swizzling."""
    def __init__(self, sourceObject=None):
        IBandOrderFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBandOrderFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBandOrderFilter._get_property(self, attrname) is not None: found_prop = IBandOrderFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BandOrderFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{91749CD4-8503-4C71-AD42-DB5AAF1BC240}", BandOrderFilter)


class BlurFilter(IBlurFilter, IConvolutionFilter, IRasterFilter):
    """Applies a convolution filter to blur or smooth the source raster. Can be used to reduce noise in the raster."""
    def __init__(self, sourceObject=None):
        IBlurFilter.__init__(self, sourceObject)
        IConvolutionFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBlurFilter._private_init(self, pUnk)
        IConvolutionFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBlurFilter._get_property(self, attrname) is not None: found_prop = IBlurFilter._get_property(self, attrname)
        if IConvolutionFilter._get_property(self, attrname) is not None: found_prop = IConvolutionFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BlurFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{A3E1128F-DE2D-4A57-AC68-C7C938480BF2}", BlurFilter)


class BrightnessFilter(IBrightnessFilter, IRasterFilter):
    """Adjusts the brightness of the source raster's color bands. The adjustment to brightness is a value between -1 and 1, corresponding to least bright to most bright."""
    def __init__(self, sourceObject=None):
        IBrightnessFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBrightnessFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBrightnessFilter._get_property(self, attrname) is not None: found_prop = IBrightnessFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BrightnessFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{E6FF496E-64E8-41CA-BED7-8FEBDDB6B9C9}", BrightnessFilter)


class ColorToLuminanceFilter(IColorToLuminanceFilter, IRasterFilter):
    """Extracts a luminance band derived from the color bands of the source raster."""
    def __init__(self, sourceObject=None):
        IColorToLuminanceFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IColorToLuminanceFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IColorToLuminanceFilter._get_property(self, attrname) is not None: found_prop = IColorToLuminanceFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ColorToLuminanceFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{BE472786-A17B-490A-8DE7-4831AC3FEEDE}", ColorToLuminanceFilter)


class ContrastFilter(IContrastFilter, IRasterFilter):
    """Adjusts the contrast of the source raster. The adjustment to contrast is a value between -1 and 1, corresponding to least contrast to most contrast."""
    def __init__(self, sourceObject=None):
        IContrastFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IContrastFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IContrastFilter._get_property(self, attrname) is not None: found_prop = IContrastFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ContrastFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{20FA2A78-30D4-4DDE-84D7-EBF001730166}", ContrastFilter)


class ConvolutionFilter(IConvolutionFilter, IRasterFilter):
    """Applies convolution to the source raster. Convolution is the modification of a pixel's value based on the values of its surrounding pixels. The kernel is the numerical matrix that is applied to each pixel in this process..."""
    def __init__(self, sourceObject=None):
        IConvolutionFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConvolutionFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConvolutionFilter._get_property(self, attrname) is not None: found_prop = IConvolutionFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConvolutionFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{113D939E-C5B0-49BD-A38B-53DD961CAC5B}", ConvolutionFilter)


class EdgeDetectFilter(IEdgeDetectFilter, IConvolutionFilter, IRasterFilter):
    """Applies a convolution filter to detect edges in the source raster."""
    def __init__(self, sourceObject=None):
        IEdgeDetectFilter.__init__(self, sourceObject)
        IConvolutionFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEdgeDetectFilter._private_init(self, pUnk)
        IConvolutionFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEdgeDetectFilter._get_property(self, attrname) is not None: found_prop = IEdgeDetectFilter._get_property(self, attrname)
        if IConvolutionFilter._get_property(self, attrname) is not None: found_prop = IConvolutionFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EdgeDetectFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{04E73117-38A1-4EE3-854D-253934DE9B54}", EdgeDetectFilter)


class FilteringRasterStream(IFilteringRasterStream, IRasterStream, IRaster):
    """A class decorator for applying a raster filter to each update of a raster stream. Can be used to apply filters to videos and other raster streams as they are updated."""
    def __init__(self, sourceObject=None):
        IFilteringRasterStream.__init__(self, sourceObject)
        IRasterStream.__init__(self, sourceObject)
        IRaster.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IFilteringRasterStream._private_init(self, pUnk)
        IRasterStream._private_init(self, pUnk)
        IRaster._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFilteringRasterStream._get_property(self, attrname) is not None: found_prop = IFilteringRasterStream._get_property(self, attrname)
        if IRasterStream._get_property(self, attrname) is not None: found_prop = IRasterStream._get_property(self, attrname)
        if IRaster._get_property(self, attrname) is not None: found_prop = IRaster._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FilteringRasterStream.")
        
agcls.AgClassCatalog.add_catalog_entry("{9D59ED29-9EF8-4D85-BE0F-9E244736C814}", FilteringRasterStream)


class FlipFilter(IFlipFilter, IRasterFilter):
    """Flips the source raster along the given flip axis."""
    def __init__(self, sourceObject=None):
        IFlipFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IFlipFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFlipFilter._get_property(self, attrname) is not None: found_prop = IFlipFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FlipFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{08E0C45D-A187-4B74-93AE-BF29B39D50C3}", FlipFilter)


class GammaCorrectionFilter(IGammaCorrectionFilter, IRasterFilter):
    """Applies gamma correction to the source raster. The gamma is a value between .2 and 5. The default gamma value is 2.2."""
    def __init__(self, sourceObject=None):
        IGammaCorrectionFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGammaCorrectionFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGammaCorrectionFilter._get_property(self, attrname) is not None: found_prop = IGammaCorrectionFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GammaCorrectionFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{A560ACC2-4642-44FD-A5FC-BD3AB7A0FC2F}", GammaCorrectionFilter)


class GaussianBlurFilter(IGaussianBlurFilter, IConvolutionFilter, IRasterFilter):
    """Applies a convolution filter to blur the source raster using the Gaussian function."""
    def __init__(self, sourceObject=None):
        IGaussianBlurFilter.__init__(self, sourceObject)
        IConvolutionFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGaussianBlurFilter._private_init(self, pUnk)
        IConvolutionFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGaussianBlurFilter._get_property(self, attrname) is not None: found_prop = IGaussianBlurFilter._get_property(self, attrname)
        if IConvolutionFilter._get_property(self, attrname) is not None: found_prop = IConvolutionFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GaussianBlurFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{BCEE5F1C-66D8-48C6-8485-8435260855DE}", GaussianBlurFilter)


class GradientDetectFilter(IGradientDetectFilter, IConvolutionFilter, IRasterFilter):
    """Applies a convolution filter to detect gradients in the source raster."""
    def __init__(self, sourceObject=None):
        IGradientDetectFilter.__init__(self, sourceObject)
        IConvolutionFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGradientDetectFilter._private_init(self, pUnk)
        IConvolutionFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGradientDetectFilter._get_property(self, attrname) is not None: found_prop = IGradientDetectFilter._get_property(self, attrname)
        if IConvolutionFilter._get_property(self, attrname) is not None: found_prop = IConvolutionFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GradientDetectFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{7F410D2F-C209-4F22-A906-5F8BA0C8CA40}", GradientDetectFilter)


class LevelsFilter(ILevelsFilter, IRasterFilter):
    """Adjusts the band levels of the source raster linearly."""
    def __init__(self, sourceObject=None):
        ILevelsFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ILevelsFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ILevelsFilter._get_property(self, attrname) is not None: found_prop = ILevelsFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LevelsFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{C21CE0FC-3E94-47C9-9E21-C8478A46E75C}", LevelsFilter)


class ProjectionRasterStreamPluginActivator(IProjectionRasterStreamPluginActivator):
    """The Activator class provides methods to load COM plugins that implement projection and raster streaming. For more information about the projection and raster plugins, see the STK Programming Interface."""
    def __init__(self, sourceObject=None):
        IProjectionRasterStreamPluginActivator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProjectionRasterStreamPluginActivator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProjectionRasterStreamPluginActivator._get_property(self, attrname) is not None: found_prop = IProjectionRasterStreamPluginActivator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProjectionRasterStreamPluginActivator.")
        
agcls.AgClassCatalog.add_catalog_entry("{5365D424-8630-4D9D-B209-F946D5116080}", ProjectionRasterStreamPluginActivator)


class ProjectionRasterStreamPluginProxy(IProjectionRasterStreamPluginProxy):
    """A proxy class provides access to the raster and projection streams implemented by a plugin. Proxies are instantiated using projection raster stream plugin activator."""
    def __init__(self, sourceObject=None):
        IProjectionRasterStreamPluginProxy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProjectionRasterStreamPluginProxy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProjectionRasterStreamPluginProxy._get_property(self, attrname) is not None: found_prop = IProjectionRasterStreamPluginProxy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProjectionRasterStreamPluginProxy.")
        
agcls.AgClassCatalog.add_catalog_entry("{82E6B1F4-DC2D-40C3-8251-8207F218B820}", ProjectionRasterStreamPluginProxy)


class Raster(IRaster):
    """A raster dataset. A raster consists of one or more bands, or sets of values, which are most commonly associated with colors when the raster represents an image..."""
    def __init__(self, sourceObject=None):
        IRaster.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRaster._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRaster._get_property(self, attrname) is not None: found_prop = IRaster._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Raster.")
        
agcls.AgClassCatalog.add_catalog_entry("{50AB6A3A-54CA-4619-9B99-FB7BD497EA92}", Raster)


class RasterAttributes(IRasterAttributes):
    """The attributes describing a raster dataset. raster attributes define the memory layout of a raster, and includes properties defining the order of each raster band that the raster contains, as specified by the raster format..."""
    def __init__(self, sourceObject=None):
        IRasterAttributes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRasterAttributes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRasterAttributes._get_property(self, attrname) is not None: found_prop = IRasterAttributes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RasterAttributes.")
        
agcls.AgClassCatalog.add_catalog_entry("{32DEB10A-1039-43AF-AA36-BA94F8CC8531}", RasterAttributes)


class RasterFilter(IRasterFilter):
    """A filter for processing raster datasets. RasterFilter is the base class for all raster filters..."""
    def __init__(self, sourceObject=None):
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RasterFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{0345FD5E-C6A6-42D3-AEA9-57A7444BFF42}", RasterFilter)


class RasterStream(IRasterStream, IRaster):
    """A raster, the data of which, is updated dynamically at the specified update delta. The class can be used to stream video and other dynamic raster data to textures and other raster clients..."""
    def __init__(self, sourceObject=None):
        IRasterStream.__init__(self, sourceObject)
        IRaster.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRasterStream._private_init(self, pUnk)
        IRaster._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRasterStream._get_property(self, attrname) is not None: found_prop = IRasterStream._get_property(self, attrname)
        if IRaster._get_property(self, attrname) is not None: found_prop = IRaster._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RasterStream.")
        
agcls.AgClassCatalog.add_catalog_entry("{CAFADC5E-933C-46AC-BD09-18B089E86346}", RasterStream)


class RotateFilter(IRotateFilter, IRasterFilter):
    """Rotates the source raster clockwise by the specified angle."""
    def __init__(self, sourceObject=None):
        IRotateFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRotateFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRotateFilter._get_property(self, attrname) is not None: found_prop = IRotateFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RotateFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{AEDFA944-E740-4D19-9819-CB179C43E060}", RotateFilter)


class SequenceFilter(ISequenceFilter, IRasterFilter):
    """Applies a sequence of filters to the source raster in the order in which they were added. When continue on failure is set to true, subsequent filters will still be applied to the source raster even if one or more filters in the sequence cannot be applied."""
    def __init__(self, sourceObject=None):
        ISequenceFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISequenceFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISequenceFilter._get_property(self, attrname) is not None: found_prop = ISequenceFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SequenceFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{37330024-90FE-47DD-9548-C13089A085FC}", SequenceFilter)


class SharpenFilter(ISharpenFilter, IConvolutionFilter, IRasterFilter):
    """Applies a convolution filter to increase the sharpness of the source raster."""
    def __init__(self, sourceObject=None):
        ISharpenFilter.__init__(self, sourceObject)
        IConvolutionFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISharpenFilter._private_init(self, pUnk)
        IConvolutionFilter._private_init(self, pUnk)
        IRasterFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISharpenFilter._get_property(self, attrname) is not None: found_prop = ISharpenFilter._get_property(self, attrname)
        if IConvolutionFilter._get_property(self, attrname) is not None: found_prop = IConvolutionFilter._get_property(self, attrname)
        if IRasterFilter._get_property(self, attrname) is not None: found_prop = IRasterFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SharpenFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{0F6FC309-D30E-41AD-A7B6-E70039313B6E}", SharpenFilter)


class VideoStream(IVideoStream, IRasterStream, IRaster):
    """A raster stream that streams from a video. The video can be read from a file, or streamed from an HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""
    def __init__(self, sourceObject=None):
        IVideoStream.__init__(self, sourceObject)
        IRasterStream.__init__(self, sourceObject)
        IRaster.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVideoStream._private_init(self, pUnk)
        IRasterStream._private_init(self, pUnk)
        IRaster._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVideoStream._get_property(self, attrname) is not None: found_prop = IVideoStream._get_property(self, attrname)
        if IRasterStream._get_property(self, attrname) is not None: found_prop = IRasterStream._get_property(self, attrname)
        if IRaster._get_property(self, attrname) is not None: found_prop = IRaster._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VideoStream.")
        
agcls.AgClassCatalog.add_catalog_entry("{80D82D96-D87B-4910-B8BB-1FBE9E121A4F}", VideoStream)


class KmlContainer(IKmlContainer, IKmlFeature):
    """A KmlContainer contains a collection of children kml features."""
    def __init__(self, sourceObject=None):
        IKmlContainer.__init__(self, sourceObject)
        IKmlFeature.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IKmlContainer._private_init(self, pUnk)
        IKmlFeature._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IKmlContainer._get_property(self, attrname) is not None: found_prop = IKmlContainer._get_property(self, attrname)
        if IKmlFeature._get_property(self, attrname) is not None: found_prop = IKmlFeature._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in KmlContainer.")
        
agcls.AgClassCatalog.add_catalog_entry("{24AA1395-417E-4845-A9D2-61C4D59BCABF}", KmlContainer)


class KmlDocument(IKmlDocument, IKmlContainer, IKmlFeature):
    """A KML document."""
    def __init__(self, sourceObject=None):
        IKmlDocument.__init__(self, sourceObject)
        IKmlContainer.__init__(self, sourceObject)
        IKmlFeature.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IKmlDocument._private_init(self, pUnk)
        IKmlContainer._private_init(self, pUnk)
        IKmlFeature._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IKmlDocument._get_property(self, attrname) is not None: found_prop = IKmlDocument._get_property(self, attrname)
        if IKmlContainer._get_property(self, attrname) is not None: found_prop = IKmlContainer._get_property(self, attrname)
        if IKmlFeature._get_property(self, attrname) is not None: found_prop = IKmlFeature._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in KmlDocument.")
        
agcls.AgClassCatalog.add_catalog_entry("{130689C0-43C6-4C34-9AC7-252E155E9F66}", KmlDocument)


class KmlFeature(IKmlFeature):
    """A KML feature."""
    def __init__(self, sourceObject=None):
        IKmlFeature.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IKmlFeature._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IKmlFeature._get_property(self, attrname) is not None: found_prop = IKmlFeature._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in KmlFeature.")
        
agcls.AgClassCatalog.add_catalog_entry("{20C290F8-9102-4960-AD19-F5EFC321F796}", KmlFeature)


class KmlFolder(IKmlFolder, IKmlContainer, IKmlFeature):
    """A KML folder."""
    def __init__(self, sourceObject=None):
        IKmlFolder.__init__(self, sourceObject)
        IKmlContainer.__init__(self, sourceObject)
        IKmlFeature.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IKmlFolder._private_init(self, pUnk)
        IKmlContainer._private_init(self, pUnk)
        IKmlFeature._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IKmlFolder._get_property(self, attrname) is not None: found_prop = IKmlFolder._get_property(self, attrname)
        if IKmlContainer._get_property(self, attrname) is not None: found_prop = IKmlContainer._get_property(self, attrname)
        if IKmlFeature._get_property(self, attrname) is not None: found_prop = IKmlFeature._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in KmlFolder.")
        
agcls.AgClassCatalog.add_catalog_entry("{C7BE1A8D-28BF-4298-AE7D-656B40FFB3D0}", KmlFolder)


class KmlGraphics(IKmlGraphics):
    """Provides loading and unloading of kml documents for a particular central body."""
    def __init__(self, sourceObject=None):
        IKmlGraphics.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IKmlGraphics._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IKmlGraphics._get_property(self, attrname) is not None: found_prop = IKmlGraphics._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in KmlGraphics.")
        
agcls.AgClassCatalog.add_catalog_entry("{A094F5DE-8BF2-4079-8009-0450D2E4EF11}", KmlGraphics)


class KmlNetworkLink(IKmlNetworkLink, IKmlFeature):
    """A KML network link."""
    def __init__(self, sourceObject=None):
        IKmlNetworkLink.__init__(self, sourceObject)
        IKmlFeature.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IKmlNetworkLink._private_init(self, pUnk)
        IKmlFeature._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IKmlNetworkLink._get_property(self, attrname) is not None: found_prop = IKmlNetworkLink._get_property(self, attrname)
        if IKmlFeature._get_property(self, attrname) is not None: found_prop = IKmlFeature._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in KmlNetworkLink.")
        
agcls.AgClassCatalog.add_catalog_entry("{BD2ECA7D-919B-4C64-8AA1-E503A80EF3EA}", KmlNetworkLink)


class MarkerBatchPrimitive(IMarkerBatchPrimitive, IPrimitive):
    """ Renders one or more markers in the 3D scene. Markers are 2D images that always face the viewer which can be sized in pixels or meters. Markers are also referred to as sprites or billboards..."""
    def __init__(self, sourceObject=None):
        IMarkerBatchPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMarkerBatchPrimitive._private_init(self, pUnk)
        IPrimitive._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMarkerBatchPrimitive._get_property(self, attrname) is not None: found_prop = IMarkerBatchPrimitive._get_property(self, attrname)
        if IPrimitive._get_property(self, attrname) is not None: found_prop = IPrimitive._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MarkerBatchPrimitive.")
        
agcls.AgClassCatalog.add_catalog_entry("{C7F4992D-BBE2-4C68-BB4E-51BB8CD2D124}", MarkerBatchPrimitive)


class MarkerBatchPrimitiveOptionalParameters(IMarkerBatchPrimitiveOptionalParameters):
    """Optional per-marker parameters for marker batch primitive that overrides the marker batch's per-batch parameters..."""
    def __init__(self, sourceObject=None):
        IMarkerBatchPrimitiveOptionalParameters.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMarkerBatchPrimitiveOptionalParameters._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMarkerBatchPrimitiveOptionalParameters._get_property(self, attrname) is not None: found_prop = IMarkerBatchPrimitiveOptionalParameters._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MarkerBatchPrimitiveOptionalParameters.")
        
agcls.AgClassCatalog.add_catalog_entry("{24750753-2036-4221-83F0-F9045DCA0A5D}", MarkerBatchPrimitiveOptionalParameters)


class MaximumCountPathPrimitiveUpdatePolicy(IMaximumCountPathPrimitiveUpdatePolicy, IPathPrimitiveUpdatePolicy):
    """path primitive update policy that removes points from remove location when the number of points in the path exceeds maximum count."""
    def __init__(self, sourceObject=None):
        IMaximumCountPathPrimitiveUpdatePolicy.__init__(self, sourceObject)
        IPathPrimitiveUpdatePolicy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMaximumCountPathPrimitiveUpdatePolicy._private_init(self, pUnk)
        IPathPrimitiveUpdatePolicy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMaximumCountPathPrimitiveUpdatePolicy._get_property(self, attrname) is not None: found_prop = IMaximumCountPathPrimitiveUpdatePolicy._get_property(self, attrname)
        if IPathPrimitiveUpdatePolicy._get_property(self, attrname) is not None: found_prop = IPathPrimitiveUpdatePolicy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MaximumCountPathPrimitiveUpdatePolicy.")
        
agcls.AgClassCatalog.add_catalog_entry("{4D41C220-2CE4-4CA1-942A-9AF4F7F34C4A}", MaximumCountPathPrimitiveUpdatePolicy)


class ModelArticulation(IModelArticulation):
    """A model articulation identifies geometry on the model and is a collection of transformations that can be applied to that geometry."""
    def __init__(self, sourceObject=None):
        IModelArticulation.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IModelArticulation._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IModelArticulation._get_property(self, attrname) is not None: found_prop = IModelArticulation._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ModelArticulation.")
        
agcls.AgClassCatalog.add_catalog_entry("{A9E72E72-17D6-4D7C-A4EF-5A970232ED93}", ModelArticulation)


class ModelArticulationCollection(IModelArticulationCollection):
    """A collection containing a model primitive's available articulations. A model articulation identifies geometry on the model and is a collection of transformations that can be applied to that geometry."""
    def __init__(self, sourceObject=None):
        IModelArticulationCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IModelArticulationCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IModelArticulationCollection._get_property(self, attrname) is not None: found_prop = IModelArticulationCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ModelArticulationCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{ACC4920A-6D6B-4374-937F-2469F439ABA8}", ModelArticulationCollection)


class ModelPrimitive(IModelPrimitive, IPrimitive):
    """The model primitive loads and renders `COLLADA <https://www.khronos.org/collada/>`_ (DAE) and AGI `MDL <https://support.agi.com/3d-models>`_ (MDL) models."""
    def __init__(self, sourceObject=None):
        IModelPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IModelPrimitive._private_init(self, pUnk)
        IPrimitive._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IModelPrimitive._get_property(self, attrname) is not None: found_prop = IModelPrimitive._get_property(self, attrname)
        if IPrimitive._get_property(self, attrname) is not None: found_prop = IPrimitive._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ModelPrimitive.")
        
agcls.AgClassCatalog.add_catalog_entry("{FD89B6D8-F106-4929-889A-3304A9CDBE97}", ModelPrimitive)


class ModelTransformation(IModelTransformation):
    """A model transformation defines a transformation that is applied to geometry on a model primitive. That geometry is identified by the model articulation which contains the transformation..."""
    def __init__(self, sourceObject=None):
        IModelTransformation.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IModelTransformation._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IModelTransformation._get_property(self, attrname) is not None: found_prop = IModelTransformation._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ModelTransformation.")
        
agcls.AgClassCatalog.add_catalog_entry("{BC56F0E9-D0F3-4C3E-9AAA-AB5AB255927C}", ModelTransformation)


class Overlay(IOverlay, IScreenOverlayContainer):
    """A visible element drawn in screen space. Overlays are useful for floating logos, heads up displays, and integrating user interfaces into the 3D window."""
    def __init__(self, sourceObject=None):
        IOverlay.__init__(self, sourceObject)
        IScreenOverlayContainer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IOverlay._private_init(self, pUnk)
        IScreenOverlayContainer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IOverlay._get_property(self, attrname) is not None: found_prop = IOverlay._get_property(self, attrname)
        if IScreenOverlayContainer._get_property(self, attrname) is not None: found_prop = IScreenOverlayContainer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Overlay.")
        
agcls.AgClassCatalog.add_catalog_entry("{6D9C8A3B-0EC8-428F-BC05-1F30315E92DC}", Overlay)


class PathPrimitive(IPathPrimitive, IPrimitive):
    """Renders a line to the 3D scene. Similar to the polyline primitive; however, the PathPrimitive was designed for the efficient addition/removal of points to/from the front or back of the line."""
    def __init__(self, sourceObject=None):
        IPathPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPathPrimitive._private_init(self, pUnk)
        IPrimitive._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPathPrimitive._get_property(self, attrname) is not None: found_prop = IPathPrimitive._get_property(self, attrname)
        if IPrimitive._get_property(self, attrname) is not None: found_prop = IPrimitive._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PathPrimitive.")
        
agcls.AgClassCatalog.add_catalog_entry("{AFDCAA13-BE39-4E17-9AC5-06C08933A910}", PathPrimitive)


class PickResult(IPickResult):
    """A single result from Pick."""
    def __init__(self, sourceObject=None):
        IPickResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPickResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPickResult._get_property(self, attrname) is not None: found_prop = IPickResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PickResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{E007C42E-13D7-4006-992A-B996CEA3BE49}", PickResult)


class PixelSizeDisplayCondition(IPixelSizeDisplayCondition, IDisplayCondition):
    """Defines an inclusive interval, in pixels, that determines when an object, such as a primitive, is rendered based on the number of pixels the object's bounding sphere (or in the case of screen overlays, bounding rectangle) covers on the screen..."""
    def __init__(self, sourceObject=None):
        IPixelSizeDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPixelSizeDisplayCondition._private_init(self, pUnk)
        IDisplayCondition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPixelSizeDisplayCondition._get_property(self, attrname) is not None: found_prop = IPixelSizeDisplayCondition._get_property(self, attrname)
        if IDisplayCondition._get_property(self, attrname) is not None: found_prop = IDisplayCondition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PixelSizeDisplayCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{26B1DA4F-DA20-4E44-A98D-D54CC67821B8}", PixelSizeDisplayCondition)


class PointBatchPrimitive(IPointBatchPrimitive, IPrimitive):
    """ Renders one or more points in the 3D scene. Each point in the batch has a unique position and an optional color. All points in the batch share the same pixel size. For best performance, avoid creating lots of batches with only a few points each..."""
    def __init__(self, sourceObject=None):
        IPointBatchPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointBatchPrimitive._private_init(self, pUnk)
        IPrimitive._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointBatchPrimitive._get_property(self, attrname) is not None: found_prop = IPointBatchPrimitive._get_property(self, attrname)
        if IPrimitive._get_property(self, attrname) is not None: found_prop = IPrimitive._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointBatchPrimitive.")
        
agcls.AgClassCatalog.add_catalog_entry("{D8019323-F9C3-4238-BB4C-CD917C83E0F6}", PointBatchPrimitive)


class PointBatchPrimitiveOptionalParameters(IPointBatchPrimitiveOptionalParameters):
    """Optional per-point parameters for point batch primitive that overrides the point batch primitive's global parameters..."""
    def __init__(self, sourceObject=None):
        IPointBatchPrimitiveOptionalParameters.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointBatchPrimitiveOptionalParameters._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointBatchPrimitiveOptionalParameters._get_property(self, attrname) is not None: found_prop = IPointBatchPrimitiveOptionalParameters._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointBatchPrimitiveOptionalParameters.")
        
agcls.AgClassCatalog.add_catalog_entry("{944f2ade-d0e5-4896-a1e2-28b1c9e74f08}", PointBatchPrimitiveOptionalParameters)


class PolylinePrimitive(IPolylinePrimitive, IPrimitive):
    """Renders a polyline in the 3D scene. Each line segment may have a different color. A polyline can be constructed with a position interpolator to render great arcs or rhumb lines."""
    def __init__(self, sourceObject=None):
        IPolylinePrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPolylinePrimitive._private_init(self, pUnk)
        IPrimitive._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPolylinePrimitive._get_property(self, attrname) is not None: found_prop = IPolylinePrimitive._get_property(self, attrname)
        if IPrimitive._get_property(self, attrname) is not None: found_prop = IPrimitive._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PolylinePrimitive.")
        
agcls.AgClassCatalog.add_catalog_entry("{F6E930C1-39F1-471B-A6F3-AFE651B00A95}", PolylinePrimitive)


class PolylinePrimitiveOptionalParameters(IPolylinePrimitiveOptionalParameters):
    """Optional per-point or per-segment parameters for polyline primitive that overrides the polyline primitive's global parameters..."""
    def __init__(self, sourceObject=None):
        IPolylinePrimitiveOptionalParameters.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPolylinePrimitiveOptionalParameters._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPolylinePrimitiveOptionalParameters._get_property(self, attrname) is not None: found_prop = IPolylinePrimitiveOptionalParameters._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PolylinePrimitiveOptionalParameters.")
        
agcls.AgClassCatalog.add_catalog_entry("{eee51ba6-73ae-4626-9fac-62a0f82cb3d1}", PolylinePrimitiveOptionalParameters)


class PositionInterpolator(IPositionInterpolator):
    """Position interpolators compute positions based on a collection of input positions. Position interpolators are used in conjunction with the polyline primitive to render things such as great arcs and rhumb lines."""
    def __init__(self, sourceObject=None):
        IPositionInterpolator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPositionInterpolator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPositionInterpolator._get_property(self, attrname) is not None: found_prop = IPositionInterpolator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PositionInterpolator.")
        
agcls.AgClassCatalog.add_catalog_entry("{3D14E044-4128-4F60-9F08-797AA09205B5}", PositionInterpolator)


class Primitive(IPrimitive):
    """Primitives represent objects rendered in the 3D scene."""
    def __init__(self, sourceObject=None):
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPrimitive._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPrimitive._get_property(self, attrname) is not None: found_prop = IPrimitive._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Primitive.")
        
agcls.AgClassCatalog.add_catalog_entry("{0BE64D00-03FF-41C1-8F8E-DCDB5D260FCE}", Primitive)


class PrimitiveManager(IPrimitiveManager):
    """The primitive manager contains spatial data structures used to efficiently render primitives. Once a primitive is constructed, it must be added to the primitive manager before it will be rendered."""
    def __init__(self, sourceObject=None):
        IPrimitiveManager.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPrimitiveManager._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPrimitiveManager._get_property(self, attrname) is not None: found_prop = IPrimitiveManager._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PrimitiveManager.")
        
agcls.AgClassCatalog.add_catalog_entry("{29884E1F-F498-4FED-9B83-AFC57A4BB09B}", PrimitiveManager)


class RasterImageGlobeOverlay(IRasterImageGlobeOverlay, IGlobeImageOverlay, IGlobeOverlay):
    """A globe image overlay for handling rasters."""
    def __init__(self, sourceObject=None):
        IRasterImageGlobeOverlay.__init__(self, sourceObject)
        IGlobeImageOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRasterImageGlobeOverlay._private_init(self, pUnk)
        IGlobeImageOverlay._private_init(self, pUnk)
        IGlobeOverlay._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRasterImageGlobeOverlay._get_property(self, attrname) is not None: found_prop = IRasterImageGlobeOverlay._get_property(self, attrname)
        if IGlobeImageOverlay._get_property(self, attrname) is not None: found_prop = IGlobeImageOverlay._get_property(self, attrname)
        if IGlobeOverlay._get_property(self, attrname) is not None: found_prop = IGlobeOverlay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RasterImageGlobeOverlay.")
        
agcls.AgClassCatalog.add_catalog_entry("{49EC3E96-9494-4D95-A9C2-C722C46197FC}", RasterImageGlobeOverlay)


class RhumbLineInterpolator(IRhumbLineInterpolator, IPositionInterpolator):
    """The rhumb line interpolator computes interpolated positions along a rhumb line. Rhumb lines are lines of constant bearing. They appear as straight lines on a Mercator 2D map projection and are well suited to navigation."""
    def __init__(self, sourceObject=None):
        IRhumbLineInterpolator.__init__(self, sourceObject)
        IPositionInterpolator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRhumbLineInterpolator._private_init(self, pUnk)
        IPositionInterpolator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRhumbLineInterpolator._get_property(self, attrname) is not None: found_prop = IRhumbLineInterpolator._get_property(self, attrname)
        if IPositionInterpolator._get_property(self, attrname) is not None: found_prop = IPositionInterpolator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RhumbLineInterpolator.")
        
agcls.AgClassCatalog.add_catalog_entry("{E791A602-85BA-4413-9C8D-479D1692254C}", RhumbLineInterpolator)


class Scene(IScene):
    """A scene provides properties and functionality that are reflected in the rendering of the globe control that it is associated with. An globe control's scene is available from the scene property..."""
    def __init__(self, sourceObject=None):
        IScene.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScene._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScene._get_property(self, attrname) is not None: found_prop = IScene._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Scene.")
        
agcls.AgClassCatalog.add_catalog_entry("{E664A9F1-8A89-4B4C-9AA2-E5BEB603AF3C}", Scene)


class SceneDisplayCondition(ISceneDisplayCondition, IDisplayCondition):
    """A display condition used to control what scene or scenes an object, such as a primitive, is rendered in. This is used to show an object in some scenes and hide it in others."""
    def __init__(self, sourceObject=None):
        ISceneDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISceneDisplayCondition._private_init(self, pUnk)
        IDisplayCondition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISceneDisplayCondition._get_property(self, attrname) is not None: found_prop = ISceneDisplayCondition._get_property(self, attrname)
        if IDisplayCondition._get_property(self, attrname) is not None: found_prop = IDisplayCondition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SceneDisplayCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{8074B463-1740-4C65-870C-E231589EE5CE}", SceneDisplayCondition)


class SceneManager(ISceneManager):
    """The static scene manager class provides global properties and functionality that apply to all scenes and thus affect the rendering of every globe control..."""
    def __init__(self, sourceObject=None):
        ISceneManager.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISceneManager._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISceneManager._get_property(self, attrname) is not None: found_prop = ISceneManager._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SceneManager.")
        
agcls.AgClassCatalog.add_catalog_entry("{B671433F-CA75-4628-B84D-4878A247AFC3}", SceneManager)


class ScreenOverlay(IScreenOverlay, IOverlay, IScreenOverlayContainer):
    """A visible element drawn in screen space. Overlays are useful for floating logos, heads up displays, and integrating user interfaces into the 3D window."""
    def __init__(self, sourceObject=None):
        IScreenOverlay.__init__(self, sourceObject)
        IOverlay.__init__(self, sourceObject)
        IScreenOverlayContainer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScreenOverlay._private_init(self, pUnk)
        IOverlay._private_init(self, pUnk)
        IScreenOverlayContainer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScreenOverlay._get_property(self, attrname) is not None: found_prop = IScreenOverlay._get_property(self, attrname)
        if IOverlay._get_property(self, attrname) is not None: found_prop = IOverlay._get_property(self, attrname)
        if IScreenOverlayContainer._get_property(self, attrname) is not None: found_prop = IScreenOverlayContainer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScreenOverlay.")
        
agcls.AgClassCatalog.add_catalog_entry("{B50A73BA-5299-4746-B30B-EEB80699546E}", ScreenOverlay)


class ScreenOverlayCollection(IScreenOverlayCollection, IScreenOverlayCollectionBase):
    """A collection of screen overlays."""
    def __init__(self, sourceObject=None):
        IScreenOverlayCollection.__init__(self, sourceObject)
        IScreenOverlayCollectionBase.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScreenOverlayCollection._private_init(self, pUnk)
        IScreenOverlayCollectionBase._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScreenOverlayCollection._get_property(self, attrname) is not None: found_prop = IScreenOverlayCollection._get_property(self, attrname)
        if IScreenOverlayCollectionBase._get_property(self, attrname) is not None: found_prop = IScreenOverlayCollectionBase._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScreenOverlayCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{F75B7693-A40E-4B54-AB6F-EE8F974D2E6C}", ScreenOverlayCollection)


class ScreenOverlayManager(IScreenOverlayManager, IScreenOverlayCollectionBase, IScreenOverlayContainer):
    """The top-level container for screen overlays. All child screen overlays that are added to this container are specified relative to the overall globe control."""
    def __init__(self, sourceObject=None):
        IScreenOverlayManager.__init__(self, sourceObject)
        IScreenOverlayCollectionBase.__init__(self, sourceObject)
        IScreenOverlayContainer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScreenOverlayManager._private_init(self, pUnk)
        IScreenOverlayCollectionBase._private_init(self, pUnk)
        IScreenOverlayContainer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScreenOverlayManager._get_property(self, attrname) is not None: found_prop = IScreenOverlayManager._get_property(self, attrname)
        if IScreenOverlayCollectionBase._get_property(self, attrname) is not None: found_prop = IScreenOverlayCollectionBase._get_property(self, attrname)
        if IScreenOverlayContainer._get_property(self, attrname) is not None: found_prop = IScreenOverlayContainer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScreenOverlayManager.")
        
agcls.AgClassCatalog.add_catalog_entry("{9853EC1E-531C-4494-B308-BC6644CF672C}", ScreenOverlayManager)


class ScreenOverlayPickResult(IScreenOverlayPickResult):
    """Describes a picked screen overlay as a result of a call to pick screen overlays."""
    def __init__(self, sourceObject=None):
        IScreenOverlayPickResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScreenOverlayPickResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScreenOverlayPickResult._get_property(self, attrname) is not None: found_prop = IScreenOverlayPickResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScreenOverlayPickResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{6E7F318E-F7E5-4B19-A532-50EC60EF09FA}", ScreenOverlayPickResult)


class SolidPrimitive(ISolidPrimitive, IPrimitive):
    """Renders filled solid objects and their outlines. Example solids include boxes and ellipsoids. Various effects are supported, such as displaying the solid's silhouette, and hiding the outline of the backside of the solid..."""
    def __init__(self, sourceObject=None):
        ISolidPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISolidPrimitive._private_init(self, pUnk)
        IPrimitive._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISolidPrimitive._get_property(self, attrname) is not None: found_prop = ISolidPrimitive._get_property(self, attrname)
        if IPrimitive._get_property(self, attrname) is not None: found_prop = IPrimitive._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SolidPrimitive.")
        
agcls.AgClassCatalog.add_catalog_entry("{12343DC0-99FF-48B6-9D93-9B7A2CE34DB9}", SolidPrimitive)


class Stereoscopic(IStereoscopic):
    """Gets the stereoscopic options for all Scenes. To use a particular stereoscopic display mode, ensure that your system supports the feature and that it is enabled."""
    def __init__(self, sourceObject=None):
        IStereoscopic.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStereoscopic._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStereoscopic._get_property(self, attrname) is not None: found_prop = IStereoscopic._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Stereoscopic.")
        
agcls.AgClassCatalog.add_catalog_entry("{5FDA997C-0450-4574-BFD9-D803A3AA6167}", Stereoscopic)


class SurfaceMeshPrimitive(ISurfaceMeshPrimitive, IPrimitive):
    """A triangle mesh primitive for meshes on the surface that need to conform to terrain."""
    def __init__(self, sourceObject=None):
        ISurfaceMeshPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISurfaceMeshPrimitive._private_init(self, pUnk)
        IPrimitive._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISurfaceMeshPrimitive._get_property(self, attrname) is not None: found_prop = ISurfaceMeshPrimitive._get_property(self, attrname)
        if IPrimitive._get_property(self, attrname) is not None: found_prop = IPrimitive._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SurfaceMeshPrimitive.")
        
agcls.AgClassCatalog.add_catalog_entry("{C4B2DB74-EBA8-4B18-8BE4-372FCA665F5D}", SurfaceMeshPrimitive)


class TerrainOverlayCollection(ITerrainOverlayCollection):
    """A collection of terrain overlay objects."""
    def __init__(self, sourceObject=None):
        ITerrainOverlayCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITerrainOverlayCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITerrainOverlayCollection._get_property(self, attrname) is not None: found_prop = ITerrainOverlayCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TerrainOverlayCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{168D1247-7208-45C3-AF31-7E4009DE2EA7}", TerrainOverlayCollection)


class TerrainOverlay(ITerrainOverlay, IGlobeOverlay):
    """A globe overlay which shows terrain."""
    def __init__(self, sourceObject=None):
        ITerrainOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITerrainOverlay._private_init(self, pUnk)
        IGlobeOverlay._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITerrainOverlay._get_property(self, attrname) is not None: found_prop = ITerrainOverlay._get_property(self, attrname)
        if IGlobeOverlay._get_property(self, attrname) is not None: found_prop = IGlobeOverlay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TerrainOverlay.")
        
agcls.AgClassCatalog.add_catalog_entry("{C1640FF1-07BB-4584-940C-50BDD48CFE14}", TerrainOverlay)


class TextBatchPrimitive(ITextBatchPrimitive, IPrimitive):
    """ Renders one or more strings in the 3D scene.  For best performance, avoid creating lots of batches with only a few strings each. See the Batching Performance Overview. """
    def __init__(self, sourceObject=None):
        ITextBatchPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITextBatchPrimitive._private_init(self, pUnk)
        IPrimitive._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITextBatchPrimitive._get_property(self, attrname) is not None: found_prop = ITextBatchPrimitive._get_property(self, attrname)
        if IPrimitive._get_property(self, attrname) is not None: found_prop = IPrimitive._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TextBatchPrimitive.")
        
agcls.AgClassCatalog.add_catalog_entry("{EEE49615-F2F3-4810-B877-4C7729F56DD1}", TextBatchPrimitive)


class TextBatchPrimitiveOptionalParameters(ITextBatchPrimitiveOptionalParameters):
    """Optional per-string and per-batch parameters for text batch primitive..."""
    def __init__(self, sourceObject=None):
        ITextBatchPrimitiveOptionalParameters.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITextBatchPrimitiveOptionalParameters._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITextBatchPrimitiveOptionalParameters._get_property(self, attrname) is not None: found_prop = ITextBatchPrimitiveOptionalParameters._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TextBatchPrimitiveOptionalParameters.")
        
agcls.AgClassCatalog.add_catalog_entry("{D68422E0-31FC-4E61-9A7C-6E4BCB261A9D}", TextBatchPrimitiveOptionalParameters)


class TextOverlay(ITextOverlay, IScreenOverlay, IOverlay, IScreenOverlayContainer):
    """A rectangular overlay that contains text."""
    def __init__(self, sourceObject=None):
        ITextOverlay.__init__(self, sourceObject)
        IScreenOverlay.__init__(self, sourceObject)
        IOverlay.__init__(self, sourceObject)
        IScreenOverlayContainer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITextOverlay._private_init(self, pUnk)
        IScreenOverlay._private_init(self, pUnk)
        IOverlay._private_init(self, pUnk)
        IScreenOverlayContainer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITextOverlay._get_property(self, attrname) is not None: found_prop = ITextOverlay._get_property(self, attrname)
        if IScreenOverlay._get_property(self, attrname) is not None: found_prop = IScreenOverlay._get_property(self, attrname)
        if IOverlay._get_property(self, attrname) is not None: found_prop = IOverlay._get_property(self, attrname)
        if IScreenOverlayContainer._get_property(self, attrname) is not None: found_prop = IScreenOverlayContainer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TextOverlay.")
        
agcls.AgClassCatalog.add_catalog_entry("{46BE31F3-1A5B-4B51-AA77-27CCA844F5CD}", TextOverlay)


class TextureMatrix(ITextureMatrix):
    """A 4 by 4 matrix applied to a texture coordinate."""
    def __init__(self, sourceObject=None):
        ITextureMatrix.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITextureMatrix._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITextureMatrix._get_property(self, attrname) is not None: found_prop = ITextureMatrix._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TextureMatrix.")
        
agcls.AgClassCatalog.add_catalog_entry("{E05D3E06-18C5-49DE-B9AC-B2245C83E62B}", TextureMatrix)


class TextureScreenOverlay(ITextureScreenOverlay, IScreenOverlay, IOverlay, IScreenOverlayContainer):
    """A rectangular overlay that can be assigned a texture."""
    def __init__(self, sourceObject=None):
        ITextureScreenOverlay.__init__(self, sourceObject)
        IScreenOverlay.__init__(self, sourceObject)
        IOverlay.__init__(self, sourceObject)
        IScreenOverlayContainer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITextureScreenOverlay._private_init(self, pUnk)
        IScreenOverlay._private_init(self, pUnk)
        IOverlay._private_init(self, pUnk)
        IScreenOverlayContainer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITextureScreenOverlay._get_property(self, attrname) is not None: found_prop = ITextureScreenOverlay._get_property(self, attrname)
        if IScreenOverlay._get_property(self, attrname) is not None: found_prop = IScreenOverlay._get_property(self, attrname)
        if IOverlay._get_property(self, attrname) is not None: found_prop = IOverlay._get_property(self, attrname)
        if IScreenOverlayContainer._get_property(self, attrname) is not None: found_prop = IScreenOverlayContainer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TextureScreenOverlay.")
        
agcls.AgClassCatalog.add_catalog_entry("{51136098-508C-4DD3-B39C-D342235E58BD}", TextureScreenOverlay)


class TimeIntervalDisplayCondition(ITimeIntervalDisplayCondition, IDisplayCondition):
    """Defines an inclusive time interval that determines when an object, such as a primitive, is rendered based on the current animation time ."""
    def __init__(self, sourceObject=None):
        ITimeIntervalDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeIntervalDisplayCondition._private_init(self, pUnk)
        IDisplayCondition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeIntervalDisplayCondition._get_property(self, attrname) is not None: found_prop = ITimeIntervalDisplayCondition._get_property(self, attrname)
        if IDisplayCondition._get_property(self, attrname) is not None: found_prop = IDisplayCondition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeIntervalDisplayCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{256AACC3-3E56-4BA6-80F9-15BD968C3863}", TimeIntervalDisplayCondition)


class TriangleMeshPrimitive(ITriangleMeshPrimitive, IPrimitive):
    """Renders a triangle mesh in the 3D scene. Examples of triangle meshes includes polygons on the globe (e.g. states or countries), terrain and imagery extents, ellipses, and extrusions."""
    def __init__(self, sourceObject=None):
        ITriangleMeshPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITriangleMeshPrimitive._private_init(self, pUnk)
        IPrimitive._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITriangleMeshPrimitive._get_property(self, attrname) is not None: found_prop = ITriangleMeshPrimitive._get_property(self, attrname)
        if IPrimitive._get_property(self, attrname) is not None: found_prop = IPrimitive._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TriangleMeshPrimitive.")
        
agcls.AgClassCatalog.add_catalog_entry("{DA3D4743-D0D9-49B8-8037-3DDC3075170E}", TriangleMeshPrimitive)


class TriangleMeshPrimitiveOptionalParameters(ITriangleMeshPrimitiveOptionalParameters):
    """Optional parameters for triangle mesh primitive..."""
    def __init__(self, sourceObject=None):
        ITriangleMeshPrimitiveOptionalParameters.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITriangleMeshPrimitiveOptionalParameters._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITriangleMeshPrimitiveOptionalParameters._get_property(self, attrname) is not None: found_prop = ITriangleMeshPrimitiveOptionalParameters._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TriangleMeshPrimitiveOptionalParameters.")
        
agcls.AgClassCatalog.add_catalog_entry("{07985409-9BA1-406C-8A91-D4E99DDB406F}", TriangleMeshPrimitiveOptionalParameters)


class VectorPrimitive(IVectorPrimitive, IPrimitive):
    """Renders a vector in the 3D scene. A vector is defined by a source (given by an ISystem) and a direction (given by an IVector or IPoint). Length is auto-calculated or can be set separately."""
    def __init__(self, sourceObject=None):
        IVectorPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorPrimitive._private_init(self, pUnk)
        IPrimitive._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorPrimitive._get_property(self, attrname) is not None: found_prop = IVectorPrimitive._get_property(self, attrname)
        if IPrimitive._get_property(self, attrname) is not None: found_prop = IPrimitive._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorPrimitive.")
        
agcls.AgClassCatalog.add_catalog_entry("{8DE433D5-0E13-44ED-B3CF-DF380B8BEA7D}", VectorPrimitive)


class BoxTriangulatorInitializer(IBoxTriangulatorInitializer):
    """Triangulates a box. It is recommended to visualize the box using a solid primitive. Although, if only the fill is desired for visualization, a triangle mesh primitive with render back then front faces set to true can be used..."""
    def __init__(self, sourceObject=None):
        IBoxTriangulatorInitializer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBoxTriangulatorInitializer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBoxTriangulatorInitializer._get_property(self, attrname) is not None: found_prop = IBoxTriangulatorInitializer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BoxTriangulatorInitializer.")
        
agcls.AgClassCatalog.add_catalog_entry("{F5AA6E13-2989-46FD-8BA7-341870EE56CB}", BoxTriangulatorInitializer)


class CylinderTriangulatorInitializer(ICylinderTriangulatorInitializer):
    """Triangulates a cylinder. It is recommended to visualize the cylinder using a solid primitive. Although, if only the fill is desired for visualization, a triangle mesh primitive with render back then front faces set to true can be used..."""
    def __init__(self, sourceObject=None):
        ICylinderTriangulatorInitializer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICylinderTriangulatorInitializer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICylinderTriangulatorInitializer._get_property(self, attrname) is not None: found_prop = ICylinderTriangulatorInitializer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CylinderTriangulatorInitializer.")
        
agcls.AgClassCatalog.add_catalog_entry("{351F63E3-5430-4B7C-8811-1353D7FDBA79}", CylinderTriangulatorInitializer)


class EllipsoidTriangulatorInitializer(IEllipsoidTriangulatorInitializer):
    """Triangulates an ellipsoid. It is recommended to visualize the ellipsoid using a solid primitive. Although, if only the fill is desired for visualization, a triangle mesh primitive with render back then front faces set to true can be used..."""
    def __init__(self, sourceObject=None):
        IEllipsoidTriangulatorInitializer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEllipsoidTriangulatorInitializer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEllipsoidTriangulatorInitializer._get_property(self, attrname) is not None: found_prop = IEllipsoidTriangulatorInitializer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EllipsoidTriangulatorInitializer.")
        
agcls.AgClassCatalog.add_catalog_entry("{DEBC2954-C0E9-4562-8AD6-A93E7EDD3E82}", EllipsoidTriangulatorInitializer)


class ExtrudedPolylineTriangulatorInitializer(IExtrudedPolylineTriangulatorInitializer):
    """Triangulates a polyline into an extrusion with bottom and top boundaries."""
    def __init__(self, sourceObject=None):
        IExtrudedPolylineTriangulatorInitializer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IExtrudedPolylineTriangulatorInitializer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IExtrudedPolylineTriangulatorInitializer._get_property(self, attrname) is not None: found_prop = IExtrudedPolylineTriangulatorInitializer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ExtrudedPolylineTriangulatorInitializer.")
        
agcls.AgClassCatalog.add_catalog_entry("{9DD61791-420A-401D-8C10-251999CA274B}", ExtrudedPolylineTriangulatorInitializer)


class SurfaceExtentTriangulatorInitializer(ISurfaceExtentTriangulatorInitializer):
    """Triangulates an extent on a central body into a triangle mesh and a surrounding boundary. The mesh is commonly visualized with the triangle mesh primitive or surface mesh primitive. The boundary is commonly visualized with the polyline primitive."""
    def __init__(self, sourceObject=None):
        ISurfaceExtentTriangulatorInitializer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISurfaceExtentTriangulatorInitializer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISurfaceExtentTriangulatorInitializer._get_property(self, attrname) is not None: found_prop = ISurfaceExtentTriangulatorInitializer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SurfaceExtentTriangulatorInitializer.")
        
agcls.AgClassCatalog.add_catalog_entry("{F86CAF5F-4B95-4CD0-9E8A-7C04AF8B7E9B}", SurfaceExtentTriangulatorInitializer)


class SurfacePolygonTriangulatorInitializer(ISurfacePolygonTriangulatorInitializer):
    """Triangulates a polygon, with an optional hole, on a central body, into a triangle mesh and a surrounding boundary. The mesh is commonly visualized with the triangle mesh primitive or surface mesh primitive..."""
    def __init__(self, sourceObject=None):
        ISurfacePolygonTriangulatorInitializer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISurfacePolygonTriangulatorInitializer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISurfacePolygonTriangulatorInitializer._get_property(self, attrname) is not None: found_prop = ISurfacePolygonTriangulatorInitializer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SurfacePolygonTriangulatorInitializer.")
        
agcls.AgClassCatalog.add_catalog_entry("{FB4D2919-C9DB-4C93-A64B-35A9EB884E6B}", SurfacePolygonTriangulatorInitializer)


class SurfaceShapesInitializer(ISurfaceShapesInitializer):
    """Computes boundary positions for shapes on the surface such as circles, ellipses, and sectors."""
    def __init__(self, sourceObject=None):
        ISurfaceShapesInitializer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISurfaceShapesInitializer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISurfaceShapesInitializer._get_property(self, attrname) is not None: found_prop = ISurfaceShapesInitializer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SurfaceShapesInitializer.")
        
agcls.AgClassCatalog.add_catalog_entry("{2B227F07-5BB0-43E5-9AE2-7288A73856BC}", SurfaceShapesInitializer)


class AGICustomTerrainOverlayFactory(IAGICustomTerrainOverlayFactory):
    """A terrain overlay for handling AGI Cesium Terrain."""
    def __init__(self, sourceObject=None):
        IAGICustomTerrainOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAGICustomTerrainOverlayFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAGICustomTerrainOverlayFactory._get_property(self, attrname) is not None: found_prop = IAGICustomTerrainOverlayFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AGICustomTerrainOverlayFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{3B6233AF-5A82-45AB-8371-0C1430585060}", AGICustomTerrainOverlayFactory)


class AGIProcessedImageGlobeOverlayFactory(IAGIProcessedImageGlobeOverlayFactory):
    """A globe image overlay for handling AGI Processed Image (PDTTX) files."""
    def __init__(self, sourceObject=None):
        IAGIProcessedImageGlobeOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAGIProcessedImageGlobeOverlayFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAGIProcessedImageGlobeOverlayFactory._get_property(self, attrname) is not None: found_prop = IAGIProcessedImageGlobeOverlayFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AGIProcessedImageGlobeOverlayFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{668251C7-6113-4243-B563-8F58F25A9281}", AGIProcessedImageGlobeOverlayFactory)


class AGIProcessedTerrainOverlayFactory(IAGIProcessedTerrainOverlayFactory):
    """A terrain overlay for handling AGI Processed Terrain (PDTT) files."""
    def __init__(self, sourceObject=None):
        IAGIProcessedTerrainOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAGIProcessedTerrainOverlayFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAGIProcessedTerrainOverlayFactory._get_property(self, attrname) is not None: found_prop = IAGIProcessedTerrainOverlayFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AGIProcessedTerrainOverlayFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{AD84EB3C-79EC-43F8-B042-0B9180B94D75}", AGIProcessedTerrainOverlayFactory)


class AGIRoamImageGlobeOverlayFactory(IAGIRoamImageGlobeOverlayFactory):
    """A globe image overlay for handling ROAM (TXM/TXB) files."""
    def __init__(self, sourceObject=None):
        IAGIRoamImageGlobeOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAGIRoamImageGlobeOverlayFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAGIRoamImageGlobeOverlayFactory._get_property(self, attrname) is not None: found_prop = IAGIRoamImageGlobeOverlayFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AGIRoamImageGlobeOverlayFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{BB6E5A38-778A-4E22-91FB-7B4E63F40D6E}", AGIRoamImageGlobeOverlayFactory)


class CustomImageGlobeOverlayPluginActivatorFactory(ICustomImageGlobeOverlayPluginActivatorFactory):
    """The Activator class provides methods to load COM plugins that implement custom image globe overlays. For more information about custom image globe overlays, see the STK Programming Interface."""
    def __init__(self, sourceObject=None):
        ICustomImageGlobeOverlayPluginActivatorFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICustomImageGlobeOverlayPluginActivatorFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICustomImageGlobeOverlayPluginActivatorFactory._get_property(self, attrname) is not None: found_prop = ICustomImageGlobeOverlayPluginActivatorFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CustomImageGlobeOverlayPluginActivatorFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{2B0D7F25-8A54-40C5-BD10-75EB00788704}", CustomImageGlobeOverlayPluginActivatorFactory)


class GeospatialImageGlobeOverlayFactory(IGeospatialImageGlobeOverlayFactory):
    """A globe image overlay for handling `JPEG 2000 <https://jpeg.org/jpeg2000/>`_ (.jp2), ECW (.ecw), ECWP, and MrSid (.sid) image formats in the WGS84 geographic projection."""
    def __init__(self, sourceObject=None):
        IGeospatialImageGlobeOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGeospatialImageGlobeOverlayFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGeospatialImageGlobeOverlayFactory._get_property(self, attrname) is not None: found_prop = IGeospatialImageGlobeOverlayFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GeospatialImageGlobeOverlayFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{636E2A9D-49B9-4673-8BD5-4DF7E06A696E}", GeospatialImageGlobeOverlayFactory)


class ProjectedRasterOverlayFactory(IProjectedRasterOverlayFactory):
    """A globe image overlay which projects a raster onto the terrain or surface of the central body. You can also enable projection onto models by setting projected raster model projection to true for a Scene..."""
    def __init__(self, sourceObject=None):
        IProjectedRasterOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProjectedRasterOverlayFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProjectedRasterOverlayFactory._get_property(self, attrname) is not None: found_prop = IProjectedRasterOverlayFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProjectedRasterOverlayFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{FDAAFAF9-B61B-4DB8-8157-96EF4D476457}", ProjectedRasterOverlayFactory)


class ProjectionFactory(IProjectionFactory):
    """A projection represents a simplified camera with a position, orientation, and field of view horizontal and field of view vertical..."""
    def __init__(self, sourceObject=None):
        IProjectionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProjectionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProjectionFactory._get_property(self, attrname) is not None: found_prop = IProjectionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProjectionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{C22AAF01-98CE-41E1-8A98-E164A61D40CC}", ProjectionFactory)


class AltitudeDisplayConditionFactory(IAltitudeDisplayConditionFactory):
    """Defines an inclusive altitude interval that determines when an object is rendered based on the camera's altitude relative to a central body."""
    def __init__(self, sourceObject=None):
        IAltitudeDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAltitudeDisplayConditionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAltitudeDisplayConditionFactory._get_property(self, attrname) is not None: found_prop = IAltitudeDisplayConditionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AltitudeDisplayConditionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{75D5CF9A-FBCE-482C-9520-7811D9E71EC1}", AltitudeDisplayConditionFactory)


class AxesPrimitiveFactory(IAxesPrimitiveFactory):
    """Renders an axes in the 3D scene."""
    def __init__(self, sourceObject=None):
        IAxesPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesPrimitiveFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesPrimitiveFactory._get_property(self, attrname) is not None: found_prop = IAxesPrimitiveFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesPrimitiveFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{166D78CD-1000-4EDC-B031-AAB1B1B45E8D}", AxesPrimitiveFactory)


class CompositeDisplayConditionFactory(ICompositeDisplayConditionFactory):
    """A composite of display conditions combined using a binary logic operation. For example, several time interval display condition objects can be added to a composite..."""
    def __init__(self, sourceObject=None):
        ICompositeDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICompositeDisplayConditionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICompositeDisplayConditionFactory._get_property(self, attrname) is not None: found_prop = ICompositeDisplayConditionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CompositeDisplayConditionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{375A535B-557C-4E7B-A2AD-0905381BA46F}", CompositeDisplayConditionFactory)


class CompositePrimitiveFactory(ICompositePrimitiveFactory):
    """ A primitive that is composed of multiple other primitives. Since composites can contain other composites, they are commonly used to build hierarchies of primitives to efficiently evaluate display conditions..."""
    def __init__(self, sourceObject=None):
        ICompositePrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICompositePrimitiveFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICompositePrimitiveFactory._get_property(self, attrname) is not None: found_prop = ICompositePrimitiveFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CompositePrimitiveFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{7F9D1191-7973-4B59-B2E6-9A4D4F19A222}", CompositePrimitiveFactory)


class ConstantDisplayConditionFactory(IConstantDisplayConditionFactory):
    """A display condition that evaluates to a user-defined value. This is commonly used to hide primitives by assigning to a primitive a display condition that always returns false."""
    def __init__(self, sourceObject=None):
        IConstantDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConstantDisplayConditionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConstantDisplayConditionFactory._get_property(self, attrname) is not None: found_prop = IConstantDisplayConditionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConstantDisplayConditionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{84B6B505-833D-4A3B-BD6B-99266C8C5284}", ConstantDisplayConditionFactory)


class DistanceDisplayConditionFactory(IDistanceDisplayConditionFactory):
    """Defines an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the object."""
    def __init__(self, sourceObject=None):
        IDistanceDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDistanceDisplayConditionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDistanceDisplayConditionFactory._get_property(self, attrname) is not None: found_prop = IDistanceDisplayConditionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DistanceDisplayConditionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{F8A027DC-AE3B-464A-A5C4-39AA37368ED7}", DistanceDisplayConditionFactory)


class DistanceToGlobeOverlayDisplayConditionFactory(IDistanceToGlobeOverlayDisplayConditionFactory):
    """Defines an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the globe overlay..."""
    def __init__(self, sourceObject=None):
        IDistanceToGlobeOverlayDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDistanceToGlobeOverlayDisplayConditionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDistanceToGlobeOverlayDisplayConditionFactory._get_property(self, attrname) is not None: found_prop = IDistanceToGlobeOverlayDisplayConditionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DistanceToGlobeOverlayDisplayConditionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{0BF7DA00-8B06-41FA-A580-15D898A0837F}", DistanceToGlobeOverlayDisplayConditionFactory)


class DistanceToPositionDisplayConditionFactory(IDistanceToPositionDisplayConditionFactory):
    """Defines an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to a position defined in the given reference frame."""
    def __init__(self, sourceObject=None):
        IDistanceToPositionDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDistanceToPositionDisplayConditionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDistanceToPositionDisplayConditionFactory._get_property(self, attrname) is not None: found_prop = IDistanceToPositionDisplayConditionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DistanceToPositionDisplayConditionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{F19A2CB9-BF83-4F3F-9B76-82794467A872}", DistanceToPositionDisplayConditionFactory)


class DistanceToPrimitiveDisplayConditionFactory(IDistanceToPrimitiveDisplayConditionFactory):
    """Defines an inclusive distance interval that determines when an object, such as a screen overlay, is rendered based on the distance from the camera to the primitive..."""
    def __init__(self, sourceObject=None):
        IDistanceToPrimitiveDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDistanceToPrimitiveDisplayConditionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDistanceToPrimitiveDisplayConditionFactory._get_property(self, attrname) is not None: found_prop = IDistanceToPrimitiveDisplayConditionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DistanceToPrimitiveDisplayConditionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{8D977F6C-359B-4353-AD7A-B1317BE7136E}", DistanceToPrimitiveDisplayConditionFactory)


class DurationPathPrimitiveUpdatePolicyFactory(IDurationPathPrimitiveUpdatePolicyFactory):
    """path primitive update policy that removes points from remove location after a given duration."""
    def __init__(self, sourceObject=None):
        IDurationPathPrimitiveUpdatePolicyFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDurationPathPrimitiveUpdatePolicyFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDurationPathPrimitiveUpdatePolicyFactory._get_property(self, attrname) is not None: found_prop = IDurationPathPrimitiveUpdatePolicyFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DurationPathPrimitiveUpdatePolicyFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{D10A5794-C75B-43DA-8277-FAA18D9C988A}", DurationPathPrimitiveUpdatePolicyFactory)


class GlobeImageOverlayInitializer(IGlobeImageOverlayInitializer):
    """A globe overlay that shows an image."""
    def __init__(self, sourceObject=None):
        IGlobeImageOverlayInitializer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGlobeImageOverlayInitializer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGlobeImageOverlayInitializer._get_property(self, attrname) is not None: found_prop = IGlobeImageOverlayInitializer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GlobeImageOverlayInitializer.")
        
agcls.AgClassCatalog.add_catalog_entry("{6CA56657-186B-4768-B747-AB0071E02C05}", GlobeImageOverlayInitializer)


class GraphicsFontFactory(IGraphicsFontFactory):
    """A font that is suitable for use with the text batch primitive. For best performance, avoid creating duplicate font objects. Instead assign the same font object to several text batch primitives."""
    def __init__(self, sourceObject=None):
        IGraphicsFontFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGraphicsFontFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGraphicsFontFactory._get_property(self, attrname) is not None: found_prop = IGraphicsFontFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GraphicsFontFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{4890C7DD-6EAC-4F44-94DB-A72E75BEDAF0}", GraphicsFontFactory)


class GreatArcInterpolatorFactory(IGreatArcInterpolatorFactory):
    """The great arc interpolator computes interpolated positions along a great arc. A great arc is the shortest path between two positions on an ellipsoid."""
    def __init__(self, sourceObject=None):
        IGreatArcInterpolatorFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGreatArcInterpolatorFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGreatArcInterpolatorFactory._get_property(self, attrname) is not None: found_prop = IGreatArcInterpolatorFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GreatArcInterpolatorFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{6882FDC8-B958-498D-A274-46AE40AE78D5}", GreatArcInterpolatorFactory)


class AlphaFromLuminanceFilterFactory(IAlphaFromLuminanceFilterFactory):
    """Adds an alpha band to the source raster derived from the luminance of the raster's color bands."""
    def __init__(self, sourceObject=None):
        IAlphaFromLuminanceFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAlphaFromLuminanceFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAlphaFromLuminanceFilterFactory._get_property(self, attrname) is not None: found_prop = IAlphaFromLuminanceFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AlphaFromLuminanceFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{1190FF7A-66F4-4B54-B35B-57BBBEDD35AA}", AlphaFromLuminanceFilterFactory)


class AlphaFromPixelFilterFactory(IAlphaFromPixelFilterFactory):
    """Adds an alpha band to the source raster based on the value of its first pixel. All pixels in the source raster that are the same color as the first pixel will be made transparent."""
    def __init__(self, sourceObject=None):
        IAlphaFromPixelFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAlphaFromPixelFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAlphaFromPixelFilterFactory._get_property(self, attrname) is not None: found_prop = IAlphaFromPixelFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AlphaFromPixelFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{72AEEA38-C86F-48DE-A8D7-F993011E6466}", AlphaFromPixelFilterFactory)


class AlphaFromRasterFilterFactory(IAlphaFromRasterFilterFactory):
    """Adds an alpha band to the source raster derived from the color bands or alpha of another raster. This filter can be used to apply an alpha mask to the source raster."""
    def __init__(self, sourceObject=None):
        IAlphaFromRasterFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAlphaFromRasterFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAlphaFromRasterFilterFactory._get_property(self, attrname) is not None: found_prop = IAlphaFromRasterFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AlphaFromRasterFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{F578725F-3B1F-4B45-AA36-FADF0AA5516F}", AlphaFromRasterFilterFactory)


class BandExtractFilterFactory(IBandExtractFilterFactory):
    """Extracts a band or set of bands from the source raster. The extract format property specifies the bands and the order of the bands that will be extracted."""
    def __init__(self, sourceObject=None):
        IBandExtractFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBandExtractFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBandExtractFilterFactory._get_property(self, attrname) is not None: found_prop = IBandExtractFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BandExtractFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{52C5D954-F113-46CA-BF7C-3BFCA6637B6D}", BandExtractFilterFactory)


class BandOrderFilterFactory(IBandOrderFilterFactory):
    """Reorders or swizzles the bands of the source raster to match the band order of the raster format specified by the band order property. When maintain raster format is true, the source raster's format is maintained after swizzling."""
    def __init__(self, sourceObject=None):
        IBandOrderFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBandOrderFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBandOrderFilterFactory._get_property(self, attrname) is not None: found_prop = IBandOrderFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BandOrderFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{F238EFB7-84AC-4648-AB58-42C01DADA9A9}", BandOrderFilterFactory)


class BlurFilterFactory(IBlurFilterFactory):
    """Applies a convolution filter to blur or smooth the source raster. Can be used to reduce noise in the raster."""
    def __init__(self, sourceObject=None):
        IBlurFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBlurFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBlurFilterFactory._get_property(self, attrname) is not None: found_prop = IBlurFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BlurFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{8FE6B4C1-2607-4213-A2C6-EBD012D3A51F}", BlurFilterFactory)


class BrightnessFilterFactory(IBrightnessFilterFactory):
    """Adjusts the brightness of the source raster's color bands. The adjustment to brightness is a value between -1 and 1, corresponding to least bright to most bright."""
    def __init__(self, sourceObject=None):
        IBrightnessFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBrightnessFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBrightnessFilterFactory._get_property(self, attrname) is not None: found_prop = IBrightnessFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BrightnessFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{C03BF579-ED2C-480E-835C-A2F17B7B1E02}", BrightnessFilterFactory)


class ColorToLuminanceFilterFactory(IColorToLuminanceFilterFactory):
    """Extracts a luminance band derived from the color bands of the source raster."""
    def __init__(self, sourceObject=None):
        IColorToLuminanceFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IColorToLuminanceFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IColorToLuminanceFilterFactory._get_property(self, attrname) is not None: found_prop = IColorToLuminanceFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ColorToLuminanceFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{7311B5AA-FC01-4B35-A1A3-76DE69555938}", ColorToLuminanceFilterFactory)


class ContrastFilterFactory(IContrastFilterFactory):
    """Adjusts the contrast of the source raster. The adjustment to contrast is a value between -1 and 1, corresponding to least contrast to most contrast."""
    def __init__(self, sourceObject=None):
        IContrastFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IContrastFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IContrastFilterFactory._get_property(self, attrname) is not None: found_prop = IContrastFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ContrastFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{9B1023F6-67C4-4DC9-8EA1-9171564EFA42}", ContrastFilterFactory)


class ConvolutionFilterFactory(IConvolutionFilterFactory):
    """Applies convolution to the source raster. Convolution is the modification of a pixel's value based on the values of its surrounding pixels. The kernel is the numerical matrix that is applied to each pixel in this process..."""
    def __init__(self, sourceObject=None):
        IConvolutionFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConvolutionFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConvolutionFilterFactory._get_property(self, attrname) is not None: found_prop = IConvolutionFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConvolutionFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{64B119DD-A78C-4815-A9DD-4D77B310D28D}", ConvolutionFilterFactory)


class EdgeDetectFilterFactory(IEdgeDetectFilterFactory):
    """Applies a convolution filter to detect edges in the source raster."""
    def __init__(self, sourceObject=None):
        IEdgeDetectFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEdgeDetectFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEdgeDetectFilterFactory._get_property(self, attrname) is not None: found_prop = IEdgeDetectFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EdgeDetectFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{E14D1269-91FA-4A83-92A7-F5117E1E9DE9}", EdgeDetectFilterFactory)


class FilteringRasterStreamFactory(IFilteringRasterStreamFactory):
    """A class decorator for applying a raster filter to each update of a raster stream. Can be used to apply filters to videos and other raster streams as they are updated."""
    def __init__(self, sourceObject=None):
        IFilteringRasterStreamFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IFilteringRasterStreamFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFilteringRasterStreamFactory._get_property(self, attrname) is not None: found_prop = IFilteringRasterStreamFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FilteringRasterStreamFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{8B9D2671-491B-4D5B-8410-B8A8ED881970}", FilteringRasterStreamFactory)


class FlipFilterFactory(IFlipFilterFactory):
    """Flips the source raster along the given flip axis."""
    def __init__(self, sourceObject=None):
        IFlipFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IFlipFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFlipFilterFactory._get_property(self, attrname) is not None: found_prop = IFlipFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FlipFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{0C012B18-9467-42CE-8EC5-E7B70012BA73}", FlipFilterFactory)


class GammaCorrectionFilterFactory(IGammaCorrectionFilterFactory):
    """Applies gamma correction to the source raster. The gamma is a value between .2 and 5. The default gamma value is 2.2."""
    def __init__(self, sourceObject=None):
        IGammaCorrectionFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGammaCorrectionFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGammaCorrectionFilterFactory._get_property(self, attrname) is not None: found_prop = IGammaCorrectionFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GammaCorrectionFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{E09D6B71-6E82-45A1-A208-B761D82266E9}", GammaCorrectionFilterFactory)


class GaussianBlurFilterFactory(IGaussianBlurFilterFactory):
    """Applies a convolution filter to blur the source raster using the Gaussian function."""
    def __init__(self, sourceObject=None):
        IGaussianBlurFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGaussianBlurFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGaussianBlurFilterFactory._get_property(self, attrname) is not None: found_prop = IGaussianBlurFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GaussianBlurFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{B98AC54E-10BB-4E81-9766-806A2F0EA8C4}", GaussianBlurFilterFactory)


class GradientDetectFilterFactory(IGradientDetectFilterFactory):
    """Applies a convolution filter to detect gradients in the source raster."""
    def __init__(self, sourceObject=None):
        IGradientDetectFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGradientDetectFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGradientDetectFilterFactory._get_property(self, attrname) is not None: found_prop = IGradientDetectFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GradientDetectFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{B88D6D7C-4807-4905-B52F-DF054A4AD186}", GradientDetectFilterFactory)


class Jpeg2000WriterInitializer(IJpeg2000WriterInitializer):
    """Converts an image, such as a BMP, to a GeoJP2 file that can be used as an image globe overlay."""
    def __init__(self, sourceObject=None):
        IJpeg2000WriterInitializer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IJpeg2000WriterInitializer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IJpeg2000WriterInitializer._get_property(self, attrname) is not None: found_prop = IJpeg2000WriterInitializer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Jpeg2000WriterInitializer.")
        
agcls.AgClassCatalog.add_catalog_entry("{0F29EA41-17E7-4252-B419-B2573C015DC6}", Jpeg2000WriterInitializer)


class LevelsFilterFactory(ILevelsFilterFactory):
    """Adjusts the band levels of the source raster linearly."""
    def __init__(self, sourceObject=None):
        ILevelsFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ILevelsFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ILevelsFilterFactory._get_property(self, attrname) is not None: found_prop = ILevelsFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LevelsFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{69CBD183-936F-480E-B0FF-4D140DDC9232}", LevelsFilterFactory)


class ProjectionRasterStreamPluginActivatorFactory(IProjectionRasterStreamPluginActivatorFactory):
    """The Activator class provides methods to load COM plugins that implement projection and raster streaming. For more information about the projection and raster plugins, see the STK Programming Interface."""
    def __init__(self, sourceObject=None):
        IProjectionRasterStreamPluginActivatorFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProjectionRasterStreamPluginActivatorFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProjectionRasterStreamPluginActivatorFactory._get_property(self, attrname) is not None: found_prop = IProjectionRasterStreamPluginActivatorFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProjectionRasterStreamPluginActivatorFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{51F36FBA-E366-4A66-A452-FEE99786ED2E}", ProjectionRasterStreamPluginActivatorFactory)


class RasterFactory(IRasterFactory):
    """A raster dataset. A raster consists of one or more bands, or sets of values, which are most commonly associated with colors when the raster represents an image..."""
    def __init__(self, sourceObject=None):
        IRasterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRasterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRasterFactory._get_property(self, attrname) is not None: found_prop = IRasterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RasterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{390E63D5-4C79-48B3-98CD-55B1983F859A}", RasterFactory)


class RasterAttributesFactory(IRasterAttributesFactory):
    """The attributes describing a raster dataset. raster attributes define the memory layout of a raster, and includes properties defining the order of each raster band that the raster contains, as specified by the raster format..."""
    def __init__(self, sourceObject=None):
        IRasterAttributesFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRasterAttributesFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRasterAttributesFactory._get_property(self, attrname) is not None: found_prop = IRasterAttributesFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RasterAttributesFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{94CA0CCD-4D74-47BD-8E5F-E2D96403DACF}", RasterAttributesFactory)


class RotateFilterFactory(IRotateFilterFactory):
    """Rotates the source raster clockwise by the specified angle."""
    def __init__(self, sourceObject=None):
        IRotateFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRotateFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRotateFilterFactory._get_property(self, attrname) is not None: found_prop = IRotateFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RotateFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{12C8E395-4E61-4484-A97D-33742C841A6D}", RotateFilterFactory)


class SequenceFilterFactory(ISequenceFilterFactory):
    """Applies a sequence of filters to the source raster in the order in which they were added. When continue on failure is set to true, subsequent filters will still be applied to the source raster even if one or more filters in the sequence cannot be applied."""
    def __init__(self, sourceObject=None):
        ISequenceFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISequenceFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISequenceFilterFactory._get_property(self, attrname) is not None: found_prop = ISequenceFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SequenceFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{4CC16FDF-B6CE-4C06-B47F-AD7812566215}", SequenceFilterFactory)


class SharpenFilterFactory(ISharpenFilterFactory):
    """Applies a convolution filter to increase the sharpness of the source raster."""
    def __init__(self, sourceObject=None):
        ISharpenFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISharpenFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISharpenFilterFactory._get_property(self, attrname) is not None: found_prop = ISharpenFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SharpenFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{98011831-2D99-4FED-AC53-DFB4090D132C}", SharpenFilterFactory)


class VideoStreamFactory(IVideoStreamFactory):
    """A raster stream that streams from a video. The video can be read from a file, or streamed from an HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""
    def __init__(self, sourceObject=None):
        IVideoStreamFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVideoStreamFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVideoStreamFactory._get_property(self, attrname) is not None: found_prop = IVideoStreamFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VideoStreamFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{A977E2D9-785B-4AB0-B01F-927486E3170B}", VideoStreamFactory)


class MarkerBatchPrimitiveFactory(IMarkerBatchPrimitiveFactory):
    """ Renders one or more markers in the 3D scene. Markers are 2D images that always face the viewer which can be sized in pixels or meters. Markers are also referred to as sprites or billboards..."""
    def __init__(self, sourceObject=None):
        IMarkerBatchPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMarkerBatchPrimitiveFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMarkerBatchPrimitiveFactory._get_property(self, attrname) is not None: found_prop = IMarkerBatchPrimitiveFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MarkerBatchPrimitiveFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{E2AC5708-26C2-469F-AE1C-C48AED18565E}", MarkerBatchPrimitiveFactory)


class MarkerBatchPrimitiveOptionalParametersFactory(IMarkerBatchPrimitiveOptionalParametersFactory):
    """Optional per-marker parameters for marker batch primitive that overrides the marker batch's per-batch parameters..."""
    def __init__(self, sourceObject=None):
        IMarkerBatchPrimitiveOptionalParametersFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMarkerBatchPrimitiveOptionalParametersFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMarkerBatchPrimitiveOptionalParametersFactory._get_property(self, attrname) is not None: found_prop = IMarkerBatchPrimitiveOptionalParametersFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MarkerBatchPrimitiveOptionalParametersFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{120D8907-DB34-481B-93B1-C61A4C5C61EF}", MarkerBatchPrimitiveOptionalParametersFactory)


class MaximumCountPathPrimitiveUpdatePolicyFactory(IMaximumCountPathPrimitiveUpdatePolicyFactory):
    """path primitive update policy that removes points from remove location when the number of points in the path exceeds maximum count."""
    def __init__(self, sourceObject=None):
        IMaximumCountPathPrimitiveUpdatePolicyFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMaximumCountPathPrimitiveUpdatePolicyFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMaximumCountPathPrimitiveUpdatePolicyFactory._get_property(self, attrname) is not None: found_prop = IMaximumCountPathPrimitiveUpdatePolicyFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MaximumCountPathPrimitiveUpdatePolicyFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{C3F59BCB-635A-4E50-B5AA-269CD0380069}", MaximumCountPathPrimitiveUpdatePolicyFactory)


class ModelPrimitiveFactory(IModelPrimitiveFactory):
    """The model primitive loads and renders `COLLADA <https://www.khronos.org/collada/>`_ (DAE) and AGI `MDL <https://support.agi.com/3d-models>`_ (MDL) models."""
    def __init__(self, sourceObject=None):
        IModelPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IModelPrimitiveFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IModelPrimitiveFactory._get_property(self, attrname) is not None: found_prop = IModelPrimitiveFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ModelPrimitiveFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{90BABAB0-7D1E-420F-B91F-46E2E5B31763}", ModelPrimitiveFactory)


class PathPrimitiveFactory(IPathPrimitiveFactory):
    """Renders a line to the 3D scene. Similar to the polyline primitive; however, the PathPrimitive was designed for the efficient addition/removal of points to/from the front or back of the line."""
    def __init__(self, sourceObject=None):
        IPathPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPathPrimitiveFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPathPrimitiveFactory._get_property(self, attrname) is not None: found_prop = IPathPrimitiveFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PathPrimitiveFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{1847AEAB-C6B6-4561-BBDB-D979A443CCF0}", PathPrimitiveFactory)


class PixelSizeDisplayConditionFactory(IPixelSizeDisplayConditionFactory):
    """Defines an inclusive interval, in pixels, that determines when an object, such as a primitive, is rendered based on the number of pixels the object's bounding sphere (or in the case of screen overlays, bounding rectangle) covers on the screen..."""
    def __init__(self, sourceObject=None):
        IPixelSizeDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPixelSizeDisplayConditionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPixelSizeDisplayConditionFactory._get_property(self, attrname) is not None: found_prop = IPixelSizeDisplayConditionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PixelSizeDisplayConditionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{52EC4EAD-B9A0-4940-BAE8-BD115805BB46}", PixelSizeDisplayConditionFactory)


class PointBatchPrimitiveFactory(IPointBatchPrimitiveFactory):
    """ Renders one or more points in the 3D scene. Each point in the batch has a unique position and an optional color. All points in the batch share the same pixel size. For best performance, avoid creating lots of batches with only a few points each..."""
    def __init__(self, sourceObject=None):
        IPointBatchPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointBatchPrimitiveFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointBatchPrimitiveFactory._get_property(self, attrname) is not None: found_prop = IPointBatchPrimitiveFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointBatchPrimitiveFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{B497A3DE-DF9F-4EFD-8CB8-2767415F4889}", PointBatchPrimitiveFactory)


class PointBatchPrimitiveOptionalParametersFactory(IPointBatchPrimitiveOptionalParametersFactory):
    """Optional per-point parameters for point batch primitive that overrides the point batch primitive's global parameters..."""
    def __init__(self, sourceObject=None):
        IPointBatchPrimitiveOptionalParametersFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointBatchPrimitiveOptionalParametersFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointBatchPrimitiveOptionalParametersFactory._get_property(self, attrname) is not None: found_prop = IPointBatchPrimitiveOptionalParametersFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointBatchPrimitiveOptionalParametersFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{aa54a6e1-f927-48b6-8a29-7b718bb0cb7b}", PointBatchPrimitiveOptionalParametersFactory)


class PolylinePrimitiveFactory(IPolylinePrimitiveFactory):
    """Renders a polyline in the 3D scene. Each line segment may have a different color. A polyline can be constructed with a position interpolator to render great arcs or rhumb lines."""
    def __init__(self, sourceObject=None):
        IPolylinePrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPolylinePrimitiveFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPolylinePrimitiveFactory._get_property(self, attrname) is not None: found_prop = IPolylinePrimitiveFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PolylinePrimitiveFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{825E24B9-F4B9-4EF4-8F98-A8BD8F7A6C4B}", PolylinePrimitiveFactory)


class PolylinePrimitiveOptionalParametersFactory(IPolylinePrimitiveOptionalParametersFactory):
    """Optional per-point or per-segment parameters for polyline primitive that overrides the polyline primitive's global parameters..."""
    def __init__(self, sourceObject=None):
        IPolylinePrimitiveOptionalParametersFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPolylinePrimitiveOptionalParametersFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPolylinePrimitiveOptionalParametersFactory._get_property(self, attrname) is not None: found_prop = IPolylinePrimitiveOptionalParametersFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PolylinePrimitiveOptionalParametersFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{2ff372bc-ad1c-4fa2-82e9-75c9b407f19c}", PolylinePrimitiveOptionalParametersFactory)


class RasterImageGlobeOverlayFactory(IRasterImageGlobeOverlayFactory):
    """A globe image overlay for handling rasters."""
    def __init__(self, sourceObject=None):
        IRasterImageGlobeOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRasterImageGlobeOverlayFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRasterImageGlobeOverlayFactory._get_property(self, attrname) is not None: found_prop = IRasterImageGlobeOverlayFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RasterImageGlobeOverlayFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{73782D85-0307-4B70-B793-2930A8880AEE}", RasterImageGlobeOverlayFactory)


class RhumbLineInterpolatorFactory(IRhumbLineInterpolatorFactory):
    """The rhumb line interpolator computes interpolated positions along a rhumb line. Rhumb lines are lines of constant bearing. They appear as straight lines on a Mercator 2D map projection and are well suited to navigation."""
    def __init__(self, sourceObject=None):
        IRhumbLineInterpolatorFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRhumbLineInterpolatorFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRhumbLineInterpolatorFactory._get_property(self, attrname) is not None: found_prop = IRhumbLineInterpolatorFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RhumbLineInterpolatorFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{0B6D54BD-A46B-4770-A936-23F247B6F038}", RhumbLineInterpolatorFactory)


class SceneDisplayConditionFactory(ISceneDisplayConditionFactory):
    """A display condition used to control what scene or scenes an object, such as a primitive, is rendered in. This is used to show an object in some scenes and hide it in others."""
    def __init__(self, sourceObject=None):
        ISceneDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISceneDisplayConditionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISceneDisplayConditionFactory._get_property(self, attrname) is not None: found_prop = ISceneDisplayConditionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SceneDisplayConditionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{19159366-8E64-467F-922B-739678DA01C2}", SceneDisplayConditionFactory)


class SceneManagerInitializer(ISceneManagerInitializer):
    """The static scene manager class provides global properties and functionality that apply to all scenes and thus affect the rendering of every globe control..."""
    def __init__(self, sourceObject=None):
        ISceneManagerInitializer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISceneManagerInitializer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISceneManagerInitializer._get_property(self, attrname) is not None: found_prop = ISceneManagerInitializer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SceneManagerInitializer.")
        
agcls.AgClassCatalog.add_catalog_entry("{956AD97D-96ED-4898-89BE-08AF68BF1EA6}", SceneManagerInitializer)


class ScreenOverlayFactory(IScreenOverlayFactory):
    """A visible element drawn in screen space. Overlays are useful for floating logos, heads up displays, and integrating user interfaces into the 3D window."""
    def __init__(self, sourceObject=None):
        IScreenOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScreenOverlayFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScreenOverlayFactory._get_property(self, attrname) is not None: found_prop = IScreenOverlayFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScreenOverlayFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{C2F5A068-E483-4CCF-819D-FBB25DC85A71}", ScreenOverlayFactory)


class SolidPrimitiveFactory(ISolidPrimitiveFactory):
    """Renders filled solid objects and their outlines. Example solids include boxes and ellipsoids. Various effects are supported, such as displaying the solid's silhouette, and hiding the outline of the backside of the solid..."""
    def __init__(self, sourceObject=None):
        ISolidPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISolidPrimitiveFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISolidPrimitiveFactory._get_property(self, attrname) is not None: found_prop = ISolidPrimitiveFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SolidPrimitiveFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{9F23AC4E-DCB0-45B1-BE07-E4BEBA9B4AFF}", SolidPrimitiveFactory)


class SurfaceMeshPrimitiveFactory(ISurfaceMeshPrimitiveFactory):
    """A triangle mesh primitive for meshes on the surface that need to conform to terrain."""
    def __init__(self, sourceObject=None):
        ISurfaceMeshPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISurfaceMeshPrimitiveFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISurfaceMeshPrimitiveFactory._get_property(self, attrname) is not None: found_prop = ISurfaceMeshPrimitiveFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SurfaceMeshPrimitiveFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{A9B40191-F8D7-46D8-B217-30C1C41E2369}", SurfaceMeshPrimitiveFactory)


class TerrainOverlayInitializer(ITerrainOverlayInitializer):
    """A globe overlay which shows terrain."""
    def __init__(self, sourceObject=None):
        ITerrainOverlayInitializer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITerrainOverlayInitializer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITerrainOverlayInitializer._get_property(self, attrname) is not None: found_prop = ITerrainOverlayInitializer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TerrainOverlayInitializer.")
        
agcls.AgClassCatalog.add_catalog_entry("{8D76F5E3-BACE-4CA4-9C4D-9F14464ACAFD}", TerrainOverlayInitializer)


class TextBatchPrimitiveFactory(ITextBatchPrimitiveFactory):
    """ Renders one or more strings in the 3D scene.  For best performance, avoid creating lots of batches with only a few strings each. See the Batching Performance Overview. """
    def __init__(self, sourceObject=None):
        ITextBatchPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITextBatchPrimitiveFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITextBatchPrimitiveFactory._get_property(self, attrname) is not None: found_prop = ITextBatchPrimitiveFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TextBatchPrimitiveFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{246D4DAA-4CD0-4E10-98C7-791A17E5A736}", TextBatchPrimitiveFactory)


class TextBatchPrimitiveOptionalParametersFactory(ITextBatchPrimitiveOptionalParametersFactory):
    """Optional per-string and per-batch parameters for text batch primitive..."""
    def __init__(self, sourceObject=None):
        ITextBatchPrimitiveOptionalParametersFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITextBatchPrimitiveOptionalParametersFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITextBatchPrimitiveOptionalParametersFactory._get_property(self, attrname) is not None: found_prop = ITextBatchPrimitiveOptionalParametersFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TextBatchPrimitiveOptionalParametersFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{A3C12306-7202-468F-B0A5-306D98A7E2BC}", TextBatchPrimitiveOptionalParametersFactory)


class TextOverlayFactory(ITextOverlayFactory):
    """A rectangular overlay that contains text."""
    def __init__(self, sourceObject=None):
        ITextOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITextOverlayFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITextOverlayFactory._get_property(self, attrname) is not None: found_prop = ITextOverlayFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TextOverlayFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{5DFA35A5-B53D-4B58-A32E-B2B2690D3104}", TextOverlayFactory)


class TextureMatrixFactory(ITextureMatrixFactory):
    """A 4 by 4 matrix applied to a texture coordinate."""
    def __init__(self, sourceObject=None):
        ITextureMatrixFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITextureMatrixFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITextureMatrixFactory._get_property(self, attrname) is not None: found_prop = ITextureMatrixFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TextureMatrixFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{0169DB20-811D-4DF6-8EDF-51C47B485D6B}", TextureMatrixFactory)


class TextureScreenOverlayFactory(ITextureScreenOverlayFactory):
    """A rectangular overlay that can be assigned a texture."""
    def __init__(self, sourceObject=None):
        ITextureScreenOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITextureScreenOverlayFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITextureScreenOverlayFactory._get_property(self, attrname) is not None: found_prop = ITextureScreenOverlayFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TextureScreenOverlayFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{C4060E65-DD40-40CE-B462-55E08E6D63AF}", TextureScreenOverlayFactory)


class TimeIntervalDisplayConditionFactory(ITimeIntervalDisplayConditionFactory):
    """Defines an inclusive time interval that determines when an object, such as a primitive, is rendered based on the current animation time ."""
    def __init__(self, sourceObject=None):
        ITimeIntervalDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeIntervalDisplayConditionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeIntervalDisplayConditionFactory._get_property(self, attrname) is not None: found_prop = ITimeIntervalDisplayConditionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeIntervalDisplayConditionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{526637D4-DD61-4B7D-BAE9-6FEF3673BF5D}", TimeIntervalDisplayConditionFactory)


class TriangleMeshPrimitiveFactory(ITriangleMeshPrimitiveFactory):
    """Renders a triangle mesh in the 3D scene. Examples of triangle meshes includes polygons on the globe (e.g. states or countries), terrain and imagery extents, ellipses, and extrusions."""
    def __init__(self, sourceObject=None):
        ITriangleMeshPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITriangleMeshPrimitiveFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITriangleMeshPrimitiveFactory._get_property(self, attrname) is not None: found_prop = ITriangleMeshPrimitiveFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TriangleMeshPrimitiveFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{D904C0D6-FEAE-4E13-9BBC-98F22CC2F0AF}", TriangleMeshPrimitiveFactory)


class TriangleMeshPrimitiveOptionalParametersFactory(ITriangleMeshPrimitiveOptionalParametersFactory):
    """Optional parameters for triangle mesh primitive..."""
    def __init__(self, sourceObject=None):
        ITriangleMeshPrimitiveOptionalParametersFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITriangleMeshPrimitiveOptionalParametersFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITriangleMeshPrimitiveOptionalParametersFactory._get_property(self, attrname) is not None: found_prop = ITriangleMeshPrimitiveOptionalParametersFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TriangleMeshPrimitiveOptionalParametersFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{9D9FB947-B9EB-4964-8FD8-6FF54D734BD8}", TriangleMeshPrimitiveOptionalParametersFactory)


class VectorPrimitiveFactory(IVectorPrimitiveFactory):
    """Renders a vector in the 3D scene. A vector is defined by a source (given by an ISystem) and a direction (given by an IVector or IPoint). Length is auto-calculated or can be set separately."""
    def __init__(self, sourceObject=None):
        IVectorPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorPrimitiveFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorPrimitiveFactory._get_property(self, attrname) is not None: found_prop = IVectorPrimitiveFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorPrimitiveFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{380CA28E-1D09-4F5B-9341-6E96BA4CACCE}", VectorPrimitiveFactory)



################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################
