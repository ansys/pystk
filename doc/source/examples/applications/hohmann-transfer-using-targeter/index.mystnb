---
jupytext:
  text_representation:
    extension: .mystnb
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.15.2
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Hohmann transfer using targeter

This example provides a practical example of how to use PySTK to solve for a Hohmann transfer problem. The the satellite presents an circular and equatorial orbit with a periapsis radius of 6700 kilometers. Its desired final orbit has an apoapsis radius of 42238 kilometers.

## What is a Hohmann transfer?

A Hohmann transfer is a fuel-efficient orbital maneuver used in spaceflight to transfer a spacecraft from one circular orbit to another circular orbit at a different altitude or around a different celestial body. It was developed by German engineer Walter Hohmann in 1925 and is often referred to as the Hohmann transfer orbit or Hohmann ellipse. This maneuver is commonly used for missions within our solar system, including transfers between planets or moons.

The transfer is typically modeled under the two-body assumption. This means that it assumes a simplified scenario where only two significant gravitational bodies are considered: the spacecraft and the central body (e.g., a planet or a moon).

## Launch a new STK instance

Start by launching a new STK instance. In this example, STKEngine is used in noGraphics mode. This means that the graphic user interface (GUI) of the product is not launched:

```{code-cell} ipython3
from ansys.stk.core.stkengine import STKEngine


stk = STKEngine.start_application(noGraphics=False)
print(f"Using {stk.version}")
```

## Create a new scenario

Start by creating a new scenario in STK by running:

```{code-cell} ipython3
root = stk.new_object_root()
root.new_scenario("HohmannTransfer")


from ansys.stk.core.stkengine.experimental.jupyterwidgets import GlobeWidget
globe_plotter = GlobeWidget(stk, 640, 480)
root.execute_command('Animate * Start Loop');
```

## Adding a satellite to the scenario

Now that a new scenario is available, add a new satellite:

```{code-cell} ipython3
from ansys.stk.core.stkobjects import STK_OBJECT_TYPE

satellite = root.current_scenario.children.new(STK_OBJECT_TYPE.SATELLITE, "Satellite")
```

Then, declare the type of propagator used for the satellite:

```{code-cell} ipython3
from ansys.stk.core.stkobjects import VEHICLE_PROPAGATOR_TYPE

satellite.set_propagator_type(VEHICLE_PROPAGATOR_TYPE.PROPAGATOR_ASTROGATOR)
```

Initialize the propagator by making sure that no previous sequence is present. Add any additional configurations for the propagator. For this example, its is requested to draw the maneuver in 3D.

```{code-cell} ipython3
satellite.propagator.main_sequence.remove_all()
satellite.propagator.options.draw_trajectory_in_3d = True
```

## Set up the initial state of the satellite

To declare the initial state of a satellite, a total of six elements are required. STK supports multiple sets of elements. List them by running:

```{code-cell} ipython3
from ansys.stk.core.stkobjects.astrogator import ELEMENT_TYPE

element_types = [element_type for element_type, _ in ELEMENT_TYPE.__members__.items()]
print(element_types)
```

The segment type is also required for specifying the initial state of the satellite. List the supported segment types by running:

```{code-cell} ipython3
from ansys.stk.core.stkobjects.astrogator import SEGMENT_TYPE

initial_state = satellite.propagator.main_sequence.insert(SEGMENT_TYPE.INITIAL_STATE, "Inner orbit", "-")
initial_state.set_element_type(ELEMENT_TYPE.KEPLERIAN)
```

Now, set at least six of the previous elements. Since the initial orbit of the satellite is a

```{code-cell} ipython3
initial_state.element.periapsis_radius_size = 6700.00
initial_state.element.eccentricity = 0.00
initial_state.element.inclination = 0.00
initial_state.element.raan = 0.00
initial_state.element.arg_of_periapsis = 0.00
initial_state.element.true_anomaly = 0.00
```

## Set up the parking orbit of the satellite

The parking orbit is the temporary orbit that the satellite follows before starting any maneuver. Modelling a parking orbit requires to create a new segment in the main sequence. This segment must be of the propagate type. The total duration of the propagation is set in this example for 7200 seconds.

```{code-cell} ipython3
inital_state_sequence = satellite.propagator.main_sequence.insert(SEGMENT_TYPE.PROPAGATE, "Transfer orbit", "-")
inital_state_sequence.stopping_conditions["Duration"].properties.trip = 7200
```

Additional configurations, like the name for this propagation and its color can also be declared in this step:

```{code-cell} ipython3
from ansys.stk.core.utilities.colors import Color, Colors


inital_state_sequence.propagator_name = "Earth point mass"
inital_state_sequence.properties.color = Colors.Blue
```

## Define the target sequence for solving transfer orbit

The target sequence is the set of steps defining the complete maneuver.

```{code-cell} ipython3
start_transfer = satellite.propagator.main_sequence.insert(SEGMENT_TYPE.TARGET_SEQUENCE, "Start transfer", "-")
```

### First impulse to transfer the satellite to the final orbit

Hohmann maneuver is an impulsive maneuver. Thus, define a maneuver of impulsive type in the target sequence:

```{code-cell} ipython3
from ansys.stk.core.stkobjects.astrogator import MANEUVER_TYPE


delta_v1 = start_transfer.segments.insert(SEGMENT_TYPE.MANEUVER, "First impulse", "-")
delta_v1.set_maneuver_type(MANEUVER_TYPE.IMPULSIVE)
```

This first impulse takes place in the direction of the velocity vector at the periapsis. For this reason, it is convenient to define the thrust impulse in the Velocity-Normal-CoNormal (VNC) frame. By selecting the VNC frame, the velocity vector is now aligned with the X-axis.

```{code-cell} ipython3
from ansys.stk.core.stkobjects.astrogator import ATTITUDE_CONTROL, CONTROL_MANEUVER, PROFILE_MODE, TARGET_SEQ_ACTION

delta_v1.maneuver.set_attitude_control_type(ATTITUDE_CONTROL.THRUST_VECTOR)
delta_v1.enable_control_parameter(CONTROL_MANEUVER.IMPULSIVE_CARTESIAN_X)
delta_v1.results.add('Keplerian Elems/Radius of Apoapsis');
```

Now, configure the solver for this target sequence. A differential corrector can be used to solve for the desired final radius at apoapsis. Retrieve the differential corrector for the target sequence:

```{code-cell} ipython3
first_impulse_differential_corrector = start_transfer.profiles["Differential Corrector"]
```

Configure the differential corrector for the first impulse:

```{code-cell} ipython3
control_delta_v1_x = first_impulse_differential_corrector.control_parameters.get_control_by_paths("First impulse", "ImpulsiveMnvr.Cartesian.X")
control_delta_v1_x.enable = True
control_delta_v1_x.max_step = 0.30
```

Impose the numerical conditions to be met by the impulse along its X axis:

```{code-cell} ipython3
target_radius_of_apoapsis = first_impulse_differential_corrector.results.get_result_by_paths("First impulse", "Radius Of Apoapsis")
target_radius_of_apoapsis.enable = True
target_radius_of_apoapsis.desired_value = 42238.00
target_radius_of_apoapsis.tolerance = 0.10
```

Establish the maximum number of iterations and an iterative profile search:

```{code-cell} ipython3
first_impulse_differential_corrector.max_iterations = 50
first_impulse_differential_corrector.mode = PROFILE_MODE.ITERATE
```

Finally, run all active profiles in the target sequence:

```{code-cell} ipython3
start_transfer.action = TARGET_SEQ_ACTION.RUN_ACTIVE_PROFILES
```

### Propagate the satellite to the end of the transfer orbit

+++

Once the impulse is solved, the maneuver is complete. The next step is to propagate the satellite to the end of the transfer orbit. This is done by adding a new propagation segment to the main sequence:

```{code-cell} ipython3
propagate_transfer = satellite.propagator.main_sequence.insert(SEGMENT_TYPE.PROPAGATE, "Transfer orbit", "-")
propagate_transfer.properties.color = Colors.Green
propagate_transfer.stopping_conditions.add("Apoapsis")
propagate_transfer.stopping_conditions.remove("Duration")
```

### Final impulse to circularize the orbit

For the final impulse, create a new target sequence:

```{code-cell} ipython3
end_transfer = satellite.propagator.main_sequence.insert(SEGMENT_TYPE.TARGET_SEQUENCE, "End transfer", "-")
```

Next, add a new impulsive maneuver to model the burn to adapt the transfer orbit to the final desired one:

```{code-cell} ipython3
delta_v2 = end_transfer.segments.insert(SEGMENT_TYPE.MANEUVER, "Last impulse", "-")
delta_v2.set_maneuver_type(MANEUVER_TYPE.IMPULSIVE)
```

Again, define the thrust in the direction of the local velocity vector:

```{code-cell} ipython3
delta_v2.maneuver.set_attitude_control_type(ATTITUDE_CONTROL.THRUST_VECTOR)
delta_v2.enable_control_parameter(CONTROL_MANEUVER.IMPULSIVE_CARTESIAN_X)
delta_v2.results.add("Keplerian Elems/Eccentricity");
```

Configure the differential corrector for this target sequence:

```{code-cell} ipython3
last_impulse_differential_corrector = end_transfer.profiles["Differential Corrector"]
```

Configure the differential corrector for the last impulse:

```{code-cell} ipython3
control_delta_v2_x = last_impulse_differential_corrector.control_parameters.get_control_by_paths("Last impulse", "ImpulsiveMnvr.Cartesian.X")
control_delta_v2_x.enable = True
control_delta_v2_x.max_step = 0.30
```

Impose the numerical conditions to be met by the impulse along its X axis:

```{code-cell} ipython3
target_eccentricity = last_impulse_differential_corrector.results.get_result_by_paths("Last impulse", "Eccentricity")
target_eccentricity.enable = True
target_eccentricity.desired_value = 0
target_eccentricity.tolerance = 0.01
```

Again, establish the maximum number of iterations and an iterative profile search:

```{code-cell} ipython3
last_impulse_differential_corrector.enable_display_status = True
last_impulse_differential_corrector.mode = PROFILE_MODE.ITERATE
```

Finally, run all active profiles in the target sequence:
end_transfer.action = TARGET_SEQ_ACTION.RUN_ACTIVE_PROFILES
Propagation along the final orbit

Once the last impulse has been applied, it is possible to propagate the satellite along its final parking orbit. Start by creating a new propagation segment in the main sequence. Propagate the satellite for a total of 86400 seconds.

```{code-cell} ipython3
propagate_final_orbit = satellite.propagator.main_sequence.insert(SEGMENT_TYPE.PROPAGATE, "Propagate final orbit", "-")
propagate_final_orbit.properties.color = Colors.Green
propagate_final_orbit.propagator_name = "Earth Point Mass"
propagate_final_orbit.stopping_conditions["Duration"].properties.trip = 86400.00
```

## Running the main control sequence

Once that all the segments for the main sequence are defined, run the analysis:

```{code-cell} ipython3
satellite.propagator.run_mission_control_sequence()
```

```{code-cell} ipython3
globe_plotter
```
